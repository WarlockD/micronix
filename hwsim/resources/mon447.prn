'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1


                                
                                
                                	subttl	'(c) 1981 Morrow Designs'
                                	title   'MPZ-80  MON4.47 FIRMWARE'
                                
                                	.z80
  0000'                         	aseg
                                
                                ;****************************************************************
                                ;*								*
                                ;* Decision one CPU firmware, for the Morrow Designs / Thinker	*
                                ;* Toys Decision one computer.	The monitor routine looks for	*
                                ;* the power on jump addresses on CPU switches which determine 	*
                                ;* address to begin execution (top 5 switches).	 I/O is through	*
                                ;* the Wunderbus I/O motherboard UART 1.  Base address of the	*
                                ;* I/O is assumed to be standard (beginning at port 48H).	*
                                ;* If top five switches are 'On', a hard disk is assumed to be	*
                                ;* the disk device and Boothd is executed.			*
                                ;*								*
                                ;*  Revised  3/24/82    -       Restore maps before power on    *
                                ;*				jump with switch 6 off for cold *
                                ;*				boot of MOS.			*
                                ;*								*
                                ;*  Revised 12/28/82	-	Fixed PIC init routine		*
                                ;*								*
                                ;*  Revised 11/15/82    -      added nop to wrtask for correct  *
                                ;* 			       delay count			* 
                                ;*								*	
                                ;*  Revised 8/27/82	-	M16 home and load constants	*
                                ;*				changed. group0-3 equates now	*
                                ;*				set int en bit high.		*	
                                ;*								*
                                ;* Bobby Dale Gifford and Bob Groppo        			*
                                ;* 10/20/81							*
                                ;*								*
                                ;****************************************************************
                                
                                	org	0		;Local Ram in task zero
                                
  0200                          tempstk equ	0200h		;temporary stack
  0000                          nop	equ	0
  01B0                          gobuff	equ	01b0h		;location of task switch routine on 'RESET'
  00C3                          jmpop	equ	0c3h		;Jump unstruction op-code
  00CD                          callop	equ	0cdh		;z80 call instruction opcode
  002B                          t1mask	equ	2bh		;unlimited mask... no traps enabled
  002B                          t0mask	equ	2bh		;unlimited mask	
  0036                          ssmode	equ	036h		;single step mode mask
  001A                          hstrap	equ	1Ah		;allow traps on halts and stops, interrupts
                                				;- masked out in task 0 (temporary)
  0001                          window	equ	01h		;task 0 window at location 10000
  000D                          ACR	equ	0Dh		;carriage return
  000A                          ALF	equ	0Ah		;line feed
  0020                          ASP	equ	' '		;space
  000C                          AFF	equ	0Ch		;form feed
  0007                          BEl	equ	07H		;bell
  0008                          BSP	equ	08H		;backspace
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-1
'(c) 1981 Morrow Designs'

  0019                          mskofst	equ	19h		;offset to get to user's mask reg. contents
  0017                          spofst	equ	17h		;offset to stack pointer of user
  0015                          afofst	equ	15h		;offset to user Af register
  0013                          hlofst	equ	13h		;offset to user h,l register
  0011                          deofst	equ	11h		;offset to d,e
  000F                          bcofst	equ	0Fh		;offset to b,c
  000D                          pcofst	equ	0Dh		;offset to the users pc register
  0076                          nxtbyte	equ	076h		;byte after a halt
  0016                          ersav	equ	regsav + 2	;temporary error save area
                                
                                ;****************************************************************
                                ;*								*
                                ;*		   Wunderbus I/O equates:			*
                                ;*								*
                                ;****************************************************************
                                	
  0048                          base	equ	048h		;I/O base address of wunderbus ports
  0008                          group0	equ	08h
  0009                          group1	equ	09h		;serial port 1
  000A                          group2	equ	0ah		;serial	port 2
  000B                          group3	equ	0bh		;serial port 3
  004F                          grpctl	equ	base+7		;I/O group select port
                                
                                ;	UART equates
                                
  0048                          dll	equ	base		;divisor latch lsb
  0049                          dlm	equ	base+1		;divisor latch msb
  0049                          ier	equ	base+1		;interupt enable register
  004B                          lcr	equ	base+3		;line control register
  004C                          mcr	equ	base+4		;modem control register
  004D                          lsr	equ	base+5		;line status register
  0048                          rbr	equ	base		;read data buffer
  0048                          thr	equ	base		;transmitter data buffer
  0080                          dlab	equ	80h		;divisor latch access bit
  0020                          thre	equ	20h		;status line TBE
  0001                          dr	equ	01		;line status DR bit
  0001                          wls0	equ	01		;word length select bit 0
  0002                          wls1	equ	02		;word length select bit 1 (for 8 bit word)
  0004                          stb	equ	04		;stop bit count (2 stop bits)
  0000                          imask	equ	00		;non interupt mode
  0010                          loop	equ	010h		;UART loop mode
                                
                                ;	PIC equates
                                
  0010                          init	equ	010h		;bit high to initialize the PIC
  004C                          icw1	equ	base + 4	;PIC initialization control word 1
  004D                          icw2	equ	base + 5	;PIC initialization control word 2
  004D                          icw3	equ	base + 5	;PIC initialization control word 3
  004D                          icw4	equ	base + 5	;PIC initialization control word 4
  004D                          ocw1	equ	base + 5	;PIC interrupt mask register
  004C                          ocw2	equ	base + 4	;PIC EOI register
  00FF                          picmask equ	0ffh		;mask to turn all interrupts off
  0018                          ltim	equ	018h		;ICW access + level triggered mode
  0004                          adi4	equ	04h		;call address intervals = 4
  0000                          adi8	equ	00h		;call address intervals = 8
  0002                          sngl	equ	02		;sole system PIC
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-2
'(c) 1981 Morrow Designs'

  0001                          ic4	equ	01h		;icw4 access bit
  0000                          lovect	equ	0		;call vectors begin at 0
  0000                          hivect	equ	0		;call vectors begin at 0
  000C                          normal	equ	0ch		;Master/Reg. nest/buffered/no AEOI/8085
                                				; -normal setting of OCW4 for Morrow Software
  0020                          eoi	equ	20h		;non-specific EOI constant
  001F                          ivalu	equ	init OR ltim OR adi4 OR sngl OR ic4 OR lovect
                                
                                ;****************************************************************
                                ;*								*
                                ;*	HDC Winchester controller equates			*
                                ;*								*
                                ;****************************************************************
                                
  000D                          revnum	equ	13		
  0050                          ioaddr	equ	120Q
  0050                          contrl	equ	ioaddr
  0050                          status	equ	ioaddr
  0053                          data	equ	ioaddr+3
  0052                          functn	equ	ioaddr+2
  0051                          commd	equ	ioaddr+1
  0051                          secstat equ	ioaddr+1
  0001                          dread	equ	1
  0001                          sector	equ	1
  0002                          opdone	equ	2
  0004                          complt	equ	4
  0008                          header	equ	10Q
  0005                          drenbl	equ	5
  0007                          dskrun	equ	7
  0020                          ready	equ	40Q
  0080                          system	equ	200Q
  00F8                          stepo	equ	370Q
  00FC                          drivea	equ	374Q
  0001                          trk0	equ	1
                                
                                ;****************************************************************
                                ;*								*
                                ;*	DJ-DMA Equates						*
                                ;*								*
                                ;****************************************************************
                                
  104A                          djstat	equ	104ah		;adjusted channel address of status byte
                                
                                ;****************************************************************
                                ;*								*
                                ;*  	     DMA Winchester Controller Equates			*
                                ;*								*
                                ;****************************************************************
  0099                          cyl	equ	153		;number cylinders for Seagate ST-506
  0004                          heads	equ	  4		;number heads for Seagate ST-506
  001E                          stpdly	equ	 01eh		;15 msec for Seagate ST-506
  00C8                          hdsetl	equ	 0C8h		;20 msec for Seagate ST-506
  0003                          secsiz	equ	  3		;512 byte sectors for Micronix
  0000                          readat	equ	  0		;DMA controller read sector opcode
  0001                          write	equ	  1		;DMA controller write sector opcode
  0002                          rhead	equ	  2		;DMA controller read header opcode
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-3
'(c) 1981 Morrow Designs'

  0003                          format	equ	  3		;DMA controller format track opcode
  0004                          const	equ	  4		;load drive constants command
  0005                          sense	equ	  5		;return drive status command
  0006                          noop	equ	  6		;command used when seeking
  0054                          dmarst	equ	 54h		;DMA controller reset port
  0055                          attn	equ	 55h		;DMA controller Attention port
  0010                          stepout	equ	 10h		;Step direction to track 0
  0000                          stepin	equ	  0		;Step direction away from track 0
  0001                          track0	equ	  1		;track 0 status
  0002                          wfault	equ	  2		;write fault condition from drive
  0004                          dready	equ	  4		;drive ready status
  0008                          sekcmp	equ	  8		;seek complete status
  0011                          hdspt	equ	 17		;number of sectors per track
  1050                          iopb	equ	1050h		;pointer to the channel
  1080                          chan	equ	1080h		;actual channel
  1083                          select	equ	chan + 3	;select byte in channel
  1084                          dmaddr	equ	chan + 4	;24 bit dma address location
  1087                          arg	equ	chan + 7	;beginning of four arguments to commands
  108B                          cmmd	equ	chan + 11	;actual command location
  108C                          statis	equ	chan + 12	;controller return status location 
  108D                          link	equ	chan + 13	;link field address for next command
  1100                          bootad	equ	1100h		;dma address for first sector from hddma
  00FF                          good	equ	0ffh		;good status result
                                
                                
                                
                                ;****************************************************************
                                ;*								*
                                ;* Decision One Ram variables, visible only to task 0.		*
                                ;*								*
                                ;****************************************************************
                                
  0000                          ram	equ	$			;Local RAM, visible only to task 0
                                
                                ;****************************************************************
                                ;*								*
                                ;* Supervisor entry point, this jump must be inserted into the	*
                                ;* CPU's ram by the supervisor for subsequent entry to the	*
                                ;* supervisor when traps occur.					*
                                ;*								*
                                ;****************************************************************
                                
  0000    C3 0000               super:	jp	super			;Supervisor entry point
  0003    C3 0003               user:	jp	user			;(7) User entry point
                                
  0006    00                    ctask:	db	0			;Current task
  0007    00                    cmask:	db	0			;Current mask contents
  0008    0000                  cstack:	dw	0			;temporary save stack
  000A    0000                  u.sp:	dw	0
  000C    0000                  u.pc:	dw	0
  000E    0000                  u.de:	dw	0
  0010    0000                  u.hl:	dw	0
  0012    0000                  u.af:	dw	0
                                
  0014                          begsav	equ	$
  0014    0000                  regsav:	dw	0			;address of beginning of reg save area
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-4
'(c) 1981 Morrow Designs'

  0016                          	ds	1Ch
                                
  0032                          monstk	equ	$			;monitor stack area
                                
  0032                          	ds	(200h - 01eh) - monstk
                                ;********************************************************
                                ;*							*
                                ;*	Initialized stack at 200h contents		*
                                ;*							*
                                ;********************************************************
                                
  01E2    0000                  retstk: dw	0		;return address from call to monitor or super
  01E4    0000                  tskmsk:	dw	0
  01E6    0000                  t.pc:	dw	0
  01E8    0000                  t.sp: 	dw	0		;users stack pointer
  01EA    0000                  t.af:	dw	0		;primary A & f register save
  01EC    0000                  t.bc:	dw	0		;primary b & c register save
  01EE    0000                  t.de:	dw	0		;primary d & e register save
  01F0    0000                  t.hl:	dw	0		;primary h & l register save
  01F2    0000                  t.int:	dw	0		;interrupt register register save
  01F4    0000                  t.ix:	dw	0		; ix register save
  01F6    0000                  t.iy:	dw	0		; iy register save
  01F8    0000                  t.af1:	dw	0		; alternate A & f register save
  01FA    0000                  t.bc1:	dw	0		; alternate b & c register save
  01FC    0000                  t.de1:  dw	0		; alternate d & e register save
  01FE    0000                  t.hl1:  dw 	0		; alternate h & l register save
                                
                                
                                
                                
                                ;****************************************************************
                                ;*								*
                                ;* The following map is used to hold an image of the current	*
                                ;* memory map for all tasks.					*
                                ;*								*
                                ;****************************************************************
                                
  0200                          map:	ds	200h			;Task Memory map image
                                
                                ;****************************************************************
                                ;*								*
                                ;* Decision One local I/O map, the following registers are	*
                                ;* memory mapped into task 0, and are always visible to task	*
                                ;* zero only.							*
                                ;*								*
                                ;****************************************************************
                                
  0400                          locio	equ	$			;Local I/O, visible only to task 0
  0400                          trpadd:	ds	0			;Trapp address register (read)
  0400                          dspseg:	ds	1			;Display segment register (write)
  0401                          keybd:	ds	0			;Key board register (read)
  0401                          dspcol:	ds	1			;Display column register (write)
  0402                          switch:	ds	0			;CPU switch port (read)
  0402                          task:	ds	1			;Task register (write)
  0403                          stats:	ds	0			;Trap status register (read)
  0403                          mask:	ds	1			;Task mask register (write)
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-5
'(c) 1981 Morrow Designs'

  0404                          elocio	equ	$			;End of local I/O
                                
  0404                          	ds	200h-(elocio-locio)	;Fill out local I/O
                                
                                ;****************************************************************
                                ;*								*
                                ;* The following ram is the actual memory map, it can only be	*
                                ;* written into, so an image is kept in the local ram.		*
                                ;*								*
                                ;****************************************************************
                                
  0600                          mapram:	ds	200h			;Memory Map RAM, visible only to task 0
                                
                                ;****************************************************************
                                ;*								*
                                ;* Decision One prom routines, usable by the supervisor task	*
                                ;* but not accessible by any other tasks.			*
                                ;*								*
                                ;****************************************************************
                                
  0800                          rom0	equ	$			;Local ROM, visible only to task 0
                                					;and is visible only during RESET
                                
                                ;****************************************************************
                                ;*								*
                                ;* Reset is executed only once. Currently, reset forms an	*
                                ;* identity map for task zero to occupy the first 64K of main	*
                                ;* memory, allows task 0 to have unlimited priviledges. Task1   *
                                ;* occupies the first 64K, unlimited access and the traps are  	*
                                ;* set for halts or a stop. All other task maps are initialized *
                                ;* starting at bank 2 to bank 15. (e.g. task 15 has bank 15).	*
                                ;* If swithches are set with S1 through S7 off and S8 on, the   *
                                ;* power on jump address will be F800. If switch 6 is on, the	*
                                ;* program will jump to the monitor regardless of the state	*
                                ;* of the other switches.  If S1 - S5 are all 'ON' a MORROW	*
                                ;* hard disk is assumed and the 'Boothd' program is executed.	*
                                ;* If pin 13 of 12C is grounded, the diagnostic mode is entered.*
                                ;*								*
                                ;****************************************************************
                                
                                
                                ; Check all the readable registers
                                
                                
  0800    D3 FF                 regrd:  out	(0ffh),a		;sync
  0802    21 0400               	ld	hl,trpadd
  0805    7E                    	ld	a,(hl)			;read trap address reg @ 400h
  0806    23                    	inc	hl			
  0807    7E                    	ld	a,(hl)			;read keyboard reg @ 401h
  0808    23                    	inc	hl
  0809    7E                    	ld	a,(hl)			;read switch reg @ 402h
  080A    23                    	inc	hl
  080B    7E                    	ld	a,(hl)			;read trap status reg @ 403h
  080C    18 49                 	jr	getsw
                                
                                
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-6
'(c) 1981 Morrow Designs'

                                
                                ; Check all the writable registers
                                
  080E    AF                    regwr:	xor	a			;loop till switch not 00
  080F    D3 FF                 regwr1:	out	(0ffh),a		;sync
  0811    32 0403               	ld	(mask),a		;write to the mask register
  0814    32 0401               	ld	(dspcol),a		;write to the display column register
  0817    32 0400               	ld	(dspseg),a		;write to the display segment reg.
  081A    2F                    	cpl	
  081B    FE FF                 	cp	0ffh
  081D    28 F0                 	jr	z,regwr1
  081F    18 36                 	jr	getsw
                                
                                
                                ; Check the Map RAMs
                                
  0821    AF                    tmap:   xor	a			;write to map ram / protection ram
  0822    21 0600               	ld	hl,mapram
  0825    D3 FF                 	out	(0ffh),a		;sync
  0827    77                    	ld	(hl),a			;write location 600,0
  0828    23                    	inc	hl
  0829    77                    	ld	(hl),a			;write 601,0
  082A    2F                    	cpl
  082B    77                    	ld	(hl),a			;write 601,0ffh
  082C    2B                    	dec	hl
  082D    77                    	ld	(hl),a			;write 600,0ffh
  082E    21 07FE               	ld	hl,mapram + 01feh
  0831    77                    	ld	(hl),a			;write 7fe,0ff
  0832    23                    	inc	hl
  0833    77                    	ld	(hl),a			;write 7ff,0ff
  0834    2F                    	cpl
  0835    77                    	ld	(hl),a			;write 7ff,00
  0836    2B                    	dec	hl
  0837    77                    	ld	(hl),a			;write 7fe,00
  0838    18 1D                 	jr	getsw
                                
                                
                                ; Check the R/W RAMs
                                
                                
  083A    21 0000               tram:	ld	hl,0000h		;write to read/write ram
  083D    D3 FF                 	out	(0ffh),a
  083F    AF                    tram1:	xor	a
  0840    77                    	ld	(hl),a			;write a 00 to ram 
  0841    BE                    	cp	(hl)			;read it back
  0842    2F                    	cpl
  0843    77                    	ld	(hl),a			;write an ffh to ram 
  0844    BE                    	cp	(hl)			;read it back
  0845    CB 44                 	bit	0,h
  0847    20 0E                 	jr	nz,getsw
  0849    21 03FF               	ld	hl,03ffh
  084C    18 F1                 	jr      tram1			;write to 3ffh a ffh
                                
                                
                                ; Check the Floating Point Processor
                                
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-7
'(c) 1981 Morrow Designs'

                                
  084E    AF                    tfpp:   xor	a			;check FPP
  084F    D3 FF                 	out	(0ffh),a		;sync
  0851    32 0C00               	ld	(0c00h),a		;write a 00 to location C00h
  0854    3A 0C00               	ld	a,(0c00h)		;read c00h
                                
                                
  0857    3A 0401               getsw:	ld	a,(keybd)		
  085A    CB 4F                 	bit	1,a
  085C    CA 08D5               reset:	jp	z,reset0		;go to the montior if  low
  085F    3A 0402               	ld	a,(switch)
  0862    CB 57                 	bit	2,a
  0864    CA 08D5               	jp	z,reset0		;go to the monitor if S6 is on
  0867    E6 70                 	and	070h			;strip insignificant bits
  0869    CB 0F                 	rrc	a			;4 byte offset
  086B    CB 0F                 	rrc	a
  086D    21 0BD0               	ld	hl,jtable		;point to beginning of table
  0870    85                    	add	a,l
  0871    6F                    	ld	l,a
  0872    E9                    	jp	(hl)
                                
                                ; Check the S-100 bus addr and data lines
                                
                                
  0873    21 0402               tbus:   ld	hl,task
  0876    3E F0                 	ld	a,0f0h
  0878    77                    	ld	(hl),a			;force upper task bits high
  0879    3E FF                 	ld	a,0ffh			;init the T0 map
  087B    32 061E               	ld	(61eh),a
  087E    3E 03                 	ld	a,03
  0880    32 061F               	ld	(61fh),a
  0883    32 0603               	ld	(603h),a
  0886    AF                    	xor	a
  0887    32 0602               	ld	(602h),a
  088A    D3 FF                 	out	(0ffh),a		;sync
  088C    32 FFFF               	ld	(0ffffh),a		;write - bus addresses A0-23 are high
  088F    77                    	ld	(hl),a			;upper task bits low
  0890    32 1000               	ld	(1000h),a		;write - bus addresses A0-23 are low
  0893    F6 F0                 	or	0f0h
  0895    77                    	ld	(hl),a			;force upper task bits high
  0896    3A FFFF               	ld	a,(0ffffh)		;read  - bus addresses A0-23 are high
  0899    AF                    	xor	a
  089A    77                    	ld	(hl),a		 	;force upper task bits low
  089B    3A 1000               	ld	a,(1000h)		;read  - bus addresses A0-23 are low
  089E    18 B7                 	jr	getsw
                                
                                
  08A0    21 0402               ntbus:  ld	hl,task
  08A3    3E A0                 	ld	a,0A0h
  08A5    77                    	ld	(hl),a			;force upper task bits high
  08A6    3E AA                         ld	a,0aah			;init the T0 map
  08A8    32 061E               	ld	(61eh),a
  08AB    3E 03                 	ld	a,03
  08AD    32 061F               	ld	(61fh),a
  08B0    32 0603               	ld	(603h),a
  08B3    3E 55                 	ld	a,55h
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-8
'(c) 1981 Morrow Designs'

  08B5    32 0602               	ld	(602h),a
  08B8    D3 FF                 	out	(0ffh),a		;sync
  08BA    2F                    	cpl
  08BB    32 FAAA               	ld	(0faaah),a		;write - bus addresses A0-23 = AAAAAA
  08BE    3E 50                 	ld	a,50h
  08C0    77                    	ld	(hl),a			;upper task bits low = 5
  08C1    F6 05                 	or	05h
  08C3    32 1555               	ld	(1555h),a		;write - bus addresses A0-23 are low
  08C6    3E A0                 	ld	a,0A0h
  08C8    77                    	ld	(hl),a			;force upper task bits high
  08C9    3A FAAA               	ld	a,(0faaah)		;read  - bus addresses A0-23 are high
  08CC    3E 50                 	ld	a,050h
  08CE    77                    	ld	(hl),a			;force upper task bits low
  08CF    3A 1555               	ld	a,(1555h)		;read  - bus addresses A0-23 are low
  08D2    C3 0857               	jp	getsw
                                
                                	
                                ; Initialize the maps and jump vectors
                                
                                
  08D5    CD 08E1               reset0: call	reset1
  08D8    CD 0B2B               	call	uartst
  08DB    CD 091A               	call	setup
  08DE    C3 01B0               	jp	gobuff
                                
  08E1    21 0000               reset1:	ld	hl,super		;initialize 'super' to the monitor...
  08E4    2B                    settle:	dec	hl			;wait for hardware to settle down
  08E5    7D                    	ld	a,l
  08E6    B4                    	or	h
  08E7    20 FB                 	jr	nz,settle
  08E9    36 C3                 	ld	(hl),jmpop		;- this will be overwritten by the
  08EB    23                    	inc	hl			;- supervisor but all traps in the 
  08EC    36 00                 	ld	(hl),00h		;- meantime will fall into the monitor.
  08EE    23                    	inc 	hl
  08EF    36 10                 	ld	(hl),10h
  08F1    21 0200               	ld	hl,map
  08F4    22 0008               	ld	(cstack),hl		;initialize a temporary stack
                                
  08F7    AF                    reslop: xor	a
  08F8    0E 03                 	ld	c,3			;New access priviledges
  08FA    47                    reslp2: ld	b,a			;New allocation = segment #
  08FB    CD 0B18               	call	rstmap			;Allocate it
  08FE    3C                    	inc	a			;Next segment #
  08FF    E6 0F                 	and	0fh			;Check if all done
  0901    20 F7                 	jr	nz,reslp2		;Continue until done
  0903    3E 10                         LD	A,10h			;write new task and segment
  0905    06 00                 	LD	B,0			;TASK 1 gets first 64K of memory
  0907    CD 0B18               reslp1: call    rstmap			;Give TASK 1 a full 64k of space
  090A    04                    	inc	B			
  090B    3C                    	inc	A			
  090C    FE 20                 	cp      20h			
  090E    20 F7                 	jr	nz,reslp1						
  0910    47                    fmap:	ld	b,a			;fill all the tasks' maps
  0911    CD 0B18               	call	rstmap
  0914    3C                    	inc	a
  0915    FE 00                 	cp	0h
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-9
'(c) 1981 Morrow Designs'

  0917    20 F7                 	jr	nz,fmap
  0919    C9                    	ret
                                
                                	
                                
  091A    AF                    setup:	xor	a
  091B    32 0602               	ld	(mapram + 2),a		;a window for DMA device commands
  091E    32 0202               	ld	(map + 2),a		;image map updated
  0921    32 0016               	ld	(ersav),a		;null the error save byte
  0924    3E 1A                 	ld	a,hstrap		;initialize the mask register
  0926    32 0403               	ld	(mask),a		; -to trap on halts and stops
  0929    32 0007               	ld	(cmask),a
                                
                                ;	Following code checks for presence of any ram in system
                                
  092C    21 FFFF               	ld	hl,0ffffh		;top of ram
  092F    3E F0                 ramchk:	ld	a,0f0h
  0931    A4                    	and	h
  0932    28 12                 	jr	z,badram		;dont go below task0,seg1	
  0934    77                    	ld	(hl),a			;check it with a 00h
  0935    BE                    	cp	(hl)			
  0936    28 03                 	jr	z,nexchk
  0938    2B                    	dec	hl			;try the next location
  0939    18 F4                 	jr	ramchk
  093B    2F                    nexchk:	cpl	
  093C    77                    	ld	(hl),a			;check it with an ff (might be ROM)
  093D    BE                    	cp	(hl)
  093E    22 0017               	ld	(ersav + 1),hl		;store it away for printing
  0941    28 11                 	jr	z,tstsw					
  0943    2B                    	dec	hl			;try next location
  0944    18 E9                 	jr	ramchk
                                
  0946    21 0BAD               badram: ld	hl,0badh
  0949    22 0017               	ld	(ersav + 1),hl
  094C    3E 4D                 	ld	a,'M'
  094E    32 0016               	ld	(ersav),a
  0951    C3 0A6B               	jp 	allerr			;if no ram force entry to monitor
                                
  0954    3A 0402               tstsw:	ld	a,(switch)		;get contents of switch
  0957    E6 F8                 	and	0f8h			;Ignore irrelevent bits
  0959    57                    	ld	d,a			;d & e contain jump address
  095A    1E 00                 	ld	e,0H
  095C    FE 00                 	cp	0			;boot hard disk if switches are all on
  095E    CA 0AA3               	jp	z,boothd
  0961    FE 08                 	cp	08h			;If switch 5 is off others are on
  0963    CA 09F7               	jp	z,nuboot		; - boot DMA controller
  0966    FE 10                 	cp	10h			;If switches 4 is off, others on
  0968    28 5F                 	jr	z,djdma			; - boot the DJ-DMA floppy device
                                
  096A    3A 0402               check:	ld	a,(switch)		;test monitor switch
  096D    CB 57                 	bit  	2,a
  096F    3E 01                 	ld	a,1			;normal task number
  0971    ED 53 000C            	ld	(u.pc),de		;initialize the  pc save area
  0975    32 0006               	ld	(ctask),a
  0978    28 08                 	jr	z,montor		;jump if monitor desired
  097A    32 0602               	ld	(mapram + 2),a
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-10
'(c) 1981 Morrow Designs'

  097D    32 0202               	ld	(map + 2),a		;restore the maps
  0980    18 04                 	jr	nutask
                                
  0982    AF                    montor:	xor	a			;monitor task number
  0983    11 0916               	ld	de,cold			;monitor location
                                
  0986    21 01B0               nutask: ld	hl,gobuff		;Write a routine to switch to new task
  0989    36 3E                 	ld	(hl),03eh		;- because when the task register is
  098B    23                    	inc	hl			;- written into, the lower half of the
  098C    77                    	ld	(hl),a			;- prom goes away.
  098D    23                    	inc	hl
  098E    36 32                 	ld	(hl),032h
  0990    23                    	inc	hl
  0991    36 02                 	ld	(hl),02h
  0993    23                    	inc	hl
  0994    36 04                 	ld	(hl),04h
  0996    23                    	inc	hl
  0997    36 00                 	ld	(hl),nop		;6 nops for countdown sequence
  0999    23                    	inc	hl
  099A    36 00                 	ld	(hl),nop
  099C    23                    	inc	hl
  099D    36 00                 	ld	(hl),nop
  099F    23                    	inc	hl
  09A0    36 00                 	ld	(hl),nop
  09A2    23                    	inc	hl
  09A3    36 00                 	ld	(hl),nop
  09A5    23                    	inc	hl
  09A6    36 00                 	ld	(hl),nop
  09A8    23                    	inc	hl
  09A9    36 C3                 	ld	(hl),0c3h		;the jump op code
  09AB    23                    	inc	hl
  09AC    73                    	ld	(hl),e
  09AD    23                    	inc	hl
  09AE    72                    	ld	(hl),d
                                
                                
                                ;****************************************************************
                                ;*								*
                                ;*	Wunderbuss I/O and Mult I/O PIC initialization	rou-	*
                                ;*	tine.  Interrupt vectors = restart locations.		*
                                ;*								*
                                ;****************************************************************
                                
  09AF    AF                    picset:	xor     a
  09B0    D3 4F                 	out	(grpctl),a
  09B2    3E 1F                 	ld	a,ivalu
  09B4    D3 4C                 	out	(icw1),a		;initialize the first word
  09B6    3E 00                 	ld	a,hivect
  09B8    D3 4D                 	out	(icw2),a		;initialize the second word
  09BA    3E 0C                 	ld	a,normal
  09BC    D3 4D                 	out	(icw4),a		;initialize the forth word
  09BE    3E FF                 	ld	a,picmask
  09C0    D3 4D                 	out	(ocw1),a		;mask all interrupts
  09C2    3E 20                 	ld	a,eoi			;send PIC an End of Interrupt word
  09C4    D3 4C                 	out	(ocw2),a		;clear the master interrupt requests
  09C6    D3 4C                 	out	(ocw2),a		;clear the slaves interrupt requests
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-11
'(c) 1981 Morrow Designs'

  09C8    C9                    	ret
                                
                                
                                ;****************************************************************
                                ;*								*
                                ;* DJ-DMA floppy disk boot routine (5.25 or 8 inch).		*
                                ;*								*
                                ;****************************************************************
                                
  09C9    26 10                 djdma:	ld	h,10h			; wait byte for 1 minute 
  09CB    01 0000               djlop0:	ld	bc,0000h
  09CE    3A 104A               djloop:	ld	a,(djstat)		;read the status back
  09D1    FE 40                 	cp	040h
  09D3    ED 5B 1048            	ld	de,(djstat - 2)		;d & e point to cold boot loader
  09D7    28 91                 	jr	z,check			;if good status continue set gobuff
  09D9    FE FF                 	cp	0ffh			; - else loop for good status
  09DB    28 14                 	jr	z,nstat			;if 0ffh then force to a zero
  09DD    0B                    	dec	bc
  09DE    78                    	ld	a,b
  09DF    B1                    	or	c
  09E0    20 EC                 	jr	nz,djloop
  09E2    25                    	dec	h
  09E3    20 E6                 	jr	nz,djlop0		;continue looping till a minute elapses
                                
                                ;	DJ-DMA not responding correctly
                                
  09E5    0E 46                 	ld	c,'F'
  09E7    3A 104A               	ld	a,(djstat)
  09EA    47                    	ld	b,a			;save the error status
  09EB    3A 1048               	ld	a,(djstat - 2)
  09EE    57                    	ld	d,a
  09EF    18 71                 	jr	derror			;go to error--controller not
                                					; - responding
                                
  09F1    AF                    nstat: 	xor	a
  09F2    32 104A               	ld	(djstat),a		;null status byte ... signal DJ-DMA
  09F5    18 D7                 	jr	djloop
                                
                                ;****************************************************************
                                ;*								*
                                ;* Hard Disk Boot program for the DMA Winchester Controller.	*
                                ;*								*
                                ;****************************************************************
                                
  09F7    01 0010               nuboot:	ld	bc,endboot - bootbl	;byte count
  09FA    21 0BB3               	ld	hl,bootbl		;source
  09FD    11 1080               	ld	de,chan			;destination
  0A00    ED B0                 	ldir				;move the command
  0A02    21 1050               	ld	hl,iopb			;point to default channel addr
  0A05    36 80                 	ld	(hl),80h		;fill in the command channel address
  0A07    AF                    	xor	a
  0A08    23                    	inc	hl			; -located at 50h to point to channel
  0A09    77                    	ld	(hl),a			; -at 80h.
  0A0A    23                    	inc	hl
  0A0B    77                    	ld	(hl),a
  0A0C    D3 54                 	out	(dmarst),a		;send the controller a reset
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-12
'(c) 1981 Morrow Designs'

  0A0E    11 0010               	ld	de,010h
                                
  0A11    15                    hdrl:	dec	d			;wait for controller to process reset
  0A12    20 FD                 	jr	nz,hdrl
  0A14    CD 0A3E               	call	cloop
                                
  0A17    21 FFFF               home:	ld	hl,-1			;seek to home
  0A1A    22 1081               	ld	(chan + 1),hl		;- with ffff step pulses
  0A1D    3E 06                 	ld	a,noop
  0A1F    32 108B               	ld	(statis - 1),a		;null the command byte
  0A22    3E 01                 	ld	a,1
  0A24    32 108C               	ld	(statis),a		;initialize the status byte
  0A27    CD 0A3E               	call	cloop
                                	
  0A2A    11 1080               rdata: 	ld	de,chan			;destination
  0A2D    01 000D               	ld	bc,endrd - rdtbl	;byte count
  0A30    21 0BC3               	ld	hl,rdtbl		;source
  0A33    ED B0                 	ldir				;move the read sector command
  0A35    CD 0A3E               	call	cloop
  0A38    11 0100               	ld	de,0100h		;point to beginning of DMA boot prog.
  0A3B    C3 096A               	jp	check
                                
                                			
  0A3E    0E 20                 cloop:	ld	c,020h
  0A40    D3 55                 cloop0:	out	(attn),a
  0A42    11 0000               	ld	de,0000h
  0A45    3A 108C               cloop1: ld	a,(statis)		;check drive status
  0A48    FE FF                 	cp	0ffh			;an FF means command completed
  0A4A    C8                    	ret	z
  0A4B    1B                    	dec	de			;wait for controller to respond
  0A4C    7B                    	ld	a,e
  0A4D    B2                    	or	d
  0A4E    20 F5                 	jr	nz,cloop1		;give it a couple seconds to respond
                                
                                ;	Fall through to here on any error
                                
  0A50    3A 108C               	ld	a,(statis)
  0A53    FE 01                 	cp	01h
  0A55    20 03                 	jr	nz,cloop2	
  0A57    0D                    	dec	c			;give it 10 tries if not rdy error
  0A58    20 E6                 	jr	nz,cloop0		; - about 20 seconds
                                
  0A5A    D1                    cloop2:	pop	de			;re-align the stack pointer
  0A5B    0E 48                 	ld	c,'H'			;save the device
  0A5D    47                    	ld	b,a			;save the status
  0A5E    3A 108B               	ld	a,(cmmd)		;save the command
  0A61    57                    	ld	d,a
                                
                                ;****************************************************************
                                ;*								*
                                ;*  Enter here if DISK controllers don't respond correctly.	*
                                ;*  Routine alters gobuff to point to the monitor cout routine.	*	
                                ;*								*
                                ;****************************************************************
                                
  0A62                          derror:	
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-13
'(c) 1981 Morrow Designs'

  0A62    79                    	ld	a,c
  0A63    21 0016               	ld	hl,ersav
  0A66    77                    	ld	(hl),a			;store c for later
  0A67    23                    	inc	hl
  0A68    70                    	ld	(hl),b			;error status
  0A69    23                    	inc	hl
  0A6A    72                    	ld	(hl),d			;command causing error 
                                
  0A6B    AF                    allerr:	xor	a
  0A6C    32 0006               	ld	(ctask),a
  0A6F    11 0916               	ld	de,cold			;pointer to error print
  0A72    ED 53 000C            	ld	(u.pc),de		;save the pointer in t1 pc
  0A76    C3 0986               	jp	nutask			
                                	
                                
                                	
                                ;****************************************************************
                                ;*								*
                                ;* Hard Disk Boot program for Decision 1 EPROM.			*
                                ;* For M26, M10, and M20.					*
                                ;*						11/4/81  BJG	*
                                ;****************************************************************
                                
  0A79    11 0000               hdclop:	ld	de,0000h
  0A7C    DB 50                 hdlop1: in	a,(status)
  0A7E    A0                    	and	b
  0A7F    C0                    	ret	nz
  0A80    1B                    	dec	de
  0A81    7A                    	ld	a,d
  0A82    B3                    	or	e
  0A83    20 F7                 	jr	nz,hdlop1
  0A85    18 12                 	jr	hdcerr
                                
  0A87    26 10                 wait:	ld	h,010h
  0A89    11 0000               wait0:	ld	de,0
  0A8C    DB 50                 wait1:	in	a,(status)
  0A8E    A0                    	and	b
  0A8F    C8                    	ret	z
  0A90    1B                    	dec	de
  0A91    7A                    	ld	a,d
  0A92    B3                    	or	e
  0A93    20 F7                 	jr	nz,wait1
  0A95    25                    	dec	h
  0A96    20 F1                 	jr	nz,wait0
  0A98    E1                    	pop	hl			;re-align the stack pointer
  0A99    0E 44                 hdcerr: ld	c,'D'			; D for HDCA error flag
  0A9B    DB 50                 	in	a,(status)		;get the primary status
  0A9D    47                    	ld	b,a
  0A9E    DB 51                 	in	a,(secstat)		;get the secondary status
  0AA0    57                    	ld	d,a
  0AA1    18 BF                 	jr	derror
                                	
  0AA3    3E FC                 boothd:	ld	a,drivea		;select
  0AA5    D3 52                 	out	(functn),a		;    drive A
  0AA7    3E 05                 	ld	a,drenbl		;turn on drive
  0AA9    D3 50                 	out	(contrl),a		;    command register
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-14
'(c) 1981 Morrow Designs'

                                
  0AAB    06 20                 rloop:	ld	b,ready
  0AAD    CD 0A87               	call	wait
  0AB0    3E 07                 	ld	a,dskrun		;enable the
  0AB2    D3 50                 	out	(contrl),a		;    controller
                                
  0AB4    DB 50                 waitz:	in	a,(status)		;test for heads at track 0
  0AB6    1F                    	rra
  0AB7    30 0F                 	jr	nc,sdone
  0AB9    3E F8                 	ld	a,stepo			;execute
  0ABB    D3 52                 	out	(functn),a		;    the
  0ABD    3E FC                 	ld	a,drivea		;    step out
  0ABF    D3 52                 	out	(functn),a		;    command
                                
  0AC1    06 04                 waitc:  ld	b,complt
  0AC3    CD 0A79               	call	hdclop
  0AC6    18 EC                 	jr	waitz
                                
  0AC8    DB 50                 sdone:	in	a,(status)		;get an image
  0ACA    4F                    	ld	c,a			;    of the status reg
                                
  0ACB    DB 50                 iwait1: in	a,(status)		;wait for
  0ACD    91                    	sub	c			;    the index pulse
  0ACE    28 FB                 	jr	z,iwait1		;    to arrive
                                
  0AD0    DB 50                 iwait2: in	a,(status)		;wait for the
  0AD2    91                    	sub	c			;    next index pulse
  0AD3    20 FB                 	jr	nz,iwait2		;test for head settle
                                
  0AD5    DB 50                 iwait3:	in	a,(status)
  0AD7    91                    	sub	c
  0AD8    28 FB                 	jr	z,iwait3
  0ADA    3E 08                 	ld	a,header		;reset the
  0ADC    D3 51                 	out	(commd),a		;    buffer pointer
  0ADE    AF                    	xor	a			;    to header area
  0ADF    D3 53                 	out	(data),a		;head 0
  0AE1    D3 53                 	out	(data),a		;track 0
  0AE3    3C                    	inc	a			;sector 1
  0AE4    D3 53                 	out	(data),a		    
  0AE6    3E 80                 	ld	a,system		;system key
  0AE8    D3 53                 	out	(data),a
  0AEA    3E 01                 	ld	a,dread			;issue a
  0AEC    D3 51                 	out	(commd),a		;    read command
                                
  0AEE    06 02                 waitd:	ld	b,opdone
  0AF0    CD 0A79               	call	hdclop
  0AF3    DB 53                 	in	a,(data)		;low order byte of
  0AF5    6F                    	ld	l,a			;    bootstrap address
  0AF6    5F                    	ld	e,a
  0AF7    DB 53                 	in	a,(data)		;high order byte of
  0AF9    67                    	ld	h,a			;    bootstrap address
  0AFA    57                    	ld	d,a
  0AFB    E6 F0                 	and	0f0h			;check for 1st segment of task0
  0AFD    28 11                 	jr	z,dxloop
  0AFF    AF                    	xor	a
  0B00    32 0602               	ld	(mapram + 2),a		;T0 map is as normal with no window
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-15
'(c) 1981 Morrow Designs'

                                
                                
  0B03    DB 53                 lloop:	in	a,(data)		;load
  0B05    12                    	ld	(de),a			;    the
  0B06    1C                    	inc	e			;    bootstrap
  0B07    20 FA                 	jr	nz,lloop
  0B09    54                    	ld	d,h			;save the boot addr for later
  0B0A    5D                    	ld	e,l
  0B0B    3E 01                 	ld	a,01
  0B0D    C3 096A               	jp	check
                                
  0B10    7A                    dxloop: ld	a,d
  0B11    E6 0F                 	and	0fh			;strip the segment #
  0B13    F6 10                 	or	010h			; force the load into seg 0 task 1
  0B15    57                    	ld	d,a
  0B16    18 EB                 	jr	lloop
                                
                                
                                ;****************************************************************
                                ;*								*
                                ;* Rstmap writes the tasks memory allocation vectors. Upon	*
                                ;* entry the registers must contain:				*
                                ;*	a = task number / task segment number to update		*
                                ;*          high nibble = task #    low nibble = segment #	*
                                ;*	b = New allocation vector				*
                                ;*	c = New allocation access				*
                                ;*								*	
                                ;* Routine calculates the expression  600+(Accumulator) x 2 	*
                                ;* where accumulator contents are as listed above.  All arit-   * 	
                                ;* hmetic and numbers are in Hex				*
                                ;*  						 		*
                                ;****************************************************************
                                
  0B18    6F                    rstmap:	ld	l,a             ;Get task and segment numbers       
  0B19    26 00                         ld	h,0h    
  0B1B    29                    	add	hl,hl           ;multiply times 2       
  0B1C    EB                            ex	de,hl  		;save calculated offset in D,E
  0B1D    21 0600                       ld	hl,mapram       ;point to beginning of ram map
  0B20    CD 0B26                       call    rstmxx            
  0B23    21 0200               	ld	hl,map		;point to image map at 200
  0B26    19                    rstmxx:	add	hl,de		;add offset to selected map
  0B27    70                    	ld	(hl),b          ;write the allocation vector to ram
  0B28    23                    	inc	hl		;point to access ram
  0B29    71                    	ld	(hl),c          ;write access attributes to ram
  0B2A    C9                    	ret
                                
                                ;********************************************************
                                ;*							*
                                ;*  The following code intitializes the I/O for		*
                                ;*  the Decision 1 Motherboard and the Mult I/O.	*
                                ;*  							*
                                ;********************************************************
                                
                                
  0B2B    16 03                 uartst:	ld	d,3			;start with uart 3
  0B2D    7A                    uarts0:	ld	a,d
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-16
'(c) 1981 Morrow Designs'

  0B2E    D3 4F                 	out   	(grpctl),a
  0B30    AF                    	xor 	a
  0B31    D3 4D                 	out	(lsr),a			;clear line status register 
  0B33    D3 49                 	out 	(ier),a			;initialialize interupt mask (off)
  0B35    15                    	dec	d
  0B36    20 F5                 	jr	nz,uarts0
  0B38    D3 4F                 	out 	(grpctl),a		;select sense switch port
  0B3A    DB 49                 	in	a,(base+1)		
  0B3C    07                    	rlca
  0B3D    07                    	rlca
  0B3E    07                    	rlca
  0B3F    E6 07                 	and	07h			;mask insignificant bits
  0B41    FE 07                 	cp	07h			;all off?
  0B43    16 00                 	ld	d,0
  0B45    28 0B                 	jr	z,default		;default if all off
  0B47    21 0BA5               	ld	hl,btable		;point to baud rate table
  0B4A    87                    	add 	a,a
  0B4B    5F                    	ld	e,a
  0B4C    19                    	add 	hl,de			;offset to selected baud rate
  0B4D    4E                    	ld	c,(hl)
  0B4E    23                    	inc	hl
  0B4F    46                    	ld	b,(hl)			;bc = baud rate divisor value (D)
  0B50    18 03                 	jr	setit
                                
  0B52                          default:
  0B52    01 000C               	ld	bc,12			;default baud rate is 9600
                                
  0B55    14                    setit:	inc	d
  0B56    7A                    	ld	a,d
  0B57    D3 4F                 	out	(grpctl),a
  0B59    3E 87                 	ld	a,dlab+wls1+wls0+stb
  0B5B    D3 4B                 	out 	(lcr),a			;divisor access bit is on
  0B5D    78                    	ld	a,b
  0B5E    D3 49                 	out 	(dlm),a			;load high divisor register
  0B60    79                    	ld	a,c
  0B61    D3 48                 	out 	(dll),a			;load low divisor register
  0B63    3E 07                 	ld	a,wls1+wls0+stb
  0B65    D3 4B                 	out 	(lcr),a			;divisor access bit is off
  0B67    3E 10                         ld	a,loop			;clear the shift register
  0B69    D3 4C                 	out	(mcr),a			; - by looping back.
  0B6B    DB 48                 	in	a,(rbr)			;clear receiver buffer
  0B6D    AF                    	xor	a
  0B6E    D3 48                 	out	(thr),a			;clear transmitter buffer
  0B70    CD 0B9E               	call	begin0
  0B73    DB 48                 	in	a,(rbr)
  0B75    AF                    	xor	a
  0B76    D3 48                 	out	(thr),a
  0B78    CD 0B9E               	call	begin0			;two times to make sure
  0B7B    DB 4D                 rduart:	in	a,(lsr)
  0B7D    E6 01                 	and	dr 			;check for data available
  0B7F    28 FA                 	jr	z,rduart
  0B81    DB 48                 	in	a,(rbr)			;intitialize receiver buffer
  0B83    FE 00                 	cp	0
  0B85    28 0F                 	jr	z,contin		;jump if UARTS good
                                
  0B87    F5                    urterr:	push 	af
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-17
'(c) 1981 Morrow Designs'

  0B88    3E 55                 	ld	a,'U'
  0B8A    32 0016               	ld	(ersav),a		;Uart error
  0B8D    7A                    	ld	a,d			
  0B8E    32 0018               	ld	(ersav + 2),a		;Uart # saved
  0B91    F1                    	pop	af
  0B92    32 0017               	ld	(ersav + 1),a		;bad character saved
  0B95    AF                    	xor	a
                                
  0B96    D3 4C                 contin:	out	(mcr),a
  0B98    7A                    	ld	a,d
  0B99    FE 03                 	cp	3			;initialize all three uarts
  0B9B    C8                    	ret	z
  0B9C    18 B7                 	jr	setit
                                
  0B9E    DB 4D                 begin0:	in	a,(lsr)
  0BA0    E6 20                 	and	thre
  0BA2    28 FA                 	jr	z,begin0
  0BA4    C9                    	ret
                                
                                
                                ;  Baud rate selection table for Mult I/o or WB I/O
                                
  0BA5    0417                  btable:	dw	1047			;110 baud		0 0 0
  0BA7    0180                  	dw	384			;300 baud		0 0 1
  0BA9    0060                  	dw	96			;1200 baud		0 1 0
  0BAB    0030                  	dw	48			;2400 baud		0 1 1
  0BAD    0018                  	dw	24			;4800 baud		1 0 0
  0BAF    000C                  	dw	12			;9600 baud		1 0 1
  0BB1    0006                  	dw	6			;19200 baud		1 1 0
                                
                                ; Load constants command for the DMA Winchester controller
                                
  0BB3    10                    bootbl: db	10h			;direction --> track 0
  0BB4    00                    	db	0			;low steps
  0BB5    00                    	db	0			;high steps
  0BB6    3C                    	db	03ch			;select drive 0
  0BB7    00                    	db	0			;low dma address
  0BB8    01                    	db	01			;high dma address
  0BB9    00                    	db	0			;extended dma address
  0BBA    00                    	db	0			;argument 0
  0BBB    1E                    	db	stpdly			;argument 1
  0BBC    C8                    	db	hdsetl			;argument 2
  0BBD    03                    	db	secsiz			;argument 3
  0BBE    04                    	db	const			;load constants opcode
  0BBF    00                    	db	0			;clear status byte
  0BC0    80                    	db	80h			;low link address
  0BC1    00                    	db	0			;high link address
  0BC2    00                    	db	0			;extended link address
                                
  0BC3                          endboot equ	$
                                
                                ; Read sector 1, head 0, cyl 0  command for the HD-DMA:
                                
  0BC3    00                    rdtbl:	db	0			;no seek
  0BC4    00                    	db	0
  0BC5    00                    	db	0
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-18
'(c) 1981 Morrow Designs'

  0BC6    7C                    	db	07ch			;select drive 0, head 0 
  0BC7    00                    	db	0			;dma address of 100h
  0BC8    01                    	db	1
  0BC9    00                    	db	0
  0BCA    00                    	db	0			;low byte cylinder
  0BCB    00                    	db	0			;high byte cylinder
  0BCC    00                    	db	0			;head 0
  0BCD    00                    	db	0			;sector 1
  0BCE    00                    	db	0			;read command
  0BCF    00                    	db	0			;clear status
                                
  0BD0                          endrd 	equ	$
                                
                                
                                ; Dispatch table for the on-board diagnostic routines
                                
  0BD0                          jtable	equ 	$
  0BD0    C3 0800               	jp	regrd			;test all the readable registers
  0BD3    00                    	db	0
  0BD4    C3 080E               	jp	regwr			;check all the writable registers but
                                 					; -task register
  0BD7    00                    	db	0
  0BD8    C3 0821               	jp	tmap			;check map rams
  0BDB    00                    	db	0
  0BDC    C3 083A               	jp	tram			;check read/write ram
  0BDF    00                    	db 	0
  0BE0    C3 084E               	jp	tfpp			;check fpp
  0BE3    00                    	db	0
  0BE4    C3 0873               	jp	tbus			;check bus read/write addresses
  0BE7    00                    	db	0
  0BE8    C3 08A0               	jp	ntbus			;R/W bus with 055h and 0aah
  0BEB    00                    	db	0
  0BEC    18 0B                 	jr	start			;yet to be defined
                                	
                                	
  0BEE                          ecode0  equ	$			;End of reset prom code
                                
  0BEE                          	ds	3f0h-(ecode0-rom0)	;Fill out the prom
                                
                                ;****************************************************************
                                ;*								*
                                ;* The following special piece of code is where the user task	*
                                ;* begins executing when a reset trap occurs. 			*
                                ;*								*
                                ;****************************************************************
                                
  0BF0    21 104A               	ld	hl,djstat
  0BF3    3E 00                 	ld	a,0h
  0BF5    32 0602               	ld	(mapram + 2),a		;t0 map points to t1 map seg 0
  0BF8    3C                    	inc	a
  0BF9    31 0200               start:	ld	sp,map
  0BFC    C3 0857               	jp	getsw 		        ;power-on or reset jump
  0BFF    00                    	nop				;Fill out the prom.
  0C00                          erom0   equ	$
                                
  0C00                          	ds	400h-(erom0-rom0)
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-19
'(c) 1981 Morrow Designs'

                                
                                
                                	.phase 800h  
                                
                                ;****************************************************************
                                ;*								*
                                ;*	This code is usuable by the supervisor task (task0)    	*
                                ;*	but is not accessible to any other tasks. Any trap	*
                                ;*      other than a reset will enable this half of the eprom	*
                                ;*	as well.						*
                                ;*								*
                                ;****************************************************************
                                
                                
  0800                          	rom1	equ	$
                                
                                ;****************************************************************
                                ;*								*
                                ;*          ===>>  J U M P   T A B L E   <<===			*
                                ;*								*
                                ;****************************************************************
                                
  0800    C3 0821               svtrap:	jp	trappd			;trap routine, check out reason why
  0803    C3 0812               tskbse: jp	what			;vestigial
  0806    C3 08E7               nmap:	jp	putmap			;set up new allocation vector, access 
  0809    C3 089E               gotsk:	jp	gotask			;switch to new task
  080C    C3 08DA               getmap:	jp	gtmap			;get the old allocation vector, access
  080F    C3 0812               dupmap: jp	what			;vestigial
  0812    C3 08FA               what:	jp	monitor			;debugger/monitor called 'MON'
  0815    C3 0893               restr: 	jp	restor			;restore task 0 map to normal condition
  0818                          oldtask:
  0818    C3 0809               	jp	gotsk			;jumps to last task before trap
  081B    C3 0885               wrtask: jp	writsk			;writes value in CTASK to task register
  081E    C3 0888               wratsk:	jp	atask			;writes value in 'A' to  task register
                                
                                	
  0821    11 FFF1               trappd:	ld	de,-15			;back up the users pc
  0824    E1                    	pop	hl
  0825    19                    	add	hl,de
  0826    22 000C               	ld	(u.pc),hl
  0829    3A 0006               	ld	a,(ctask)
  082C    FE 00                 	cp	0
  082E    CA 0872               	jp	z,suptrap
  0831    D1                    	pop	de
  0832    E1                    	pop	hl
  0833    F1                    	pop	Af
  0834    ED 7B 0008            	ld	sp,(cstack)		;set up reg_save stack in supervisor
  0838    08                    alltrp:	ex 	Af,Af'			;save user's auxiliary registers
  0839    D9                    	exx
  083A    E5                    	push	hl
  083B    D5                    	push	de
  083C    C5                    	push	bc
  083D    F5                    	push	Af
  083E    FD E5                 	push	iy
  0840    DD E5                 	push	ix
  0842    ED 57                 	ld	a,i			;get interupt register
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-20
'(c) 1981 Morrow Designs'

  0844    F5                    	push	af			;save it
  0845    08                    	ex	Af',Af
  0846    D9                    	exx
  0847    E5                    	push	hl			;- and save all user registers
  0848    D5                    	push	de
  0849    C5                    	push	bc
  084A    F5                    	push	Af
  084B    2A 0006               	ld	hl,(ctask)		;save the task and mask
  084E    ED 5B 000A            	ld	de,(u.sp)		;get the user's stack pointer
  0852    ED 4B 000C            	ld	bc,(u.pc)
  0856    D5                    	push	de			;save the user's stack pointer
  0857    C5                    	push	bc			;save the user's program counter
  0858    E5                    	push	hl			;save the current task and mask
  0859    ED 73 0014            	ld	(regsav),sp		;beginning address of reg save area
                                					; - saved here.
                                
                                	;Stop switch calls the monitor - return will restore to "CTASK"
                                
  085D    7D                    	ld	a,l			;get the trapped task #
  085E    FE 00                 	cp	0
  0860    28 07                 	jr	z,gowhat		;if trap was in task 0, go to monitor
  0862    3A 0403               	ld	a,(stats)
  0865    CB 67                 	bit	4,a
  0867    20 13                 	jr	nz,gosupr		;go to super unless it was a stop trap 
                                
  0869    AF                    gowhat:	xor 	a
  086A    32 0006               	ld	(ctask),a
  086D    CD 0812               	call	what
  0870    18 2C                 	jr	gotask
                                
  0872                          suptrap:
  0872    D1                    	pop	de
  0873    E1                    	pop	hl
  0874    F1                    	pop	Af
  0875    ED 7B 000A            	ld	sp,(u.sp)
  0879    C3 0838               	jp	alltrp	
                                
                                	;Call the supervisor - a return will restore the task in "CTASK"
                                
  087C    AF                    gosupr:	xor	a
  087D    32 0006               	ld	(ctask),a
  0880    CD 0000               	call	super		
  0883    18 19                 	jr	gotask
                                
                                
                                ;********************************************************
                                ;*							*
                                ;*  Writsk will take the value in CTASK and write it	*
                                ;*  to the TASK register.  It then waits 6 instructions	*
                                ;*  for the hardware delay and returns with traps set 	*
                                ;*  and operation in the task selected.	 The 'A' re-	*
                                ;*  gister is not preserved, all others untouched.	*
                                ;*							*
                                ;********************************************************
                                
  0885    3A 0006               writsk:	ld	a,(ctask)
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-21
'(c) 1981 Morrow Designs'

  0888    32 0402               atask:	ld	(task),a        ;update the task register and count   
  088B    00                    	nop			; - 7 instructions to delay for the 
  088C    00                    	nop			; - hardware swap counter.
  088D    00                    	nop
  088E    00                    	nop
  088F    00                    	nop
  0890    00                    	nop
  0891    00                    	nop
  0892    C9                    	ret
                                
                                
                                ;********************************************************
                                ;*							*
                                ;*   Restore will restore Task 0's map with its old 	*
                                ;*   values.  This assumes that if the map for task 0   *
                                ;*   has been changed, that only the actual map had 	*
                                ;*   been changed and that the image map was left in	*
                                ;*   the condition before the change occurred.		*
                                ;*							*
                                ;********************************************************
                                
                                
  0893    21 0200               restor:	ld 	hl,map			;point to beginning of map image
  0896    11 0600               	ld	de,mapram		;point to beginning of actual map
  0899    01 001F               	ld	bc,01Fh			;all of task 0 map 
  089C    ED B0                 	ldir
                                
                                ;****************************************************************
                                ;*								*
                                ;*	Gotask restores all the task's registers  and then	*
                                ;*	switches to that task.                 			*
                                ;*								*
                                ;****************************************************************
                                
  089E    21 0000               gotask:	ld	hl,0			;init hl for normal entry
  08A1    39                    	add	hl,sp
  08A2    F9                    ntask:	ld	sp,hl
  08A3    E1                    	pop	hl
  08A4    22 0006               	ld	(ctask),hl		;get back CTASK and CMASK
  08A7    E1                    	pop	hl
  08A8    22 000C               	ld	(u.pc),hl		;get back the user's pc
  08AB    E1                    	pop	hl
  08AC    22 000A               	ld	(u.sp),hl		;get back the user's sp
  08AF    F1                    	pop	Af			;get back the primary registers
  08B0    C1                    	pop	bc
  08B1    D1                    	pop	de
  08B2    E1                    	pop	hl
  08B3    08                    	ex	Af',Af
  08B4    D9                    	exx
  08B5    F1                    	pop	Af			;get back the interrupt register
  08B6    ED 47                 	ld	i,a			;restore it
  08B8    DD E1                 	pop	ix			;restore auxilliary registers
  08BA    FD E1                 	pop	iy
  08BC    2A 000C               	ld	hl,(u.pc)		
  08BF    22 0004               bcomnd:	ld	(user + 1),hl		;form jump to user's pc value @ user
  08C2    3E C3                 	ld	a,jmpop
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-22
'(c) 1981 Morrow Designs'

  08C4    32 0003               	ld	(user),a
  08C7    F1                    	pop	Af			;restore the alternate registers
  08C8    C1                    	pop	bc
  08C9    D1                    	pop	de
  08CA    2A 0006               	ld	hl,(ctask)
  08CD    22 0402               	ld	(task),hl		;write the new task and mask
  08D0    E1                    	pop	hl
  08D1    08                    	ex	Af,Af'
  08D2    D9                    	exx
  08D3    ED 7B 000A            	ld	sp,(u.sp)
  08D7    C3 0003               	jp	user
                                	
                                					
                                ;********************************************************
                                ;*							*
                                ;*  The following code will return with:		*
                                ;*      Register A = task #/ segment #			*
                                ;*	Register B = old allocation vector		*
                                ;*	Register C = old access	priviledges		*
                                ;*  Upon entry, it expects the A register to have	*
                                ;*  the desired task# / segment #. Consider this to be	*
                                ;*  opposite of the putmap routine.			*
                                ;*							*
                                ;********************************************************
                                
  08DA    6F                    gtmap:	ld	l,a		;get task and segment numbers
  08DB    26 00                 	ld	h,0h		
  08DD    29                    	add	hl,hl		;multiply times 2
  08DE    EB                    	ex	de,hl		;save calculated offset in de
  08DF    21 0200               	ld	hl,map		;point to beginning of map ram image
  08E2    19                    	add	hl,de		;add offset to get desired map
  08E3    46                    	ld	b,(HL)		;get old allocation vector
  08E4    23                    	inc	hl		;offset to access map
  08E5    4E                    	ld	c,(HL)		;get old access priviledges
  08E6    C9                    	ret 	
                                		
                                			
                                ;********************************************************
                                ;*							*
                                ;*  Putmap updates a task's allocation vectors and	*
                                ;*  access atributes.  Upon entry, registers must	*
                                ;*  contain:						*
                                ;*	a = task # / task segment # to update		*
                                ;*	    high nibble = task#, low nibble = segment#	*
                                ;*	b = new allocation vector			*
                                ;*	c = new access privilidges			*
                                ;*							*
                                ;*  Routine calculates the expression 600 + (a) X 2	*
                                ;*  where a is as listed above.  All arithmetic and	*
                                ;*  numbers are in Hex.					*
                                ;*							*
                                ;********************************************************
                                
  08E7    6F                    putmap:	ld	l,a			;get task and segment number
  08E8    26 00                 	ld	h,0h			;
  08EA    29                    	add	hl,hl			;multiply times 2
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-23
'(c) 1981 Morrow Designs'

  08EB    EB                    	ex 	de,hl			;save calculated offset in de
  08EC    21 0600               	ld	hl,mapram		;point to beginning of ram map
  08EF    CD 08F5               	call 	putmxx			
  08F2    21 0200               	ld	hl,map			;point to beginning of image map
  08F5    19                    putmxx: add	hl,de			;add offset to selected map
  08F6    70                    	ld	(hl),b			;write the allocation vector
  08F7    23                    	inc	hl			;point to access attribute ram
  08F8    71                    	ld	(hl),c			;write new access atributes
  08F9    C9                    	ret
                                
                                	
                                ;********************************************************	
                                ;*							*
                                ;*  The following routines make up the debugging tool	*
                                ;*  monitor  						*
                                ;*							*
                                ;********************************************************
                                
  08FA                          monitor:
  08FA    ED 73 0030            	ld	(monstk -2),sp		;save stack for 'u' & 'c' commands
  08FE    FD 2A 0030            	ld	iy,(monstk-2)
  0902    31 0032               	ld	sp,monstk
  0905    2A 0014               	ld	hl,(regsav)		;get the stack location
  0908    11 001B               	ld	de,27			;number of saved registers
  090B    E5                    	push	hl
  090C    19                    	add	hl,de
  090D    EB                    	ex	de,hl
  090E    E1                    	pop	hl
  090F    01 0923               	ld	bc,ustart
  0912    C5                    	push	bc
  0913    C3 094A               	jp	udi0			;print out the registers
                                
  0916    3A 0016               cold:	ld	a,(ersav)		;retrieve the error byte if any
  0919    4F                    	ld	c,a
  091A    CD 0A39               	call	ucout1			;print it
  091D    2A 0017               	ld	hl,(ersav + 1)		;retrieve disk command
  0920    CD 0AC8               	call	uladr
                                
  0923    31 0032               ustart:	ld	sp,monstk
  0926    11 0923               	LD	DE,USTART
  0929    D5                    	PUSH	DE
  092A    CD 0A06               	CALL	UCRLF
  092D    0E 3A                 	LD	C,':'
  092F    CD 0A39               	CALL	ucout1
  0932    CD 0B09               USTAR0:	CALL	UTI
  0935    B7                    	OR	A
  0936    28 FA                 	JR	Z,USTAR0
  0938    FE 7B                 	CP	'z'+1
  093A    D2 0A25               	JP	NC,UERROR
  093D    0E 02                 	LD	C,002H
  093F    FE 44                 	CP	'D'
  0941    28 04                 	JR	Z,udisp
  0943    FE 64                 	cp	'd'
  0945    20 19                 	jr	nz,ufill
                                
                                ;
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-24
'(c) 1981 Morrow Designs'

                                ;	DISPLAY MEMORY XXXX TO XXXX
                                ;
                                ;
  0947    CD 0A01               UDISP:	CALL	UEXLF
  094A    CD 0A06               UDI0:	CALL	UCRLF
  094D    CD 0AC8               	CALL	ULADR
  0950    06 10                 	LD	B,010H
  0952    CD 0A37               UDI1:	CALL	UBLK
  0955    7E                    	LD	A,(HL)
  0956    CD 0ACD               	CALL	ULBYTE
  0959    CD 0AA4               	CALL	UHILOX
  095C    10 F4                 	DJNZ	UDI1
  095E    18 EA                 	JR	UDI0
                                ;
                                ;
                                ;
                                ;	FILL MEMORY XXXX TO XXXX WITH XX
                                ;
                                ;
                                ;
  0960    FE 46                 UFILL:	CP	'F'
  0962    28 04                 	JR	z,ufill0
  0964    FE 66                 	cp	'f'
  0966    20 0D                 	jr	nz,ugoto
  0968    CD 0A72               ufill0:	CALL	UEXPR3
  096B    71                    UFI0:	LD	(HL),C
  096C    CD 0AAA               	CALL	UHILO
  096F    30 FA                 	JR	NC,UFI0
  0971    D1                    	POP	DE
  0972    C3 0923               	JP	USTART
                                ;
                                ;
                                ;	GOTO (EXECUTE) XXXX
                                ;
                                ;
  0975    FE 47                 UGOTO:	CP	'G'
  0977    28 04                 	JR	Z,ugoto0
  0979    FE 67                 	cp	'g'
  097B    20 08                 	jr	nz,umtest
  097D    CD 0A7D               ugoto0:	CALL	UEXPR1
  0980    CD 0A06               	CALL	UCRLF
  0983    E1                    	POP	HL
  0984    E9                    	JP	(HL)
                                ;
                                ;
                                ;	TEST MEMORY XXXX TO XXXX
                                ;
                                ;
  0985    FE 54                 UMTEST:	CP	'T'
  0987    28 04                 	JR	Z,ut10
  0989    FE 74                 	cp	't'
  098B    20 1C                 	jr	nz,umove
  098D    CD 0A01               ut10:	CALL	UEXLF
  0990    7E                    UT1:	LD	A,(HL)
  0991    47                    	LD	B,A
  0992    2F                    	CPL
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-25
'(c) 1981 Morrow Designs'

  0993    77                    	LD	(HL),A
  0994    AE                    	XOR	(HL)
  0995    28 0C                 	JR	Z,UT2
  0997    D5                    	PUSH	DE
  0998    5F                    	LD	E,A
  0999    CD 0A34               	CALL	UHLSP
  099C    CD 0B40               	CALL	UQI1
  099F    CD 0A06               	CALL	UCRLF
  09A2    D1                    	POP	DE
  09A3    70                    UT2:	LD	(HL),B
  09A4    CD 0AA4               	CALL	UHILOX
  09A7    18 E7                 	JR	UT1
                                ;
                                ;
                                ;	MOVE DATA FROM XXXX TO XXXX
                                ;
                                ;
  09A9    FE 4D                 UMOVE:	CP	'M'
  09AB    28 04                 	JR	Z,umvo0
  09AD    FE 6D                 	cp	'm'
  09AF    20 12                 	jr	nz,usubs
  09B1    CD 0A72               umvo0:	CALL	UEXPR3
  09B4    7E                    UMV0:	LD	A,(HL)
  09B5    02                    	LD	(BC),A
  09B6    03                    	INC	BC
  09B7    CD 0AA4               	CALL	UHILOX
  09BA    18 F8                 	JR	UMV0
  09BC    DD 77 00              USTORE:	LD	(IX+00H),A
  09BF    DD 23                 	INC	IX
  09C1    1D                    	DEC	E
  09C2    C9                    	RET
                                ;
                                ;
                                ;	EXAMINE AND/OR REPLACE MEMORY DATA
                                ;
                                ;
  09C3    FE 53                 USUBS:	CP	'S'
  09C5    CA 09CD               	JP	Z,usuo0
  09C8    FE 73                 	cp	's'
  09CA    C2 0AB4               	jp	nz,uhexn
  09CD    CD 0A7D               usuo0:	CALL	UEXPR1
  09D0    CD 0AFD               	CALL	UQCHK
  09D3    DA 0A25               	JP	C,UERROR
  09D6    E1                    	POP	HL
  09D7    7E                    USU0:	LD	A,(HL)
  09D8    CD 0ACD               	CALL	ULBYTE
  09DB    0E 2D                 	LD	C,02DH
  09DD    CD 0AF7               	CALL	UCOPCK
  09E0    D8                    	RET	C
  09E1    28 10                 	JR	Z,USU1
  09E3    E5                    	PUSH	HL
  09E4    21 0000               	LD	HL,0
  09E7    0E 01                 	LD	C,001H
  09E9    CD 0A85               	CALL	UEX1
  09EC    D1                    	POP	DE
  09ED    E1                    	POP	HL
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-26
'(c) 1981 Morrow Designs'

  09EE    73                    	LD	(HL),E
  09EF    78                    	LD	A,B
  09F0    FE 0D                 	CP	00DH
  09F2    C8                    	RET	Z
  09F3    23                    USU1:	INC	HL
  09F4    CD 0A06               	CALL	UCRLF
  09F7    E5                    	PUSH	HL
  09F8    CD 0AC8               	CALL	ULADR
  09FB    CD 0A37               	CALL	UBLK
  09FE    E1                    	POP	HL
  09FF    18 D6                 	JR	USU0
                                ;
                                ;
  0A01    CD 0A7F               UEXLF:	CALL 	UEXPR
  0A04    D1                    	POP	DE
  0A05    E1                    	POP	HL
                                ;	CR/LF OUTPUT
                                ;
                                ;
  0A06    E5                    UCRLF:	PUSH	HL
  0A07    C5                    	PUSH	BC
  0A08    0E 0D                 	LD	C,0DH
  0A0A    CD 0A39               	CALL	ucout1
  0A0D    0E 0A                 	LD	C,0AH
  0A0F    CD 0A39               	CALL	ucout1
  0A12    C1                    	POP	BC
  0A13    E1                    	POP	HL
  0A14    CD 0A54               	CALL	UCSTS
  0A17    B7                    	OR	A
  0A18    C8                    	RET	Z
                                ;
                                ;	CHECK FOR CONTROL CHARACTER
                                ;
                                ;
  0A19    CD 0A46               UCCHK:	CALL	ucon1
  0A1C    E6 7F                 	AND	07FH
  0A1E    FE 13                 	CP	013H	;CONTROL-S
  0A20    28 F7                 	JR	Z,UCCHK
  0A22    FE 03                 	CP	003H	;CONTROL-C
  0A24    C0                    	RET	NZ
  0A25    CD 0ADC               UERROR:	CALL	UMEMSIZ
  0A28    11 0A25               	LD	DE,UERROR
  0A2B    D5                    	PUSH	DE
  0A2C    0E 3F                 	LD	C,'?'
  0A2E    CD 0A39               	CALL	ucout1
  0A31    C3 0923               	JP	USTART
  0A34    CD 0AC8               UHLSP:	CALL	ULADR
                                ;
                                ;	PRINT SPACE CHARACTER
                                ;
  0A37    0E 20                 UBLK:	LD	C,020H
                                
                                
                                ;********************************************************
                                ;*							*
                                ;*  Console I/O routines for the Wunderbus I/O.  These	*
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-27
'(c) 1981 Morrow Designs'

                                ;*  routines assume that the uart divisor latch has 	*
                                ;*  previously set (either on power up or in routine 	*
                                ;*  executed before a trap to this routine occurred.    *
                                ;*  The character to output should be in the 'C' reg-	*
                                ;*  ister, the character received is returned in the	*
                                ;*  'A' register.  UCSTS returns with zero flag set	*
                                ;*  when no character is waiting in the UART buffer,	*
                                ;*  or with A = FFh if a character is waiting.		*
                                ;*							*
                                ;********************************************************	
                                
                                
  0A39    CD 0A5F               ucout1:	call	uconinit
  0A3C    DB 4D                 ucout2:	in	a,(lsr)			;get uart status
  0A3E    E6 20                 	and	thre
  0A40    28 FA                 	jr	z,ucout2		;loop until tbe
  0A42    79                    	ld	a,c
  0A43    D3 48                 	out	(thr),a			;output the data to uart
  0A45    C9                    	ret
                                
  0A46    CD 0A5F               ucon1:	call	uconinit
  0A49    DB 4D                 ucon2:	in	a,(lsr)			;get uart status
  0A4B    E6 01                 	and	dr
  0A4D    28 FA                 	jr	z,ucon2			;wait until receive data available
  0A4F    DB 48                 	in	a,(rbr)			;read the uart data register
  0A51    E6 7F                 	and	07fh			;strip parity
  0A53    C9                    	ret
                                
  0A54    CD 0A5F               ucsts:	call	uconinit		
  0A57    DB 4D                 	in	a,(lsr)			;read uart status
  0A59    E6 01                 	and	dr
  0A5B    C8                    	ret	z			;return zero set if no character
  0A5C    3E FF                 	ld	a,0ffh
  0A5E    C9                    	ret				;return a = ffh if character waiting
                                
  0A5F                          uconinit:
  0A5F    3E 09                 	ld	a,group1
  0A61    D3 4F                 	out   	(grpctl),a		;set up for UART 1
  0A63    3E 07                 	ld	a,wls0+wls1+stb		
  0A65    D3 4B                 	out 	(lcr),a			;8 bit word, 2 bit stop bits
  0A67    C9                    	ret		
                                
                                
                                
                                ;	CONVERT HEX TO ASCII
                                
  0A68    E6 0F                 UCONV:	AND	00fh
  0A6A    C6 90                 	ADD	A,090H
  0A6C    27                    	DAA
  0A6D    CE 40                 	ADC	A,040H
  0A6F    27                    	DAA
  0A70    4F                    	LD	C,A
  0A71    C9                    	RET
                                ;
                                ;	GET PARAMETERS 1,2,OR 3
                                ;
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-28
'(c) 1981 Morrow Designs'

  0A72    0C                    UEXPR3:	INC	C
  0A73    CD 0A7F               	CALL	UEXPR
  0A76    CD 0A06               	CALL	UCRLF
  0A79    C1                    	POP	BC
  0A7A    D1                    	POP	DE
  0A7B    E1                    	POP	HL
  0A7C    C9                    	RET
  0A7D    0E 01                 UEXPR1:	LD	C,001H
  0A7F    21 0000               UEXPR:	LD	HL,0
  0A82    CD 0B09               UEX0:	CALL	UTI
  0A85    47                    UEX1:	LD	B,A
  0A86    CD 0ADD               	CALL	UNIBBLE
  0A89    38 08                 	JR	C,UEX2
  0A8B    29                    	ADD	HL,HL
  0A8C    29                    	ADD	HL,HL
  0A8D    29                    	ADD	HL,HL
  0A8E    29                    	ADD	HL,HL
  0A8F    B5                    	OR	L
  0A90    6F                    	LD	L,A
  0A91    18 EF                 	JR	UEX0
  0A93    E3                    UEX2:	EX	(SP),HL
  0A94    E5                    	PUSH	HL
  0A95    78                    	LD	A,B
  0A96    CD 0AFD               	CALL	UQCHK
  0A99    30 02                 	JR	NC,UEX3
  0A9B    0D                    	DEC	C
  0A9C    C8                    	RET	Z
  0A9D    C2 0A25               UEX3:	JP	NZ,UERROR
  0AA0    0D                    	DEC	C
  0AA1    20 DC                 	JR	NZ,UEXPR
  0AA3    C9                    	RET
  0AA4    CD 0AAA               UHILOX:	CALL	UHILO
  0AA7    D0                    	RET	NC
  0AA8    D1                    	POP	DE
  0AA9    C9                    	RET
  0AAA    23                    UHILO:	INC	HL
  0AAB    7C                    	LD	A,H
  0AAC    B5                    	OR	L
  0AAD    37                    	SCF
  0AAE    C8                    	RET	Z
  0AAF    7B                    	LD	A,E
  0AB0    95                    	SUB	L
  0AB1    7A                    	LD	A,D
  0AB2    9C                    	SBC	A,H
  0AB3    C9                    	RET
                                ;
                                ;	HEXADECIMAL ARITHMETIC
                                ;
  0AB4    FE 48                 UHEXN:	CP	'H'
  0AB6    28 04                 	JR	Z,uhexd
  0AB8    FE 68                 	cp	'h'
  0ABA    20 67                 	jr	nz,uport
  0ABC    CD 0A01               uhexd:	CALL	UEXLF
  0ABF    E5                    	PUSH	HL
  0AC0    19                    	ADD	HL,DE
  0AC1    CD 0A34               	CALL	UHLSP
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-29
'(c) 1981 Morrow Designs'

  0AC4    E1                    	POP	HL
  0AC5    B7                    	OR	A
  0AC6    ED 52                 	SBC	HL,DE
                                ;
                                ;	CONVERT HL REGISTER TO ASCII
                                ;
  0AC8    7C                    ULADR:	LD	A,H
  0AC9    CD 0ACD               	CALL	ULBYTE
  0ACC    7D                    	LD	A,L
                                ;
                                ;	CONVERT A REGISTER TO ASCII
                                ;
  0ACD    F5                    ULBYTE:	PUSH	AF
  0ACE    0F                    	RRCA
  0ACF    0F                    	RRCA
  0AD0    0F                    	RRCA
  0AD1    0F                    	RRCA
  0AD2    CD 0AD6               	CALL	UDBLC
  0AD5    F1                    	POP	AF
  0AD6    CD 0A68               UDBLC:	CALL	UCONV
  0AD9    C3 0A39               	JP	ucout1			;checked
                                
  0ADC                          UMEMSIZ:
  0ADC    C9                    	RET
                                
  0ADD                          UNIBBLE:
  0ADD    FE 61                 	cp	'a'			;is it less than lower case 'a'?
  0ADF    38 06                 	jr	c,unibok		;take jump if so
  0AE1    FE 7B                 	cp	'z'+1			;less than a lower case 'z'?
  0AE3    3F                    	ccf				;set carry and return if > 'z'
  0AE4    D8                    	ret	c
  0AE5    D6 20                 	sub	' '			;convert to upper case
  0AE7    D6 30                 unibok:	SUB	030H
  0AE9    D8                    	RET	C
  0AEA    FE 17                 	cp	017h
  0AEC    3F                    	ccf
  0AED    D8                    	RET	C
  0AEE    FE 0A                 	CP	00AH
  0AF0    3F                    	CCF
  0AF1    D0                    	RET	NC
  0AF2    D6 07                 	SUB	007H
  0AF4    FE 0A                 	CP	00AH
  0AF6    C9                    	RET
  0AF7    CD 0A39               UCOPCK:	CALL	ucout1
  0AFA    CD 0B09               UPCHK:	CALL	UTI
                                ;
                                ;	CHARACTER CHECK
                                ;
  0AFD    FE 20                 UQCHK:	CP	020H
  0AFF    C8                    	RET	Z
  0B00    FE 2C                 	CP	02CH
  0B02    C8                    	RET	Z
  0B03    FE 0D                 	CP	00DH
  0B05    37                    	SCF
  0B06    C8                    	RET	Z
  0B07    3F                    	CCF
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-30
'(c) 1981 Morrow Designs'

  0B08    C9                    	RET
                                ;
                                ;	ECHO CONSOLE
                                ;
  0B09    CD 0A46               UTI:	CALL	ucon1
  0B0C    3C                    	INC	A
  0B0D    C8                    	RET	Z
  0B0E    3D                    	DEC	A
  0B0F    E6 7F                 	AND	07FH
  0B11    C8                    	RET	Z
  0B12    FE 00                 	CP	000H
  0B14    C8                    	RET	Z
  0B15    FE 4E                 	CP	04EH
  0B17    C8                    	RET	Z
  0B18    FE 6E                 	CP	06EH
  0B1A    C8                    	RET	Z
  0B1B    C5                    	PUSH	BC
  0B1C    4F                    	LD	C,A
  0B1D    CD 0A39               	CALL	ucout1
  0B20    79                    	LD	A,C
  0B21    C1                    	POP	BC
  0B22    C9                    	RET
                                
                                ;
                                ;	READ/WRITE TO I/O PORT
                                ;
  0B23    FE 4F                 UPORT:	CP	'O'
  0B25    28 2A                 	JR	Z,UQOUT
  0B27    FE 6F                 	CP 	'o'
  0B29    28 26                 	jr	z,uqout
  0B2B    FE 49                 	CP	'I'
  0B2D    28 06                 	JR	Z,uin
  0B2F    FE 69                 	cp	'i'
  0B31    28 02                 	jr	z,uin
  0B33    18 24                 	JR	UVERIFY
  0B35    CD 0A7D               UIN:	CALL	UEXPR1
  0B38    0E 0A                 	LD	C,0AH
  0B3A    CD 0A39               	CALL	ucout1
  0B3D    C1                    	POP	BC
  0B3E    ED 58                 UQ0:	IN	E,(C)
  0B40    06 08                 UQI1:	LD	B,008H
  0B42    CD 0A37               	CALL	UBLK
  0B45    CB 23                 UQI2:	SLA	E
  0B47    3E 18                 	LD	A,018H
  0B49    8F                    	ADC	A,A
  0B4A    4F                    	LD	C,A
  0B4B    CD 0A39               	CALL	ucout1
  0B4E    10 F5                 	DJNZ	UQI2
  0B50    C9                    	RET
  0B51    CD 0A7F               UQOUT:	CALL	UEXPR
  0B54    D1                    	POP	DE
  0B55    C1                    	POP	BC
  0B56    ED 59                 	OUT	(C),E
  0B58    C9                    	RET
                                ;
                                ;
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-31
'(c) 1981 Morrow Designs'

                                ;
                                ;
                                ;	VERIFY MEMORY XXXX TO XXXX WITH XXXX
                                ;
  0B59                          UVERIFY:
  0B59    FE 56                 	CP	'V'
  0B5B    28 04                 	JR	Z,uver0
  0B5D    FE 76                 	cp	'v'
  0B5F    20 12                 	jr	nz,uretrn
  0B61    CD 0A72               uver0:	call 	uexpr3
  0B64    0A                    UVERIO:	LD	A,(BC)
  0B65    BE                    	CP	(HL)
  0B66    28 05                 	JR	Z,U..B
  0B68    C5                    	PUSH	BC
  0B69    CD 0BC9               	CALL	UCERR
  0B6C    C1                    	POP	BC
  0B6D    03                    U..B:	INC	BC
  0B6E    CD 0AA4               	CALL	UHILOX
  0B71    18 F1                 	JR	UVERIO
                                
                                
                                
                                ;	Return to task which just trapped with old pc and registers restored
                                ;	All registers are saved!!
                                
  0B73    FE 43                 uretrn:	cp	'C'
  0B75    28 04                 	jr	z,uretr1
  0B77    FE 63                 	cp	'c'	
  0B79    20 0B                 	jr	nz,ucontr
  0B7B    FD F9                 uretr1:	ld	sp,iy			;get back the user save stack
  0B7D    D1                    	pop	de			; ... the return address
  0B7E    E1                    	pop	hl			; ... Ctask/Cmask
  0B7F    7C                    	ld	a,h
  0B80    F6 08                 	or	08h			;set the run bit for 'run'
  0B82    67                    	ld	h,a
  0B83    E5                    	push	hl			;restore the stack
  0B84    D5                    	push	de
  0B85    C9                    	ret				;return to user through 'gotask'
                                
                                
                                ;	Return to trapped task, execute next instruction and trap back
                                ;	All registers are saved but the mask is changed!!
                                
  0B86    FE 55                 ucontr:	cp	'U'
  0B88    28 04                 	jr	z,ucont1
  0B8A    FE 75                 	cp	'u'
  0B8C    20 0B                 	jr	nz,uboot
  0B8E    FD F9                 ucont1:	ld	sp,iy			;get back the user save stack
  0B90    D1                    	pop	de			;... the return address
  0B91    E1                            pop	hl			;... CTASK/CMASK
  0B92    7C                    	ld	a,h
  0B93    E6 F6                 	and	0f6h			;force mask for stop and run enble low
  0B95    67                    	ld	h,a
  0B96    E5                    	push	hl			;restore the stack
  0B97    D5                    	push	de
  0B98    C9                    	ret				;return to user through 'gotask'
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-32
'(c) 1981 Morrow Designs'

                                
                                ;	Jump to the cpu switch address into task specified by CTASK
                                ;	No registers are preserved!!
                                
  0B99    FE 42                 uboot:	cp	'B'
  0B9B    28 05                 	jr	z,uboot1
  0B9D    FE 62                 	cp	'b'
  0B9F    C2 0A25               	jp	nz,uerror
  0BA2    08                    uboot1:	ex	Af',Af
  0BA3    D9                    	exx
  0BA4    AF                    	xor	a
  0BA5    3C                    	inc	a
  0BA6    32 0602               	ld	(mapram + 2),a		;restore the actual map
  0BA9    32 0202               	ld	(map + 2),a		;restore map image 
  0BAC    3A 0402               	ld	a,(switch)
  0BAF    E6 F8                 	and	0f8h
  0BB1    FE 00                 	cp	0			;HDCA Boot?
  0BB3    28 0E                 	jr	z,uboot2		
  0BB5    FE 08                 	cp	8			;HD-DMA Boot?
  0BB7    28 0A                 	jr	z,uboot2
  0BB9    FE 10                 	cp	10h			;DJ-DMA Boot?
  0BBB    28 06                 	jr	z,uboot2
  0BBD    67                    	ld	h,a			;Memory Address jump
  0BBE    2E 00                 	ld	l,0
  0BC0    C3 08BF               	jp	bcomnd
  0BC3    2A 000C               uboot2: ld	hl,(u.pc)		;get the boot address for controllers
  0BC6    C3 08BF               	jp	bcomnd
                                
                                
                                ;	MEMORY MISMATCH PRINTOUT
                                ;
  0BC9    47                    UCERR:	LD	B,A
  0BCA    CD 0A34               	CALL	UHLSP
  0BCD    7E                    	LD	A,(HL)
  0BCE    CD 0ACD               	CALL	ULBYTE
  0BD1    CD 0A37               	CALL	UBLK
  0BD4    78                    	LD	A,B
  0BD5    CD 0ACD               	CALL	ULBYTE
  0BD8    C3 0A06               	JP	UCRLF
                                
                                
  0BDB                          ecode1	equ	$
  0BDB                          	ds	3edh - (ecode1-rom1)
                                
  0BED    FFFF                  serial:	dw	0ffffh			;Micronix serialization word
  0BEF    FF                    	db	0ffh
                                
                                ;********************************************************
                                ;*   							*
                                ;*   The following piece of code is where the user	*
                                ;*   task begins execution whenever a trap occurs.	*
                                ;*   The users registers and sp are saved in the 	*
                                ;*   temporary users store area.			*
                                ;*							*
                                ;********************************************************
                                
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	1-33
'(c) 1981 Morrow Designs'

  0BF0    00                    	nop				;must be nop to void a halt
  0BF1    ED 73 000A            	ld 	(u.sp),sp		;save the users stack pointer
  0BF5    31 0014               	ld	sp,begsav	     	;set sp to the temporary save area
  0BF8    F5                    	push	af	
  0BF9    E5                    	push	hl
  0BFA    D5                    	push	de
  0BFB    00                    	nop
  0BFC    CD 0821               	call	trappd			;go to supervisor trap via temp
  0BFF    76                    	halt				;halt here allows T0 to halt
                                
                                
  0C00                          erom1	equ	$						
  0C00                          	ds	400h-(erom1-rom1)
                                	
                                
                                
  0C00                          fpp0:	ds	8
  0C08                          fpp1:	ds	1
                                
                                	end
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	S
'(c) 1981 Morrow Designs'

Macros:

Symbols:
000D 	ACR             0004 	ADI4            0000 	ADI8            
000C 	AFF             0015 	AFOFST          000A 	ALF             
0A6B 	ALLERR          0838 	ALLTRP          1087 	ARG             
0020 	ASP             0888 	ATASK           0055 	ATTN            
0946 	BADRAM          0048 	BASE            000F 	BCOFST          
08BF 	BCOMND          0B9E 	BEGIN0          0014 	BEGSAV          
0007 	BEL             1100 	BOOTAD          0BB3 	BOOTBL          
0AA3 	BOOTHD          0008 	BSP             0BA5 	BTABLE          
00CD 	CALLOP          1080 	CHAN            096A 	CHECK           
0A3E 	CLOOP           0A40 	CLOOP0          0A45 	CLOOP1          
0A5A 	CLOOP2          0007 	CMASK           108B 	CMMD            
0916 	COLD            0051 	COMMD           0004 	COMPLT          
0004 	CONST           0B96 	CONTIN          0050 	CONTRL          
0008 	CSTACK          0006 	CTASK           0099 	CYL             
0053 	DATA            0B52 	DEFAULT         0011 	DEOFST          
0A62 	DERROR          09C9 	DJDMA           09CE 	DJLOOP          
09CB 	DJLOP0          104A 	DJSTAT          0080 	DLAB            
0048 	DLL             0049 	DLM             1084 	DMADDR          
0054 	DMARST          0001 	DR              0001 	DREAD           
0004 	DREADY          0005 	DRENBL          00FC 	DRIVEA          
0007 	DSKRUN          0401 	DSPCOL          0400 	DSPSEG          
080F 	DUPMAP          0B10 	DXLOOP          0BEE 	ECODE0          
0BDB 	ECODE1          0404 	ELOCIO          0BC3 	ENDBOOT         
0BD0 	ENDRD           0020 	EOI             0C00 	EROM0           
0C00 	EROM1           0016 	ERSAV           0910 	FMAP            
0003 	FORMAT          0C00 	FPP0            0C08 	FPP1            
0052 	FUNCTN          080C 	GETMAP          0857 	GETSW           
01B0 	GOBUFF          00FF 	GOOD            087C 	GOSUPR          
089E 	GOTASK          0809 	GOTSK           0869 	GOWHAT          
0008 	GROUP0          0009 	GROUP1          000A 	GROUP2          
000B 	GROUP3          004F 	GRPCTL          08DA 	GTMAP           
0A99 	HDCERR          0A79 	HDCLOP          0A7C 	HDLOP1          
0A11 	HDRL            00C8 	HDSETL          0011 	HDSPT           
0008 	HEADER          0004 	HEADS           0000 	HIVECT          
0013 	HLOFST          0A17 	HOME            001A 	HSTRAP          
0001 	IC4             004C 	ICW1            004D 	ICW2            
004D 	ICW3            004D 	ICW4            0049 	IER             
0000 	IMASK           0010 	INIT            0050 	IOADDR          
1050 	IOPB            001F 	IVALU           0ACB 	IWAIT1          
0AD0 	IWAIT2          0AD5 	IWAIT3          00C3 	JMPOP           
0BD0 	JTABLE          0401 	KEYBD           004B 	LCR             
108D 	LINK            0B03 	LLOOP           0400 	LOCIO           
0010 	LOOP            0000 	LOVECT          004D 	LSR             
0018 	LTIM            0200 	MAP             0600 	MAPRAM          
0403 	MASK            004C 	MCR             08FA 	MONITOR         
0032 	MONSTK          0982 	MONTOR          0019 	MSKOFST         
093B 	NEXCHK          0806 	NMAP            0006 	NOOP            
0000 	NOP             000C 	NORMAL          09F1 	NSTAT           
08A2 	NTASK           08A0 	NTBUS           09F7 	NUBOOT          
0986 	NUTASK          0076 	NXTBYTE         004D 	OCW1            
004C 	OCW2            0818 	OLDTASK         0002 	OPDONE          
000D 	PCOFST          00FF 	PICMASK         09AF 	PICSET          
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	S-1
'(c) 1981 Morrow Designs'

08E7 	PUTMAP          08F5 	PUTMXX          0000 	RAM             
092F 	RAMCHK          0048 	RBR             0A2A 	RDATA           
0BC3 	RDTBL           0B7B 	RDUART          0000 	READAT          
0020 	READY           0800 	REGRD           0014 	REGSAV          
080E 	REGWR           080F 	REGWR1          085C 	RESET           
08D5 	RESET0          08E1 	RESET1          08F7 	RESLOP          
0907 	RESLP1          08FA 	RESLP2          0893 	RESTOR          
0815 	RESTR           01E2 	RETSTK          000D 	REVNUM          
0002 	RHEAD           0AAB 	RLOOP           0800 	ROM0            
0800 	ROM1            0B18 	RSTMAP          0B26 	RSTMXX          
0AC8 	SDONE           0003 	SECSIZ          0051 	SECSTAT         
0001 	SECTOR          0008 	SEKCMP          1083 	SELECT          
0005 	SENSE           0BED 	SERIAL          0B55 	SETIT           
08E4 	SETTLE          091A 	SETUP           0002 	SNGL            
0017 	SPOFST          0036 	SSMODE          0BF9 	START           
108C 	STATIS          0403 	STATS           0050 	STATUS          
0004 	STB             0000 	STEPIN          00F8 	STEPO           
0010 	STEPOUT         001E 	STPDLY          0000 	SUPER           
0872 	SUPTRAP         0800 	SVTRAP          0402 	SWITCH          
0080 	SYSTEM          01EA 	T.AF            01F8 	T.AF1           
01EC 	T.BC            01FA 	T.BC1           01EE 	T.DE            
01FC 	T.DE1           01F0 	T.HL            01FE 	T.HL1           
01F2 	T.INT           01F4 	T.IX            01F6 	T.IY            
01E6 	T.PC            01E8 	T.SP            002B 	T0MASK          
002B 	T1MASK          0402 	TASK            0873 	TBUS            
0200 	TEMPSTK         084E 	TFPP            0048 	THR             
0020 	THRE            0821 	TMAP            0001 	TRACK0          
083A 	TRAM            083F 	TRAM1           0821 	TRAPPD          
0001 	TRK0            0400 	TRPADD          0803 	TSKBSE          
01E4 	TSKMSK          0954 	TSTSW           0B6D 	U..B            
0012 	U.AF            000E 	U.DE            0010 	U.HL            
000C 	U.PC            000A 	U.SP            0B2D 	UARTS0          
0B2B 	UARTST          0A37 	UBLK            0B99 	UBOOT           
0BA2 	UBOOT1          0BC3 	UBOOT2          0A19 	UCCHK           
0BC9 	UCERR           0A46 	UCON1           0A49 	UCON2           
0A5F 	UCONINIT        0B8E 	UCONT1          0B86 	UCONTR          
0A68 	UCONV           0AF7 	UCOPCK          0A39 	UCOUT1          
0A3C 	UCOUT2          0A06 	UCRLF           0A54 	UCSTS           
0AD6 	UDBLC           094A 	UDI0            0952 	UDI1            
0947 	UDISP           0A25 	UERROR          0A82 	UEX0            
0A85 	UEX1            0A93 	UEX2            0A9D 	UEX3            
0A01 	UEXLF           0A7F 	UEXPR           0A7D 	UEXPR1          
0A72 	UEXPR3          096B 	UFI0            0960 	UFILL           
0968 	UFILL0          0975 	UGOTO           097D 	UGOTO0          
0ABC 	UHEXD           0AB4 	UHEXN           0AAA 	UHILO           
0AA4 	UHILOX          0A34 	UHLSP           0B35 	UIN             
0AC8 	ULADR           0ACD 	ULBYTE          0ADC 	UMEMSIZ         
09A9 	UMOVE           0985 	UMTEST          09B4 	UMV0            
09B1 	UMVO0           0ADD 	UNIBBLE         0AE7 	UNIBOK          
0AFA 	UPCHK           0B23 	UPORT           0B3E 	UQ0             
0AFD 	UQCHK           0B40 	UQI1            0B45 	UQI2            
0B51 	UQOUT           0B7B 	URETR1          0B73 	URETRN          
0B87 	URTERR          0003 	USER            0932 	USTAR0          
0923 	USTART          09BC 	USTORE          09D7 	USU0            
09F3 	USU1            09C3 	USUBS           09CD 	USUO0           
0990 	UT1             098D 	UT10            09A3 	UT2             
'MPZ-80  MON4.47 FIRMWARE'	MACRO-80 3.44	09-Dec-81	PAGE	S-2
'(c) 1981 Morrow Designs'

0B09 	UTI             0B61 	UVER0           0B59 	UVERIFY         
0B64 	UVERIO          0A87 	WAIT            0A89 	WAIT0           
0A8C 	WAIT1           0AC1 	WAITC           0AEE 	WAITD           
0AB4 	WAITZ           0002 	WFAULT          0812 	WHAT            
0001 	WINDOW          0001 	WLS0            0002 	WLS1            
081E 	WRATSK          0001 	WRITE           0885 	WRITSK          
081B 	WRTASK          



No Fatal error(s)


