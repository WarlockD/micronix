CP/M MACRO ASSEM 2.0	#001	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;**********************************************************************
                TITLE 'CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs'
                ;**********************************************************************
                ;
                ;The following drivers are included in this CBIOS.
                ;-------------------------------------------------
                ;
                ; Console Devices:
                ;	CDRV0	Prom Patch (4 Jumps: conin, conout, const & conint)
                ;	CDRV1	Patch Area (128 bytes)
                ;	CDRV2	Multi I/O or Decision I driver
                ;	CDRV3	2D/B driver
                ;	CDRV4	DJDMA serial port
                ;	CDRV5	Switchboard serial port
                ;	CDRV6	North Star motherboard (2 serial + 1 parallel)
                ;
                ; List Devices:
                ;	LDRV0	Prom Patch (3 Jumps: lstout, lstost & lstset)
                ;	LDRV1	Patch Area (128 bytes)
                ;	LDRV2	Multio_Rev3-4 or Wunderbuss i/o Serial, no protocol
                ;	LDRV3	Multio_Rev3-4 or Wunderbuss i/o Serial, Clear To Send protocol
                ;	LDRV4	Multio_Rev3-4 or Wunderbuss i/o Serial, Data Set Ready protocol
                ;	LDRV5	Multio_Rev3-4 or Wunderbuss i/o Serial, Xon/Xoff protocol
                ;
                ; Disk systems:
                ;	DDRV1	DJDMA floppy disk controller with 8 and 5 1/4 inch disks.
                ;	DDRV2	DJ 2D/B floppy disk controller with 8 inch disks.
                ;	DDRV3	HDDMA 5, 10, 16, megabyte hard disk systems.
                ;	DDRV3	HDCA 10, 20 and 26 megabyte hard disks.
                ;
                ; Note:	Floppy systems diskette (drive A:) has to have 1024 byte
                ;	sectors in order for the cold and warm boot loaders to
                ;	work.  Be sure to format all new system diskettes with
                ;	1024 byte sectors.  The system diskette can be either
                ;	single or double sided.  The sector size on normal (non
                ;	A: drive) diskettes is not restricted.  Thus if you have
                ;	a diskette with software that is supposed to run on the
                ;	A: drive then you should mount the diskette in the B:
                ;	drive and then PIP it over to a 1024 byte sector
                ;	system diskette.
                	PAGE
CP/M MACRO ASSEM 2.0	#002	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;*****************************
                ;Begin User Configuration Area
                ;*****************************
 0001 =         ABSASM	EQU	1		;set 0 for rmac, set 1 for mac
                ;
                ;General System Considerations
                ;=============================
                ;Memory Size
                ;-----------
                ;	1) The following equate sets the memory size in kilobytes. For
                ;	   example, 48 denotes a 48k system while 64 equals a 64k system.
                ;
 0030 =         MSIZE	EQU	48		;Memory size of target CP/M
 0013 =         BIOSLN	EQU	13H		;BIOS length.  Also in ABOOT&.ASM
                ;Non-Standard Flag
                ;-----------------
                ;	If this CBIOS is used with the CP/M 2.2 system that is shipped on
                ;	a Morrow Designs diskette then NOSTAND can be set to 1.  This
                ;	will allow the CBIOS to use various data areas found inside of
                ;	the CP/M 2.2 BDOS.  If the CBIOS is used with a different
                ;	operating system then NOSTAND should be set to 0.
                ;
 0000 =         NOSTAND	EQU	0		;Set to 1 for non-standard mode
                ;Define the console and printer environments
                ;===========================================
                ;	The following is a list of possible baud rates and the decimal
                ;	value needed for the cbaud and lbaud definitions
                ;
                ;	  Baud Rate	cbaud/lbaud	Baud Rate	cbaud/lbaud
                ;		 50	2304		     2000	58
                ;		 75	1536		     2400	48
                ;		110	1047		     3600	32
                ;		134.5	 857		     4800	24
                ;		150	 768		     7200	16
                ;		300	 384		     9600	12
                ;		600	 192		    19200	 6
                ;	       1200	  96		    38400	 3
                ;	       1800	  64		    56000	 2
                ;
                ;Define the console driver to be used.
                ;-------------------------------------
                ;	CONTYP is:	0	Nothing, used for patching to PROM's.
                ;			1	Provide for 128 bytes of patch space.
                ;			2	Multi I/O or Decision I driver.
                ;			3	2D/B driver.
                ;			4	DJDMA serial port
                ;			5	Switchboard serial port
                ;			6	North Star motherboard (2 serial + 1 parallel)
                ;
 0002 =         CONTYP	EQU	2		;Console type
 000C =         CBAUD	EQU	12		;Console Baud Rate
                ;Define the list driver to be used
                ;---------------------------------
                ;	LSTTYP is:	0	Nothing, used for patching to PROM's.
                ;			1	Provide for 128 bytes of patch space.
CP/M MACRO ASSEM 2.0	#003	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;			2	Multio/Wbio serial, no protocol.
                ;			3	Multio/Wbio serial, Clear To Send protocol.
                ;			4	Multio/Wbio serial, Data Set Ready protocol.
                ;			5	Multio/Wbio serial, Xon/Xoff protocol.
                ;
                ;	Note:	The Wunderbuss i/o board (Wbio) used in the Decision 1 is
                ;		functionally identical to the Multio.
                ;
 0003 =         LSTTYP	EQU	3		;List Device type
 0060 =         LBAUD	EQU	96		;List Device Baud Rate
                	PAGE
CP/M MACRO ASSEM 2.0	#004	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Setup Disk System
                ;=================
                ;
                ;Select the Number of each type of disk drive
                ;--------------------------------------------
                ;	1) This following table tells the system the types and numbers of drives
                ;	   that are active.
                ;	2) Drives that are not present should be set to zero.
                ;	3) An example: If you have 2-8" drives using a DJDMA and one disk
                ;	   attached to an HDDMA controller you would set maxdm = 2 and
                ;	   maxmw = 1, with all other selections set to zero.
                ;
 0002 =         MAXDM	EQU	2		;DJDMA floppies (8")
 0002 =         MAXMF	EQU	2		;DJDMA floppies (5 1/4")
 0000 =         MAXFD	EQU	0		;DJ2D/B floppies (8" only)
 0000 =         MAXMW	EQU	0		;HDDMA hard disks
 0000 =         MAXHD	EQU	0		;HDCA hard disk drives
                ;Set the Logical Ordering of the drives
                ;--------------------------------------
                ;	1) You must assign an 'order number' for each drive type selected
                ;	   in the previous set of equates. Drive types that WERE NOT selected
                ;	   in the previous set of equates must be set to zero in this set.
                ;	2) Numbering must start with 1 and be continious.
                ;	3) An example: Suppose that your system consists of two DJDMA_8"
                ;	   drives and four DJDMA_1/4" drives along with one drive attached to
                ;	   an HDDMA controller; Furthermore, suppose that you set dmorder to
                ;	   3, mforder to 2 and mworder to 1. The HDDMA would be your A: drive.
                ;	   The 8" drives would be the B: and C: drives; And, finally, the D:,
                ;	   E:, F:, and G: drives would be assigned to the 5_1/4" DJDMA drives.
                ;
 0001 =         DMORDER	EQU	1		;DJDMA floppies (8")
 0002 =         MFORDER	EQU	2		;DJDMA floppies (5 1/4")
 0000 =         FDORDER	EQU	0		;DJ2D/B floppies (8" only)
 0000 =         MWORDER	EQU	0		;HDDMA hard disks
 0000 =         HDORDER	EQU	0		;HDCA hard disk drives
                ;HDDMA controller disk drives
                ;----------------------------
                ;	1) If the HDDMA controller has been selected then you must choose one
                ;	   (and only one) of the following drive types.
                ;
 0000 =         ST506	EQU	0		;Seagate ST-506
 0000 =         ST412	EQU	0		;Seagate ST-412
 0000 =         CM5619	EQU	0		;CMI CM-5619
                ;HDCA controller disk drives
                ;---------------------------
                ;	1) If the HDCA controller has been selected then you must choose one
                ;	   (and only one) of the following drive types.
                ;
 0000 =         M10F	EQU	0		;Fujitsu M2301B
 0000 =         M10M	EQU	0		;Memorex
 0000 =         M20	EQU	0		;Fujitsu M2302B
 0000 =         M26	EQU	0		;Shugart SA4000
                ;DJDMA controller equates
                ;------------------------
                ;
CP/M MACRO ASSEM 2.0	#005	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 0000 =         MFSLOW	EQU	0		;set true if slow stepping 5-1/4" floppy
                ;DJ2D/B controller equates
                ;-------------------------
                ;
 F800 =         FDORIG	EQU	0F800H		;Origin of DJ2D/B Disk Jockey PROM
                ;Misc Considerations
                ;-------------------
 0000 =         WMDRIVE	EQU	0		;CP/M logical drive number to warm boot from.
 0000 =         MWQUIET	EQU	0		;Set for no names printed on login (HDDMA only)
                	IF	MAXMW NE 0
                BADSIZ	EQU	32		;Number of badmap entries for HDDMA
                	ELSE			;(Only HDDMA drives use the bad map)
 0001 =         BADSIZ	EQU	1		;Leave one entry as filler
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#006	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                *****************************
                ;Begin Internal CBIOS equates
                ;****************************
                ;
                ;
                ;Revision Numbers
                ;----------------
                ;	1) The CBIOS revision number is output on a cold boot of the system.
                ;	2) The first part of the CBIOS revision number is converted to an
                ;	   alpha character while the the second part is simply output as a
                ;	   number. For example 54 becomes E4 and 27 becomes B7.
 0036 =         REVNUM	EQU	54		;CBIOS revision number
 0016 =         CPMREV	EQU	22		;CP/M revision number 2.2
                ;Debug Flag
                ;----------
                ;	The DEBUG flag merely causes various internal values and
                ;	addresses to be printed during the assembly process.  This
                ;	printing is forced via assembly errors and thus should not
                ;	affect the resulting code in any way.
                ;
 0000 =         DEBUG	EQU	0		;Set to 1 for debugging mode
                	PAGE
CP/M MACRO ASSEM 2.0	#007	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;General CP/M system equates.
                ;============================
                ;
                ;Location Definitions
                ;--------------------
 0000 =         WBOT	EQU	0		;Warm boot jump address
 0003 =         IOBYTE	EQU	3		;IOBYTE location
 0004 =         CDISK	EQU	4		;Address of last logged disk
 0005 =         ENTRY	EQU	5		;BDOS entry jump address
 0080 =         BUFF	EQU	80H		;Default buffer address
 0100 =         TPA	EQU	100H		;Transient memory
                ;Size Definitions
                ;----------------
 0800 =         CCPLN	EQU	800H
 0E00 =         BDOSLN	EQU	0E00H
 C000 =         SIZE	EQU	(MSIZE*1024)
                	IF	ABSASM		;if mac
 AD00 =         CBIOS	EQU	SIZE-(BIOSLN*100H)
 AD00 =         BIOS	EQU	CBIOS
 7400 =         OFFSETC	EQU	2100H-BIOS	;Offset for sysgen
                	ENDIF
                ;Sizes output for Debugging purposes
                ;-----------------------------------
                	IF	DEBUG
                DBGTMP	SET	OFFSETC		;DDT offset	! <DEBUG>
                DBGTMP	SET	CCP		;CCP address	! <DEBUG>
                DBGTMP	SET	BDOS		;BDOS address	! <DEBUG>
                DBGTMP	SET	BIOS		;CBIOS address	! <DEBUG>
                	ENDIF
                ;Misc. constants
                ;---------------
                ;
 000A =         RETRIES	EQU	10		;Max retries on disk i/o before error
                	PAGE
CP/M MACRO ASSEM 2.0	#008	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Internal Disk System Equates
                ;============================
                ;
                ;Hard Disk System Equates
                ;------------------------
                ;
 0000 =         M10	EQU	M10F OR M10M
 0000 =         FUJITSU	EQU	M20  OR M10F
 0000 =         HDSPT	EQU	32*M26+21*M20+21*M10	;Sectors per track for HDCA
 0009 =         MWSPT	EQU	9			;Sectors per track for HDDMA
 0000 =         HDLOG	EQU	M10*2+M20*3+M26*3	;Logical disks per drive for HDCA
 0000 =         MWLOG	EQU	ST506+ST412*2++CM5619*2	;Logical disks per drive for HDDMA
 0004 =         MAXLOG	EQU	(MAXHD*HDLOG)+(MAXMW*MWLOG)+MAXFD+MAXDM+MAXMF
                ;Disk System Ordering Macros
                ;---------------------------
                ;	The following marco is used in generating the logical order of the
                ;	CP/M drives.
                ;
                ORDER	MACRO	NUM
                	IF	NUM EQ HDORDER
                	DW	HDDST
                	ENDIF
                	IF	NUM EQ MWORDER
                	DW	MWDST
                	ENDIF
                	IF	NUM EQ FDORDER
                	DW	FDDST
                	ENDIF
                	IF	NUM EQ DMORDER
                	DW	DMDST
                	ENDIF
                	IF	NUM EQ MFORDER
                	DW	MFDST
                	ENDIF
                	ENDM
                	PAGE
CP/M MACRO ASSEM 2.0	#009	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;***********************************
                ;Begin CBIOS Executable Code Section
                ;***********************************
                ;	This section consists of 3 routines
                ;		1) The Jump Table
                ;		2) Warm Boot routine
                ;		3) Go CPM (executed directly after every warm/cold boot)
                ;
                ;CBIOS Jump Table
                ;----------------
                ;	The jump table below must remain in the same order, the routines
                ;	may be changed, but the function executed must be the same.
                ;
                	IF	ABSASM		;mac stuff
 AD00           	ORG	BIOS		;Cbios starting address
                	ELSE			;rmac stuff
                	CSEG
                	PUBLIC	CODEND,SAVLN
                	PUBLIC	CBIOS,CCP,BDOS,BIOSLEN
                	PUBLIC	CBIOS,CBOOT,WBOOT,CONST,CONIN,CONOUT,LSTOUT
                	PUBLIC	HOME,SETDRV,SETTRK,SETSEC,SETDMA,READ,WRITE
                	PUBLIC	LSTOST,SECTRAN
                BIOSLN	EQU	-1		;suppress errors
                	ENDIF
                CBIOS:				;label for refrencing base of cbios
 9F00 =         BDOS	EQU	CBIOS-BDOSLN
 9700 =         CCP	EQU	CBIOS-(BDOSLN+CCPLN)
                	IF	NOSTAND NE 0
                CBLOCK	EQU	CBIOS-19H	;Current actual block# * blkmsk
                	ENDIF			;Used for unallocated writting
                ;Begin Normal CPM BIOS Jump Table
                ;--------------------------------
 AD00 C3D3B8    	JMP	CBOOT		;Cold boot entry point
 AD03 C339AD    WBOOTE:	JMP	WBOOT		;Warm boot entry point
 AD06 C35EB7    	JMP	CONST		;Console status routine
 AD09 C346B7    CIN:	JMP	CONIN		;Console input
 AD0C C352B7    COUT:	JMP	CONOUT		;Console output
 AD0F C37EB7    POUT:	JMP	LSTOUT		;List device output
                	IF	(LSTTYP GE 2) AND (LSTTYP LE 5)
                	;has multio or wbio
 AD12 C3D7B7    	JMP	PUNOUT		;Punch device output
 AD15 C3C0B7    	JMP	RDRIN		;Reader device input
                	IF	NOT ABSASM	;if rmac
                	PUBLIC	PUNOUT,RDRIN
                	ENDIF
                	ELSE
                	;not multio/wbio
                	JMP	COUT		;user console out as punch
                	JMP	CIN		;use console in as reader
                	ENDIF
 AD18 C30CAE    	JMP	HOME		;Home drive
 AD1B C31EAE    	JMP	SETDRV		;Select disk
 AD1E C381AE    	JMP	SETTRK		;Set track
 AD21 C387AE    	JMP	SETSEC		;Set sector
 AD24 C38DAE    	JMP	SETDMA		;Set DMA address
CP/M MACRO ASSEM 2.0	#010	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AD27 C393AE    	JMP	READ		;Read the disk
 AD2A C398AE    	JMP	WRITE		;Write the disk
 AD2D C389B7    	JMP	LSTOST		;List device status
 AD30 C317AF    	JMP	SECTRAN		;Sector translation
                ;The following jumps are extended BIOS calls defined by Morrow Designs
                ;---------------------------------------------------------------------
                	IF	MAXFD NE 0
                	JMP	FDSEL		;Hookup for SINGLE.COM program
                	ELSE
 AD33 C38CAE    	JMP	DONOP
                	ENDIF
 AD36 C30000    	JMP	0		;End of the jump table
                	PAGE
CP/M MACRO ASSEM 2.0	#011	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Warm Boot
                ;=========
                ;	WBOOT loads in all of CP/M except the CBIOS, then initializes
                ;	system parameters as in cold boot. See the Cold Boot Loader
                ;	listing for exactly what happens during warm and cold boots.
                ;
 AD39 310001    WBOOT:	LXI	SP,TPA		;Set up stack pointer
 AD3C 3E01      	MVI	A,1
 AD3E 32A5AD    	STA	CWFLG		;Set cold/warm boot flag
 AD41 2600      	MVI	H,WMDRIVE	;Move drive to warm boot off of into (h)
 AD43 2E00      	MVI	L,D$WBOOT	;Peform warm boot operation
 AD45 CDAFAF    	CALL	JUMPER
 AD48 D250AD    	JNC	GOCPM		;No error
 AD4B 76        	HLT			;Halt computer
 AD4C 00        	DB	0
 AD4D C339AD    	JMP	WBOOT		;In case user restarts the computer
                ;Begin Executing CPM (GOCPM)
                ;===========================
                ;	Gocpm is the entry point from cold boots, and warm boots. It
                ;	initializes some of the locations in page 0, and sets up the
                ;	initial DMA address (80h).
                ;
 AD50 018000    GOCPM:	LXI	B,BUFF		;Set up initial DMA address
 AD53 CD8DAE    	CALL	SETDMA
 AD56 3EC3      	MVI	A,(JMP)		;Initialize jump to warm boot
 AD58 320000    	STA	WBOT
 AD5B 320500    	STA	ENTRY		;Initialize jump to BDOS
 AD5E 2103AD    	LXI	H,WBOOTE	;Set up low memory entry to CBIOS warm boot
 AD61 220100    	SHLD	WBOT+1
 AD64 21069F    	LXI	H,BDOS+6	;Set up low memory entry to BDOS
 AD67 220600    	SHLD	ENTRY+1
 AD6A AF        	XRA	A		;A <- 0
 AD6B 323EB7    	STA	BUFSEC		;Set buffer to unknown state
 AD6E 324DAF    	STA	BUFWRTN		;Set buffer not dirty flag
 AD71 323AB7    	STA	ERROR		;Clear buffer error flag
 AD74 3AA5AD    	LDA	CWFLG		;Get cold/warm boot flag
 AD77 B7        	ORA	A
 AD78 21A9AD    	LXI	H,COLDMES	;Pointer to initial cold command
 AD7B CA81AD    	JZ	CLDCMND
 AD7E 21ABAD    	LXI	H,WARMES	;Pointer to initial warm command
 AD81 5E        CLDCMND:MOV	E,M		;Do one level of indirection
 AD82 23        	INX	H
 AD83 56        	MOV	D,M
 AD84 1A        	LDAX	D		;Get command length
 AD85 3C        	INR	A		;Bump length to include length byte itself
 AD86 210797    	LXI	H,CCP+7		;Command buffer (includes length byte)
 AD89 4F        	MOV	C,A		;Set up for block move
 AD8A 0600      	MVI	B,0
 AD8C CDD5AF    	CALL	MOVBYT		;Move command to internal CCP buffer
 AD8F 3AA5AD    	LDA	CWFLG		;Figure out whether or not to send message
 AD92 B7        	ORA	A
 AD93 3AA8AD    	LDA	AUTOFLG
 AD96 CA9AAD    	JZ	CLDBOT
 AD99 1F        	RAR
 AD9A 1F        CLDBOT:	RAR
CP/M MACRO ASSEM 2.0	#012	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AD9B 3A0400    	LDA	CDISK		;Jump to CP/M with currently selected disk in C
 AD9E 4F        	MOV	C,A
 AD9F DA0097    	JC	CCP		;Enter CP/M, send message
 ADA2 C30397    	JMP	CCP+3		;Enter CP/M, no message
 ADA5 00        CWFLG:	DB	0		;Cold/warm boot flag
                	PAGE
CP/M MACRO ASSEM 2.0	#013	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;***************
                ;Misc. Data Area
                ;***************
                ;	The following area is a hodge-podge of pointers, constants and
                ;	revision labels.
                ;
                ;Auto Start
                ;==========
                ;	The following byte determines if an initial command is to be
                ;	given to CP/M on warm or cold boots. The value of the byte is
                ;	used to give the command to CP/M:
                ;
                ;		0 = never give command.
                ;		1 = give command on cold boots only.
                ;		2 = give the command on warm boots only.
                ;		3 = give the command on warm and cold boots.
                ;
 ADA6 00        AUTOST:	DB	0		;Revision 0 structure
 ADA7 59        	DB	100H - (LOW ($ - CBIOS))	;The rest of the page is used for this stuff
 ADA8 00        AUTOFLG:DB	0		;Auto command feature enable flag
 ADA9 ADAD      COLDMES:DW	COLDCM		;Pointer to the cold start command
 ADAB AEAD      WARMES:	DW	WARMCM		;Pointer to the warm start command
                ;Define the Auto Start Command
                ;-----------------------------
                ;	If there is a command inserted here, it will be passed to the
                ;	CCP if the auto feature is enabled.  For Example:
                ;
                ;		coldcm:	db	coldend-coldcm
                ;			db	'MBASIC MYPROG'
                ;		coldend	equ	$
                ;
                ;	will execute Microsoft BASIC, and MBASIC will execute the
                ;	"MYPROG" BASIC program.  Note: The command line must be in
                ;	upper case for most commands.
                ;
 ADAD 01        COLDCM:	DB	COLDEND-COLDCM		;Length of cold boot command
                	DB	''			;Cold boot command goes here
 ADAE =         COLDEND	EQU	$
 ADAE 01        WARMCM:	DB	WARMEND-WARMCM		;Length of warm boot command
                	DB	''			;Warm boot command goes here
 ADAF =         WARMEND	EQU	$
                	PAGE
CP/M MACRO ASSEM 2.0	#014	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;CBIOS Configuration Data
                ;========================
                ;
                ;Pointer to the Drive configuration table.
                ;-----------------------------------------
                ;
 ADAF 00        DRCONF:	DB	0		;Revision 0 structure
 ADB0 20        	DB	32		;32 bytes long now
                ;Pointer to Device Specification Tables
                ;--------------------------------------
                ;	This macro generates a table of pointers to the start of each active
                ;	disk driver's dispatch table. The order of this table defines the
                ;	logical order of the CP/M drives.
                ;
 ADB1 =         DSTTAB	EQU	$
 0001 #         DN	SET	1
                	REPT	16
                	ORDER	%DN
                DN	SET	DN+1
                	ENDM
 ADB1+A1B0      	DW	DMDST
 ADB3+3BB2      	DW	MFDST
                ;I/O configuration table.
                ;------------------------
                ;	At this CBIOS revision 11 bytes are defined for this table.
                ;	Several extensive changes are planned for the table.  Future
                ;	revision of the IOCONF table will have independant entries for
                ;	three serial ports and will be used by several character drivers.
                ;	Also the IOBYTE will be implemented for all the character
                ;	drivers.  I might even write an external program to edit this
                ;	table.
                ;
                ;	The first two bytes show the I/O configuration that the CBIOS was
                ;	assembled with.  These bytes are used by external software to
                ;	determine the configuration options that are available.
                ;
                ;	The next byte is the initial IOBYTE value.  This value is written
                ;	to location 3 on cold boots.  See the CP/M 2 alternation guide
                ;	for a description of the IOBYTE.
                ;
                ;	The next byte is to make sure that the group select byte on the
                ;	Mult I/O or Decsion I stays consistant throughout the Cbios.
                ;	Only the group bits themselves (bits 0 and 1) should be changed
                ;	as you output to the group port.  If you modify one of the other
                ;	bits (such as driver-enable) then you should modify the same bit
                ;	in this byte.  For example:
                ;
                ;		;Select console group
                ;	lda	group		;Get group byte
                ;	ori	congrp		;Select the console port
                ;	out	grpsel		;Select the group
                ;
                ;		;Modify a bit in the group byte
                ;	lda	group		;Get group byte
                ;	ori	bank		;Set the bank bit
CP/M MACRO ASSEM 2.0	#015	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;	sta	group		;Save new group setting
                ;	ori	group2		;Select second serial port
                ;	out	grpsel		;Select the desired group
                ;
                ;	Note: You should not set the group bits themselves in the
                ;	      group byte.
                ;
                ;	The following two words define the default baud rates for the
                ;	console and the list devices.  These words are provided so that
                ;	the user can easily modify them.
                ;
                ;	The next two bytes are ued to configure the hardware handshaking
                ;	protocall used by the serial list drivers with the Multio or
                ;	Wunderbuss I/O boards.  The first of these two bytes is a mask.
                ;	This mask is ANDed with the 8250's MODEM Status Register to strip
                ;	out the desired handshake lines.  Next the result of the ANDing
                ;	is XORed with the second of the two bytes.  This XORing allows
                ;	the handshake lines to be inverted.  Common byte values are
                ;	shown below.
                ;
                ;	The last byte in the revision one structure is the last character
                ;	that was recieved from the printer.  This byte is used to
                ;	implement Xon/Xoff software handshaking.  This handshaking
                ;	protocol should not bother printers that have not implemented
                ;	Xon/Xoff protocol so this driver is enabled all the time.
                ;
 ADB5 02        IOCONF:	DB	2		;Revision 2 structure
 ADB6 0B        	DB	11		;11 bytes long now
 ADB7 02        	DB	CONTYP		;Console device driver number
 ADB8 03        	DB	LSTTYP		;List device drive number
 ADB9 00        IOBYT:	DB	00000000B	;Initial IOBYT value (All devices go to CON:)
 ADBA 00        GROUP:	DB	0		;Group byte
                	IF	NOT ABSASM	;if rmac
                	PUBLIC	GROUP
                	ENDIF
 ADBB 0C00      DEFCON:	DW	CBAUD		;Console baud rate divisor value
 ADBD 6000      DEFLST:	DW	LBAUD		;Printer baud rate divisor value
                	;Clear To Send protocol
                	IF	LSTTYP EQ 3
 ADBF 10        LSTAND:	DB	CTS		;Serial list handshake mask
 ADC0 00        LSTXOR:	DB	0		;Serial list inversion flag
                	ENDIF
                	;Data Set Ready protocol
                	IF	LSTTYP EQ 4
                LSTAND:	DB	DSR		;Serial list handshake mask
                LSTXOR:	DB	0		;Serial list inversion flag
                	ENDIF
                	;Xon/Xoff protocol
                	IF	(LSTTYP NE 3) AND (LSTTYP NE 4)
                LSTAND:	DB	0		;Serial list handshake mask
                LSTXOR:	DB	0FFH		;Serial list inversion flag
                	ENDIF
 ADC1 11        LASTCH:	DB	XON		;Last character recieved from the printer
                	PAGE
CP/M MACRO ASSEM 2.0	#016	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Configuration Pointer Table
                ;===========================
                ;	At the first page boundry following the CBIOS we have a series of
                ;	pointers that point to various internal tables. At the start of
                ;	each of these tables we have a revision byte and a length byte.
                ;	The revision byte is the current revision number for that
                ;	particular structure and the length byte is the length of that
                ;	structure.  This length does not include the revision byte nor
                ;	the length byte itself.
                ;
                ;		Revision	Description
                ;		E.0		1 and 2 defined
                ;		E.3		This table is moved to a page boundry
                ;		E.3		0, 3 and 4 defined
                ;
                ;	The pointers defined so far are as follows:
                ;	-------------------------------------------
                ;		0) High byte is the page number of the CBIOS.  Low byte is
                ;		   the CBIOS revision number.  Used to determine pointer
                ;		   structure.
                ;		1) This points to the drive configuration table.
                ; 		2) This points to the I/O configuration bytes for the serial
                ;		   drivers.  Eg, the console, printer, reader, and punch
                ;       	   devices.
                ;		3) This points to the drive parameter table for DJDMA floppy
                ;       	   disk drives.  If no DJDMA is present then this pointer is
                ;		   null (0).
                ;		4) This points to the autostart command structures.  Used to
                ;		   automatically invoke a command on cold or warm boot
                ;		5) This will be a null (0) pointer.  It marks the end of
                ;		   the table.
                ;
                	IF	($ - CBIOS) GT 256	;Test for code overlap
                	'Fatal error, pointer table placement.'
                	ELSE
 ADC2           	DS	100H - (LOW ($ - CBIOS))  ;Start at a page boundry
                	ENDIF
                	;bpage is filled-in at run-time by init
 AE00 00        BPAGE:	DB	0		;CBIOS page number
 AE01 36        	DB	REVNUM		;Cbios revision number
 AE02 AFAD      	DW	DRCONF		;Drive configuration table pointer
 AE04 B5AD      	DW	IOCONF		;I/O configuration table pointer
                	IF	(MAXDM NE 0) OR (MAXMF NE 0)
 AE06 3FB0      	DW	DMARAP		;Drive parameter table pointer for DJDMA
                	ELSE
                	DW	0
                	ENDIF
 AE08 A6AD      	DW	AUTOST		;Auto command structure pointer
 AE0A 0000      	DW	0		;End of table marker
                	PAGE
CP/M MACRO ASSEM 2.0	#017	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;************************
                ;Begin BIOS Disk Routines
                ;************************
                ;
                ;Home the Disk (HOME)
                ;====================
                ;	Home is translated into a seek to track zero.
                ;
 AE0C 3A4DAF    HOME:	LDA	BUFWRTN		;Test buffer dirty flag
 AE0F B7        	ORA	A
 AE10 C217AE    	JNZ	DOHOME		;Skip buffer disable if buffer dirty
 AE13 AF        	XRA	A		;Invalidate buffer on home call
 AE14 323EB7    	STA	BUFSEC
 AE17 010000    DOHOME:	LXI	B,0		;Track to seek to
 AE1A CD81AE    	CALL	SETTRK
 AE1D C9        	RET
                ;Select a Disk Dirve (SELDSK)
                ;============================
                ;	Setdrv selects the next drive to be used in read/write
                ;	operations.  If the drive has never been selected it calls
                ;	a low level drive select routine that should perform some
                ;	sort of check if the device is working.  If not working then
                ;	it should report an error.  If the logical drive has been
                ;	selected before then setdrv just returns the DPH without
                ;	checking the drive.
                ;
 AE1E 79        SETDRV:	MOV	A,C		;Save the logical drive number
 AE1F 3235B7    	STA	CPMDRV
 AE22 FE04      	CPI	MAXLOG		;Check for a valid drive number
 AE24 D2F8AF    	JNC	ZRET		;Illegal drive
 AE27 7B        	MOV	A,E		;Check if bit 0 of (e) = 1
 AE28 E601      	ANI	1
 AE2A C262AE    	JNZ	SETD3		;Drive has allready been accessed
 AE2D 61        	MOV	H,C		;Move logical drive into (h)
 AE2E 2E02      	MVI	L,D$SEL1
 AE30 CDAFAF    	CALL	JUMPER		;Call low level drive select
 AE33 7C        	MOV	A,H		;Check if the low level drive select returned
 AE34 B5        	ORA	L		;zero to indicate an error
 AE35 CAF8AF    	JZ	ZRET		;Yes, an error so report to CP/M
 AE38 E5        	PUSH	H		;Save DPH address
 AE39 CD74AE    	CALL	GDPH		;Get entry if DPH save table
 AE3C D1        	POP	D		;DPH -> (de)
 AE3D 73        	MOV	M,E		;Put address of DPH in table
 AE3E 23        	INX	H
 AE3F 72        	MOV	M,D
 AE40 23        	INX	H
 AE41 71        	MOV	M,C		;Put sector size in table
 AE42 23        	INX	H
 AE43 7E        	MOV	A,M		;Check if bad map has ever been read for this
 AE44 B7        	ORA	A		; drive
 AE45 CC21B0    	CZ	GETBAD		;Never been read so read in bad map
 AE48 EB        	XCHG			;DPH -> (hl)
 AE49 79        SETD0:	MOV	A,C		;Move sector size code into (a)
 AE4A 32A6AE    	STA	SECSIZ		;Save sector size
 AE4D AF        	XRA	A
CP/M MACRO ASSEM 2.0	#018	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AE4E 0D        SETD1:	DCR	C		;Create number of (128 bytes/physical sector)-1
 AE4F CA58AE    	JZ	SETD2
 AE52 07        	RLC
 AE53 F601      	ORI	1
 AE55 C34EAE    	JMP	SETD1
 AE58 32E4AE    SETD2:	STA	SECPSEC		;Save for deblocking
 AE5B 3A35B7    	LDA	CPMDRV		;Save current drive as old drive
 AE5E 3244B7    	STA	LASTDRV		; in case of select errors
 AE61 C9        	RET
 AE62 61        SETD3:	MOV	H,C		;Drive in (h)
 AE63 2E03      	MVI	L,D$SEL2	;Select drive
 AE65 CDAFAF    	CALL	JUMPER
 AE68 CD74AE    	CALL	GDPH		;Quick select
 AE6B 5E        	MOV	E,M		;DPH -> (de)
 AE6C 23        	INX	H
 AE6D 56        	MOV	D,M
 AE6E 23        	INX	H
 AE6F 4E        	MOV	C,M		;Sector size -> (c)
 AE70 EB        	XCHG			;DPH -> (hl)
 AE71 C349AE    	JMP	SETD0
                ;Return a pointer to the current drive's DPH
                ;-------------------------------------------
                ;	1) This routine is only called by SETDRV.
                ;	2) The drive number should be in location CPMDRV. The DE register
                ;	   pair is destroyed. The DPH pointer is returned in the HL
                ;	   register pair								;
                ;
 AE74 3A35B7    GDPH:	LDA	CPMDRV		;Return pointer to DPH save area
 AE77 07        	RLC			;Each entry is 4 bytes long
 AE78 07        	RLC
 AE79 5F        	MOV	E,A
 AE7A 1600      	MVI	D,0
 AE7C 212FB0    	LXI	H,DPHTAB	;DPH save area table
 AE7F 19        	DAD	D		;Add offset
 AE80 C9        	RET			;(hl) = DPH save area for current drive
                ;Select a Track (SELTRK)
                ;=======================
                ;	Settrk saves the track # to seek to. Nothing is done at this
                ;	point, everything is deffered until a read or write.
                ;
 AE81 60        SETTRK:	MOV	H,B	;Enter with track number in (bc)
 AE82 69        	MOV	L,C
 AE83 2236B7    	SHLD	CPMTRK
 AE86 C9        	RET
                ;Select a Sector (SETSEC)
                ;========================
                ;	Setsec just saves the desired sector to seek to until an
                ;	actual read or write is attempted.
                ;
 AE87 60        SETSEC:	MOV	H,B		;Enter with sector number in (bc)
 AE88 69        	MOV	L,C
 AE89 2233B7    	SHLD	CPMSEC
 AE8C C9        DONOP:	RET
                ;Set the DMA Address (SETDMA)
                ;============================
                ;	Setdma saves the DMA address for the data transfer.
CP/M MACRO ASSEM 2.0	#019	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;
 AE8D 60        SETDMA:	MOV	H,B		;Enter with DMA address in (bc)
 AE8E 69        	MOV	L,C
 AE8F 22F5AE    	SHLD	CPMDMA		;CP/M dma address
 AE92 C9        	RET
                ;Read Data from a Disk (READ)
                ;============================
                ;	Read routine to buffer data from the disk. If the sector
                ;	requested from CP/M is in the buffer, then the data is simply
                ;	transferred from the buffer to the desired dma address. If
                ;	the buffer does not contain the desired sector, the buffer is
                ;	flushed to the disk if it has ever been written into, then
                ;	filled with the sector from the disk that contains the
                ;	desired CP/M sector.
                ;
 AE93 AF        READ:	XRA	A		;Set the command type to read
                	IF	NOSTAND NE 0
                	STA	UNALOC		;Clear unallocated write flag
                	ENDIF
 AE94 CDA2AE    	CALL	RWENT
 AE97 C9        	RET
                ;Write Data to a Disk (WRITE)
                ;============================
                ;	Write routine moves data from memory into the buffer. If the
                ;	desired CP/M sector is not contained in the disk buffer, the
                ;	buffer is first flushed to the disk if it has ever been
                ;	written into, then a read is performed into the buffer to get
                ;	the desired sector. Once the correct sector is in memory, the
                ;	buffer written indicator is set, so the buffer will be
                ;	flushed, then the data is transferred into the buffer.
                ;
 AE98 79        WRITE:	MOV	A,C		;Save write command type
 AE99 320EAF    	STA	WRITTYP
 AE9C 3E01      	MVI	A,1		;Set write command
 AE9E CDA2AE    	CALL	RWENT
 AEA1 C9        	RET
                ;Read/Write to/from the disk
                ;---------------------------
                ;	Redwrt calculates the physical sector on the disk that
                ;	contains the desired CP/M sector, then checks if it is the
                ;	sector currently in the buffer. If no match is made, the
                ;	buffer is flushed if necessary and the correct sector read
                ;	from the disk.
                ;
                	IF	NOT ABSASM	;if rmac
                	PUBLIC	RWENT,FILL,FLUSH,PREP,JUMPER
                	ENDIF
 AEA2 32F8AE    RWENT:	STA	RDWR		;Save command type
 AEA5 0600      	MVI	B,0		;The 0 is modified to contain the log2
 AEA6 =         SECSIZ	EQU	$-1		;	of the physical sector size/128
                				;	on the currently selected disk
 AEA7 2A33B7    	LHLD	CPMSEC		;Get the desired CP/M sector #
 AEAA 7C        	MOV	A,H
 AEAB E680      	ANI	80H		;Save only the side bit
 AEAD 4F        	MOV	C,A		;Remember the side
 AEAE 7C        	MOV	A,H
CP/M MACRO ASSEM 2.0	#020	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AEAF E67F      	ANI	7FH		;Forget the side bit
 AEB1 67        	MOV	H,A
 AEB2 2B        	DCX	H		;Temporary adjustment
 AEB3 05        DIVLOOP:DCR	B		;Update repeat count
 AEB4 CAC1AE    	JZ	DIVDONE
 AEB7 B7        	ORA	A
 AEB8 7C        	MOV	A,H
 AEB9 1F        	RAR
 AEBA 67        	MOV	H,A
 AEBB 7D        	MOV	A,L
 AEBC 1F        	RAR			;Divide the CP/M sector # by the size
 AEBD 6F        	MOV	L,A		;	of the physical sectors
 AEBE C3B3AE    	JMP	DIVLOOP
 AEC1 23        DIVDONE:INX	H
 AEC2 7C        	MOV	A,H
 AEC3 B1        	ORA	C		;Restore the side bit
 AEC4 67        	MOV	H,A
 AEC5 2238B7    	SHLD	TRUESEC		;Save the physical sector number
 AEC8 2135B7    	LXI	H,CPMDRV	;Pointer to desired drive,track, and sector
 AECB 113BB7    	LXI	D,BUFDRV	;Pointer to buffer drive,track, and sector
 AECE 0606      	MVI	B,6		;Count loop
 AED0 05        DTSLOP:	DCR	B		;Test if done with compare
 AED1 CADFAE    	JZ	MOVE		;Yes, match. Go move the data
 AED4 1A        	LDAX	D		;Get a byte to compare
 AED5 BE        	CMP	M		;Test for match
 AED6 23        	INX	H		;Bump pointers to next data item
 AED7 13        	INX	D
 AED8 CAD0AE    	JZ	DTSLOP		;Match, continue testing
                	;If Drive, track, and sector don't match, flush the buffer if
                	;necessary and then refill.
 AEDB CD21AF    	CALL	FILL		;Fill the buffer with correct physical sector
 AEDE D8        	RC			;No good, return with error indication
                	;Move has been modified to cause either a transfer into or out
                	;the buffer.
 AEDF 3A33B7    MOVE:	LDA	CPMSEC		;Get the CP/M sector to transfer
 AEE2 3D        	DCR	A		;Adjust to proper sector in buffer
 AEE3 E600      	ANI	0		;Strip off high ordered bits
 AEE4 =         SECPSEC	EQU	$-1		;The 0 is modified to represent the # of
                				;	CP/M sectors per physical sectors
 AEE5 6F        	MOV	L,A		;Put into HL
 AEE6 2600      	MVI	H,0
 AEE8 29        	DAD	H		;Form offset into buffer
 AEE9 29        	DAD	H
 AEEA 29        	DAD	H
 AEEB 29        	DAD	H
 AEEC 29        	DAD	H
 AEED 29        	DAD	H
 AEEE 29        	DAD	H
 AEEF 110EB8    	LXI	D,BUFFER	;Starting address of buffer
 AEF2 19        	DAD	D		;Form beginning address of sectgr to transfer
 AEF3 EB        	XCHG			;DE = address in buffer
 AEF4 210000    	LXI	H,0		;Get DMA address, the 0 is modified t/
 AEF5 =         CPMDMA	EQU	$-2		;	contain the DMA address
 AEF7 3E00      	MVI	A,0		;The zero gets modified to contain
 AEF8 =         RDWR	EQU	$-1		;	a zero if a read, or a 1 if write
 AEF9 A7        	ANA	A		;Test which kind of operation
CP/M MACRO ASSEM 2.0	#021	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AEFA C204AF    	JNZ	INTO		;Transfer data into the buffer
 AEFD CDD2AF    OUTOF:	CALL	MOV128
 AF00 3A3AB7    	LDA	ERROR		;Get the buffer error flag
 AF03 C9        	RET
 AF04 EB        INTO:	XCHG			;
 AF05 CDD2AF    	CALL	MOV128		;Move the data, HL = destination
 AF08 3E01      	MVI	A,1		;	DE = source
 AF0A 324DAF    	STA	BUFWRTN		;Set buffer written into flag
 AF0D 3E00      	MVI	A,0		;Check for directory write
 AF0E =         WRITTYP	EQU	$-1
 AF0F 3D        	DCR	A		;Test for a directory write (a=1=dir)
 AF10 3E00      	MVI	A,0
 AF12 C0        	RNZ			;	if not dir then exit (a=0=no-error)
 AF13 CD4CAF    	CALL	FLUSH		;Flush the buffer if this is a dir oper
 AF16 C9        	RET			;(Accm is setup by the routine PREP)
                ;Perform Sector Translation (SECTRAN)
                ;====================================
                ;Sectran translates a logical sector number into a physical
                ;	sector number.
                ;
 AF17 3A35B7    SECTRAN:LDA	CPMDRV		;Get the Drive Number
 AF1A 67        	MOV	H,A		;Drive in (h)
 AF1B 2E01      	MVI	L,D$STRAN
 AF1D CDAFAF    	CALL	JUMPER		;See device level sector translation routines
 AF20 C9        	RET
                	PAGE
CP/M MACRO ASSEM 2.0	#022	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Begin CBIOS Disk Routine Utilities
                ;==================================
                ;	These are general purpose routines that are used by by one or more
                ;	of the preceeding CBIOS Disk Routines and/or the Lo_Level drivers.
                ;
                ;Fill the Buffer with a new Sector
                ;---------------------------------
                ;	Fill fills the buffer with a new sector from the disk. If
                ;	were no errors then the carry is returned cleared else it is
                ;	set.
                ;
 AF21 CD4CAF    FILL:	CALL	FLUSH		;Flush buffer first
 AF24 D8        	RC			;(carry is set if there were any errors)
 AF25 1135B7    	LXI	D,CPMDRV	;Update the drive, track, and sector
 AF28 213BB7    	LXI	H,BUFDRV
 AF2B 010500    	LXI	B,5		;Number of bytes to move
 AF2E CDD5AF    	CALL	MOVBYT		;Copy the data
 AF31 3AF8AE    	LDA	RDWR		;Test read write flag
 AF34 B7        	ORA	A
 AF35 CA43AF    	JZ	FREAD		;Skip write type check if reading
 AF38 3A0EAF    	LDA	WRITTYP		;0 = alloc, 1 = dir, 2 = unalloc
                	IF	NOSTAND NE 0	;Do non standard (but quick and dirty) check
                	ORA	A		;(clears the carry)
                	JNZ	FNALOC		;Skip if not an allocated write
                	LDA	UNALOC		;Check unallocated write in progress flag
                	ORA	A		;(clears the carry flag)
                	JZ	FWRITIN		;We are doing an allocated write
                	LHLD	CBLOCK		;Get current block address
                	XCHG
                	LHLD	OBLOCK		;   and old block address
                	MOV	A,D		;Compare old versus new
                	CMP	H
                	JNZ	AWRITIN		;Different, clear unallocated writting mode
                	MOV	A,E
                	CMP	L
                	JNZ	AWRITIN
                	LXI	H,CPMDRV	;Test for different drive
                	LDA	UNADRV
                	CMP	M		;(reset the carry on equal)
                	JNZ	AWRITIN		;Drive is different, clear unallocated mode
                	RET			;Unallocated write (return with carry=clear)
                FNALOC:	DCR	A		;(doesn't affect carry)
                	JZ	AWRITIN		;Do a directory write
                				;We are now doing an unallocated write
                	LHLD	CBLOCK		;Save current block number
                	SHLD	OBLOCK
                	LDA	CPMDRV		;Save drive that this block belongs to
                	STA	UNADRV
                	MVI	A,1		;Set unallocated write flag
                	STA	UNALOC		;   and we do nothing about the write
                	RET			;(carry cleared by last ora)
                AWRITIN:XRA	A		;Clear unallocated writting mode
                	STA	UNALOC
                	ELSE			;Do standard unallocated test
 AF3B D602      	SUI	2		;Test for an unallocated write
CP/M MACRO ASSEM 2.0	#023	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AF3D C8        	RZ			;(carry will be cleared if zero result)
                	ENDIF
 AF3E 3AA6AE    FWRITIN:LDA	SECSIZ		;Check for 128 byte sectors
 AF41 3D        	DCR	A		;(doesn't affect the carry flag)
 AF42 C8        	RZ			;No deblocking (carry cleared by last ora)
 AF43 3E08      FREAD:	MVI	A,D$READ
 AF45 3286AF    	STA	RWOP
 AF48 CD59AF    	CALL	PREP		;Read the physical sector the buffer
 AF4B C9        	RET			;(carry and accm set by prep)
                ;Flush the Disk Buffer
                ;---------------------
                ;	Flush writes the contents of the buffer out to the disk if
                ;	it has ever been written into. If there are any errors then
                ;	the carry is returned set else it is cleared.
                ;
 AF4C 3E00      FLUSH:	MVI	A,0		;The 0 is modified to reflect if
 AF4D =         BUFWRTN	EQU	$-1		;	the buffer has been written into
 AF4E B7        	ORA	A		;Test if written into
 AF4F C8        	RZ			;Not written, all done (or clears the carry)
 AF50 3E09      	MVI	A,D$WRITE
 AF52 3286AF    	STA	RWOP
 AF55 CD59AF    	CALL	PREP		;Do the physical write
 AF58 C9        	RET			;(carry and accm set by prep)
                ;Prepare the Disk for Reading and/or Writing
                ;-------------------------------------------
                ;	1) This is actually the place where disks are read/written (contrary
                ;	   to the name of this routine)
                ;	2) Prep prepares to read/write the disk. Retries are attempted.
                ;	   If there are any errors then the carry is returned
                ;	   set and the location ERROR is set to 0FFh, else the carry is
                ;	   returned cleared ERROR is reset to zero.
                ;
 AF59 CD22B0    PREP:	CALL	ALT		;Check for alternate sectors
 AF5C F3        	DI			;Reset interrupts
 AF5D AF        	XRA	A		;Reset buffer written flag
 AF5E 324DAF    	STA	BUFWRTN
 AF61 060A      	MVI	B,RETRIES	;Maximum number of retries to attempt
 AF63 C5        RETRYLP:PUSH	B		;Save the retry count
 AF64 2E03      	MVI	L,D$SEL2	;Select drive
 AF66 CDABAF    	CALL	JUMPBUF
 AF69 2A40B7    	LHLD	ALTTRK		;Track number -> (hl)
 AF6C 44        	MOV	B,H
 AF6D 4D        	MOV	C,L
 AF6E 2E05      	MVI	L,D$STRK
 AF70 CDABAF    	CALL	JUMPBUF
 AF73 2A42B7    	LHLD	ALTSEC		;Sector -> (hl)
 AF76 44        	MOV	B,H
 AF77 4D        	MOV	C,L
 AF78 2E06      	MVI	L,D$SSEC
 AF7A CDABAF    	CALL	JUMPBUF
 AF7D 010EB8    	LXI	B,BUFFER	;Set the DMA address
 AF80 2E07      	MVI	L,D$SDMA
 AF82 CDABAF    	CALL	JUMPBUF
 AF85 2E00      	MVI	L,0		;Get operation address offset (8 or 9)
 AF86 =         RWOP	EQU	$-1		;(set by FREAD [read=8] and FLUSH [write=9])
 AF87 CDABAF    	CALL	JUMPBUF		;Read or write to the disk
CP/M MACRO ASSEM 2.0	#024	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AF8A C1        	POP	B		;Restore the retry counter
 AF8B 3E00      	MVI	A,0		;No error exit status
 AF8D D2A7AF    	JNC	PRPRET		;Return NO ERROR (accm=0, carry=clear)
 AF90 05        	DCR	B		;Update the retry counter
 AF91 37        	STC			;Assume retry count expired
 AF92 3EFF      	MVI	A,0FFH		;Error return
 AF94 CAA7AF    	JZ	PRPRET		;Return ERROR (accm=ff, carry=set)
 AF97 78        	MOV	A,B
 AF98 FE05      	CPI	RETRIES/2
 AF9A C263AF    	JNZ	RETRYLP		;Try again
 AF9D C5        	PUSH	B		;Save retry count
 AF9E 2E04      	MVI	L,D$HOME	;Home drive after (retries/2) errors
 AFA0 CDABAF    	CALL	JUMPBUF
 AFA3 C1        	POP	B
 AFA4 C363AF    	JMP	RETRYLP		;Try again
 AFA7 323AB7    PRPRET:	STA	ERROR		;save the error flag
 AFAA C9        	RET
                ;Access a lo-level driver subroutine
                ;-----------------------------------
                ;	Jumpbuf, jumper are used to dispatch to a low level device
                ;	subroutine.  Jumper is called with the drive in (h) and the
                ;	routine number (see description above) in (l).  It passes
                ;	along the (bc) and (de) registers unaltered.  Jumpbuf is
                ;	a call to jumper with the drive number from bufdrv.
                ;
                	;Entry Point_1
 AFAB 3A3BB7    JUMPBUF:LDA	BUFDRV		;Dispatch with bufdrv for drive
 AFAE 67        	MOV	H,A
                	;Entry Point_2
 AFAF D5        JUMPER:	PUSH	D
 AFB0 C5        	PUSH	B
 AFB1 E5        	PUSH	H
 AFB2 7C        	MOV	A,H		;Logical drive into (a)
 AFB3 11B1AD    	LXI	D,DSTTAB	;Drive specification pointer table
 AFB6 4F        JUMPL:	MOV	C,A		;Save logical in (c)
 AFB7 1A        	LDAX	D
 AFB8 6F        	MOV	L,A
 AFB9 13        	INX	D
 AFBA 1A        	LDAX	D
 AFBB 67        	MOV	H,A		;Get a DST pointer in (hl)
 AFBC 13        	INX	D
 AFBD 79        	MOV	A,C		;Logical in (a)
 AFBE 96        	SUB	M		;Subtract from first entry in DST
 AFBF D2B6AF    	JNC	JUMPL		;Keep scanning table till correct driver found
 AFC2 23        	INX	H		;Bump (hl) to point to start of dispatch table
 AFC3 D1        	POP	D		;Real (hl) -> (de)
 AFC4 7B        	MOV	A,E		;Move offset number into (a)
 AFC5 07        	RLC			;Each entry is 2 bytes
 AFC6 5F        	MOV	E,A		;Make an offset
 AFC7 1600      	MVI	D,0
 AFC9 19        	DAD	D		;(hl) = **Routine
 AFCA 7E        	MOV	A,M		;Pick up address of handler for selected
 AFCB 23        	INX	H		; function
 AFCC 66        	MOV	H,M
 AFCD 6F        	MOV	L,A		;(hl) = *routine
 AFCE 79        	MOV	A,C		;Logical in (a)
CP/M MACRO ASSEM 2.0	#025	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 AFCF C1        	POP	B		;Restore saved registers
 AFD0 D1        	POP	D
 AFD1 E9        	PCHL
                ;Move Data
                ;---------
                ;	1) The entry point mov128 forces 128 bytes of data to be moved
                ;	   from source to destination.
                ;	2) The second entry point (movbyt) can move upto 65K of data.
                ;	3) The Source pointer is passed in the DE register pair.
                ;	4) The Destination pointer is passed in the HL register pair.
                ;
                	;Entry Point_1
 AFD2 018000    MOV128:	LXI	B,128		;Length of transfer
                	;Entry Point_2
 AFD5 AF        MOVBYT:	XRA	A		;Check if host processor is a Z80
 AFD6 C603      	ADI	3
 AFD8 E2E6AF    	JPO	Z80MOV		;Yes, Its a Z80 so use block move
 AFDB 1A        M8080:	LDAX	D		;Get a byte of source
 AFDC 77        	MOV	M,A		;Move it
 AFDD 13        	INX	D		;Bump pointers
 AFDE 23        	INX	H
 AFDF 0B        	DCX	B		;Update counter
 AFE0 78        	MOV	A,B		;Test for end
 AFE1 B1        	ORA	C
 AFE2 C2DBAF    	JNZ	M8080
 AFE5 C9        	RET
 AFE6 EB        Z80MOV: XCHG			;Source in (hl), Destination in (de)
 AFE7 EDB0      	DW	0B0EDH		;ldir
 AFE9 EB        	XCHG
 AFEA C9        	RET
                ;Print a Message
                ;---------------
                ;Utility routine to output the message pointed at by (hl)
                ;terminated with a null.
                ;
 AFEB 7E        MESSAGE:MOV	A,M		;Get a character of the message
 AFEC 23        	INX	H		;Bump text pointer
 AFED B7        	ORA	A		;Test for end
 AFEE C8        	RZ			;Return if done
 AFEF E5        	PUSH	H		;Save pointer to text
 AFF0 4F        	MOV	C,A		;Output character in C
 AFF1 CD0CAD    	CALL	COUT		;Output the character
 AFF4 E1        	POP	H		;Restore the pointer
 AFF5 C3EBAF    	JMP	MESSAGE		;Continue until null reached
                ;Drive select error return
                ;-------------------------
                ;	1) This routine sets the HL pair to zero (the sel-drive error
                ;	return condition) and updates the value of CDISK. Notice that
                ;	this routine is called from both the high level select routine
                ;	(SETDRV) and from the lo-level routines as well (e.g. MFLDR1
                ;	in the DJDMA drivers). To stop infinite select error loops by the
                ;	CCP, cdisk is modified if it specifies the disk in error.
                ;
 AFF8 210000    ZRET:	LXI	H,0		;Seldrv error exit
 AFFB 3A0400    	LDA	CDISK
 AFFE E60F      	ANI	15		;isolate 'ccp' curr disk (strip user num)
CP/M MACRO ASSEM 2.0	#026	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B000 4F        	MOV	C,A
 B001 3A35B7    	LDA	CPMDRV		;get curr selected drive
 B004 B9        	CMP	C
 B005 C0        	RNZ			;exit if not 'ccp' select error
 B006 3A44B7    	LDA	LASTDRV		;Get last valid selected drive
 B009 4F        	MOV	C,A
 B00A 3A0400    	LDA	CDISK		;Pick up user/drive
 B00D E6F0      	ANI	0F0H		;Save user number
 B00F B1        	ORA	C		;Put together with old valid drive
 B010 320400    	STA	CDISK		;set new default disk for 'ccp'
 B013 C9        	RET
                ;No bad Map
                ;----------
                ;	This routine is used by the lo-level drivers to indicate that
                ;	the selected device has no bad map.
                ;
 B014 210000    NOBAD:	LXI	H,0		;Used by device drives to indicate no bad
 B017 C9        	RET			; sector map
                ;Return DPH pointer
                ;------------------
                ;	Enter with (de) with DPH base address and (a) with logical
                ;	drive number.  Returns with DPH address in (hl).
                ;
 B018 6F        RETDPH:	MOV	L,A		;Move logical drive into (l)
 B019 2600      	MVI	H,0
 B01B 29        	DAD	H		;Multiply by 16 (size of DPH)
 B01C 29        	DAD	H
 B01D 29        	DAD	H
 B01E 29        	DAD	H
 B01F 19        	DAD	D		;(hl) = pointer to DPH
 B020 C9        	RET
                	PAGE
CP/M MACRO ASSEM 2.0	#027	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;CBIOS Bad Map Routines (only for HDDMA)
                ;=======================================
                ;
                ;null routines if no HDDMA
                ;-------------------------
                ;
                	IF	MAXMW EQ 0	;if no HDDMA
                ;
 B021 C9        GETBAD:	RET			;no bad map to read from disk
                ;
 B022 2A3CB7    ALT:	LHLD	BUFTRK		;No alternate sector so use selected sector
 B025 2240B7    	SHLD	ALTTRK
 B028 2A3EB7    	LHLD	BUFSEC
 B02B 2242B7    	SHLD	ALTSEC
 B02E C9        	RET
                ;
                	ELSE			;have a HDDMA
                ;Check if a device has a bad map
                ;-------------------------------
                ;	1) This routine is only called by SETDRV
                ;	2) If the device has a bad sector map then append bad entries to end
                ;	   of badmap table.
                ;	3) This routine is only required for HDDMA.
                ;
                GETBAD:	MVI	M,1		;Set drive initilized
                	PUSH	B
                	PUSH	D
                	LDA	CPMDRV		;Pick up current drive
                	MOV	H,A		;Call drive routine to return a pointer to
                	MVI	L,D$BAD		;the track and sector of the bad map
                	CALL	JUMPER
                	MOV	A,H		;If routine returns 0 then the device has
                	ORA	L		; no bad sector map
                	JZ	BADRET
                	MOV	E,M		;Pick up track number of bad sector map -> (de)
                	INX	H
                	MOV	D,M
                	INX	H
                	XCHG
                	SHLD	CPMTRK
                	XCHG
                	MOV	A,M		;Pick up sector number of of bad sector map
                	INX	H
                	MOV	H,M
                	MOV	L,A
                	SHLD	TRUESEC
                	CALL	FILL		;Read in bad sector map into the buffer
                	RC
                	LHLD	BADPTR		;Pick up bad map pointer
                	LXI	D,BUFFER	;Start at beginning of buffer
                BADL:	LDAX	D		;Pick up an entry from the buffer
                	ORA	A
                	JZ	BADE		;All done
                	MOV	A,M		;Pick up entry from bad map table
                	INR	A
CP/M MACRO ASSEM 2.0	#028	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	JZ	OVERFLO		;Bad map overflow
                	LDA	CPMDRV		;Put drive in table
                	MOV	M,A
                	INX	H
                	LXI	B,8
                	CALL	MOVBYT		;Move the rest of information into the table
                	JMP	BADL
                BADE:	SHLD	BADPTR		;Restore new bad map pointer
                BADRET:	POP	D
                	POP	B
                	RET
                OVERFLO:LXI	H,OMES
                	CALL	MESSAGE
                	JMP	BADRET
                ;Check for alternate sectors in bad sector table
                ;-----------------------------------------------
                ;	1) This routine is only called by PREP.
                ;	2) If an alternate sector is found replace alttrk and altsec with
                ;	   new sector number else pass along unaltered.
                ;
                ALT:	LXI	H,BADMAP	;Address of bad map -> (hl)
                	LDA	BUFDRV		;Pick up drive number currently working on
                	MOV	C,A		;Move drive into (c) for speed in search
                ALL:	XCHG
                	LHLD	BADPTR		;Get bad map pointer
                	XCHG			; -> (de)
                	MOV	A,D		;Check if at end of bad map table
                	CMP	H
                	JNZ	ALT2		;Still more
                	MOV	A,E
                	CMP	L
                	JNZ	ALT2		;Still more
                	LHLD	BUFTRK		;No alternate sector so use selected sector
                	SHLD	ALTTRK
                	LHLD	BUFSEC
                	SHLD	ALTSEC
                	RET
                ALT2:	PUSH	H		;Save current bad map entry address
                	MOV	A,C		;Move drive into (a)
                	CMP	M		;Check if drive in table matches
                	JNZ	ALTMIS		;Does not match skip this entry
                	INX	H		;Point to LSB of alternate track
                	LDA	BUFTRK		;Pick up LSB of buffer track
                	CMP	M
                	JNZ	ALTMIS
                	INX	H		;Point to MSB alternate track
                	LDA	BUFTRK+1	;Pick up MSB of buffer track
                	CMP	M
                	JNZ	ALTMIS
                	INX	H		;Point to LSB of alternate sector
                	LDA	BUFSEC		;Pick up LSB of buffer sector
                	CMP	M
                	JNZ	ALTMIS
                	INX	H		;Point to MSB of alternate sector
                	LDA	BUFSEC+1	;Pick up MSB of buffer sector
                	CMP	M
CP/M MACRO ASSEM 2.0	#029	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	JNZ	ALTMIS		;Found an alternate sector
                	INX	H		;Point to real info on the alternate sector
                	LXI	D,ALTTRK
                	XCHG			;MOVLOP (de) = source, (hl) = dest
                	PUSH	B
                	LXI	B,4
                	CALL	MOVBYT		;Move alternate sector info in correct place
                	POP	B
                	POP	H
                	RET
                ALTMIS:	POP	H		;Current alternate did not match
                	LXI	D,9		;Bump pointer by the length of an entry
                	DAD	D
                	JMP	ALL		;Loop for more
                ;Bad Map Routines Data Areas
                ;---------------------------
                ;
                OMES:	DB	0DH, 0AH, 'BAD MAP OVERFLOW!', 0DH, 0AH, 0
                BADPTR:	DW	BADMAP		;Pointer to next available bad map entry
                	ENDIF			;end of Bad Map Routines
                	PAGE
CP/M MACRO ASSEM 2.0	#030	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;CBIOS Disk Routines Data Area
                ;=============================
                ;
                ;DPH save area
                ;-------------
                ;	1) Each entry is 4 bytes long:
                ;		0 - LSB of DPH address
                ;		1 - MSB of DPH address
                ;		2 - Sector size code (1=128, 2=256, 3=512, 4=1024)
                ;		3 - Bad map has been initilized (0 = Uninitilized)
                ;
                DPHTAB:	REPT	MAXLOG*4
                	DB	0
                	ENDM
 B02F+00        	DB	0
 B030+00        	DB	0
 B031+00        	DB	0
 B032+00        	DB	0
 B033+00        	DB	0
 B034+00        	DB	0
 B035+00        	DB	0
 B036+00        	DB	0
 B037+00        	DB	0
 B038+00        	DB	0
 B039+00        	DB	0
 B03A+00        	DB	0
 B03B+00        	DB	0
 B03C+00        	DB	0
 B03D+00        	DB	0
 B03E+00        	DB	0
                	PAGE
CP/M MACRO ASSEM 2.0	#031	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;**************************
                ;Begin Disk Driver Routines
                ;**************************
                ;
                ;General Equates and Macros
                ;==========================
                ;
                ;Disk System Dispatch Table Offsets
                ;----------------------------------
                ;	The following are offset numbers of Device Specification Tables.
                ;
 0000 =         D$WBOOT	EQU	0	;Warm boot
 0001 =         D$STRAN	EQU	1	;Sector translation
 0002 =         D$SEL1	EQU	2	;Drive select, Return DPH
 0003 =         D$SEL2	EQU	3	;Drive select
 0004 =         D$HOME	EQU	4	;Home drive
 0005 =         D$STRK	EQU	5	;Set track
 0006 =         D$SSEC	EQU	6	;Set sector
 0007 =         D$SDMA	EQU	7	;Set DMA address
 0008 =         D$READ	EQU	8	;Read a physical sector
 0009 =         D$WRITE	EQU	9	;Write a physical sector
 000A =         D$BAD	EQU	10	;Return pointer to bad sector info
                ;Disk System DPB Generation Macros
                ;---------------------------------
                ;	The following are the macros used in generating the DPH, DPB and
                ;	allocation tables.
                ;
                DPBGEN	MACRO	NAM,LOG,DSPT,DBSH,DBLM,DEXM,DDSM,DDRM,DAL0,DAL1,DCKS,DOFF,SSIZ
                DPB&NAM&LOG	EQU	$
                	DW	DSPT
                	DB	DBSH
                	DB	DBLM
                	DB	DEXM
                	DW	DDSM
                	DW	DDRM
                	DB	DAL0
                	DB	DAL1
                	DW	DCKS
                	DW	DOFF
                	DB	SSIZ
                	ENDM
                DPHGEN	MACRO	NAM,LOG,DPB1,DPB2
                DPH&NAM&LOG	EQU	$
                	DW	0
                	DW	0,0,0
                	DW	DIRBUF
                	DW	&DPB1&DPB2
                	DW	CSV&NAM&LOG
                	DW	ALV&NAM&LOG
                	ENDM
                ALLOC	MACRO	NAM,LOG,AL,CS
                CSV&NAM&LOG:	DS	CS
                ALV&NAM&LOG:	DS	AL
                	ENDM
                	PAGE
CP/M MACRO ASSEM 2.0	#032	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	(MAXDM NE 0) OR (MAXMF NE 0)	;DJDMA present?
                ;**************************************************************
                ;Begin the DJDMA Driver (DDRV1)
                ;******************************
                ;
                ;Step Rate tables
                ;================
                ;	1) The following table are drive parameters for drives connected to
                ;	   the DJDMA floppy disk controller.  There is one entry for each of
                ;	   the the eight drive that the controller can address.  The first
                ;	   four entries are for the 8" drives and the last four are for the
                ;	   5.25" drives.  Users with fast stepping 8" drives (SA850/1) or
                ;	   slow 5.25" drives (SA400) should adjust this table for optimal
                ;	   device performace.
                ;	2) Each table entry contains four fixed length fields.  The fields
                ;	   are defined as follows:
                ;
                ;		tracks	This byte contains the number of tracks on the
                ;			drive.  Most 8" drives have 77 tracks and
                ;			most 5.25" drives have 35 or 40 tracks.
                ;
                ;		config	This a a flag byte that indicates as to whether
                ;			or not this drive has been configured.  Set to
                ;			0 to force reconfiguration.
                ;
                ;		step	This word contains the stepping rate constant.
                ;			The DJDMA's delay routines tick 34.1 times per
                ;			millisecond.  Thus the step constant would be the
                ;			drive manufactors recomended stepping delay times
                ;			34.1.  Example.  Shugart SA 850's step at 3
                ;			milliseond intervals.  The step constant would be
                ;			3 * 43.1 or 102.
                ;
                ;		rfu	The next two words are reserved for future use.
                ;			They must be zero.
                ;
                ;		settle	This word is similar to the previously defined
                ;			step word.  This specifies the head settle timing
                ;			after the heads have been stepped.  Example,
                ;			Shugart's SA 850 head settle time is 15
                ;			milliseconds.  The settle constant would be 15 *
                ;			34.1 or 512.
                ;
                ;	3) An assembler macro (DCONF) has been provided to assist in
                ;	   generating the dparam table.  This macros parameters are the
                ;	   number of tracks, the step rate in milliseconds, and the head
                ;	   settle time in milliseconds.  For example:
                ;
                ;				;Shugart SA 850
                ;	dconf	77, 3, 15	;77 tracks, 3 ms step, 15 ms settle
                ;
                ;				;Shugart SA 400
                ;	dconf	35, 40, 10	;35 tracks, 40 ms step, 10 ms settle
                ;
                ;	4) Note: Caution should be used when defining the drive parameters.
CP/M MACRO ASSEM 2.0	#033	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;	   Incorrect definations may damage the floppy disk drive.  Morrow
                ;	   Designs takes no responsibility for damage that occures through
                ;	   the misuse of this macro.
                ;
                DCONF	MACRO	TRACKS, STEP, SETTLE
                	DB	TRACKS			;Number of tracks
                	DB	0			;Reset the calibrated flag
                	DW	STEP*341/10		;Step time
                	DW	0			;Reserved for future use, must be zero
                	DW	0			;Reserved for future use, must be zero
                	DW	SETTLE*341/10		;Head settle time
                	ENDM
 B03F 0050      DMARAP:	DB	0, 10*8			;Revision 0, length 80 bytes
 B041 =         DPARAM	EQU	$			;Drive parameter table
                ;
                ;Define 8" drive parameters
                ;--------------------------
                ;	1) Use SA800 parameters: 77 tracks, 8 ms step, 8 ms settle
                ;
                	DCONF	77, 8, 8		;Drive 0
 B041+4D        	DB	77			;Number of tracks
 B042+00        	DB	0			;Reset the calibrated flag
 B043+1001      	DW	8*341/10		;Step time
 B045+0000      	DW	0			;Reserved for future use, must be zero
 B047+0000      	DW	0			;Reserved for future use, must be zero
 B049+1001      	DW	8*341/10		;Head settle time
                	DCONF	77, 8, 8		;Drive 1
 B04B+4D        	DB	77			;Number of tracks
 B04C+00        	DB	0			;Reset the calibrated flag
 B04D+1001      	DW	8*341/10		;Step time
 B04F+0000      	DW	0			;Reserved for future use, must be zero
 B051+0000      	DW	0			;Reserved for future use, must be zero
 B053+1001      	DW	8*341/10		;Head settle time
                	DCONF	77, 8, 8		;Drive 2
 B055+4D        	DB	77			;Number of tracks
 B056+00        	DB	0			;Reset the calibrated flag
 B057+1001      	DW	8*341/10		;Step time
 B059+0000      	DW	0			;Reserved for future use, must be zero
 B05B+0000      	DW	0			;Reserved for future use, must be zero
 B05D+1001      	DW	8*341/10		;Head settle time
                	DCONF	77, 8, 8		;Drive 3
 B05F+4D        	DB	77			;Number of tracks
 B060+00        	DB	0			;Reset the calibrated flag
 B061+1001      	DW	8*341/10		;Step time
 B063+0000      	DW	0			;Reserved for future use, must be zero
 B065+0000      	DW	0			;Reserved for future use, must be zero
 B067+1001      	DW	8*341/10		;Head settle time
                ;
                ;Define 5.25" drive parameters
                ;-----------------------------
                ;	1) Use Tandon parameters: 40 tracks, 5 ms step, 15 ms settle
                ;	2) Note: Drive 1 is set up for a 20ms step rate and a 25ms head
                ;	   settling time so that it will operate properly with our
                ;	   soft-sectored drives.
                ;
                	IF	MFSLOW
CP/M MACRO ASSEM 2.0	#034	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	DCONF	40, 20, 20		;Drive 0
                	DCONF	40, 20, 20		;Drive 1
                	DCONF	40, 20, 20		;Drive 2
                	DCONF	40, 20, 20		;Drive 3
                	ELSE
                	DCONF	40,  5, 15		;Drive 0
 B069+28        	DB	40			;Number of tracks
 B06A+00        	DB	0			;Reset the calibrated flag
 B06B+AA00      	DW	5*341/10		;Step time
 B06D+0000      	DW	0			;Reserved for future use, must be zero
 B06F+0000      	DW	0			;Reserved for future use, must be zero
 B071+FF01      	DW	15*341/10		;Head settle time
                	DCONF	40,  5, 15		;Drive 1
 B073+28        	DB	40			;Number of tracks
 B074+00        	DB	0			;Reset the calibrated flag
 B075+AA00      	DW	5*341/10		;Step time
 B077+0000      	DW	0			;Reserved for future use, must be zero
 B079+0000      	DW	0			;Reserved for future use, must be zero
 B07B+FF01      	DW	15*341/10		;Head settle time
                	DCONF	40,  5, 15		;Drive 2
 B07D+28        	DB	40			;Number of tracks
 B07E+00        	DB	0			;Reset the calibrated flag
 B07F+AA00      	DW	5*341/10		;Step time
 B081+0000      	DW	0			;Reserved for future use, must be zero
 B083+0000      	DW	0			;Reserved for future use, must be zero
 B085+FF01      	DW	15*341/10		;Head settle time
                	DCONF	40,  5, 15		;Drive 3
 B087+28        	DB	40			;Number of tracks
 B088+00        	DB	0			;Reset the calibrated flag
 B089+AA00      	DW	5*341/10		;Step time
 B08B+0000      	DW	0			;Reserved for future use, must be zero
 B08D+0000      	DW	0			;Reserved for future use, must be zero
 B08F+FF01      	DW	15*341/10		;Head settle time
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#035	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;DJDMA equates
                ;=============
                ;
                ;Define DJDMA i/o ports and default channel address
                ;--------------------------------------------------
                ;
 0050 =         DMCHAN	EQU	50H		;Default channel address
 00EF =         DMKICK	EQU	0EFH		;Kick I/O port address
 003E =         SERIN	EQU	03EH		;Address of serial input data
                ;Define the channel commands
                ;---------------------------
                ;
 0020 =         DMRSEC	EQU	20H		;Read sector command
 0021 =         DMWSEC	EQU	21H		;Write a sector command
 0022 =         DMSTAC	EQU	22H		;Get drive status
 0023 =         DMSDMA	EQU	23H		;Set DMA address
 0024 =         INTRQC	EQU	24H		;Set Interrupt request
 0025 =         DMHALT	EQU	25H		;Halt command
 0026 =         BRACHA	EQU	26H		;Channel branch
 0027 =         SETCHA	EQU	27H		;Set channel address
 0028 =         DMSERR	EQU	28H		;Set CRC retry count
 0029 =         RDTRCK	EQU	29H		;Read track command
 002A =         WRTRCK	EQU	2AH		;Write track command
 002B =         SEROUT	EQU	2BH		;Serial character ouput
 002C =         SENABL	EQU	2CH		;Enable/disable serial input
 002D =         TRKSIZ	EQU	2DH		;Set number of tracks
 002E =         DMSETL	EQU	2EH		;Set logical drives
 00A0 =         READM	EQU	0A0H		;Read from controller memory
 00A1 =         WRITEM	EQU	0A1H		;Write to controller memory
                ;Define stepping rate equates
                ;----------------------------
                ;
 0066 =         DMFSTE	EQU	3*341/10	;SA851 stepping rate constant
 01FF =         DMFSET	EQU	15*341/10	;SA851 settling rate constant
                ;Define Internal status byte fields
                ;----------------------------------
                ;
 0040 =         DMS$T0	EQU	01000000B	;Track 0 status mask  (1 = on trk 0)
 0020 =         DMS$DD	EQU	00100000B	;Double density mask  (1 = double)
 0010 =         DMS$WR	EQU	00010000B	;Double sided track wrap  (1 = wrap)
 0008 =         DMS$DS	EQU	00001000B	;Double sided status mask  (1 = double)
 0004 =         DMS$HS	EQU	00000100B	;Hard sectored status mask  (1 = hard)
 0003 =         DMS$SS	EQU	00000011B	;Sector size code mask ...
                				;... 0 = 128, 1 = 256, 2 = 512, 3 = 1024
                ;Define North Star status byte fields
                ;------------------------------------
                ;
 0080 =         DMN$DD	EQU	10000000B	;Double density mask
 0040 =         DMN$DS	EQU	01000000B	;Double sided mask
 0020 =         DMN$2X	EQU	00100000B	;CP/M version 2.x mask
 0010 =         DMN$OK	EQU	00010000B	;Validation mask
 0008 =         DMN$40	EQU	00001000B	;40/80 track mask
 0004 =         DMN$DT	EQU	00000100B	;Double track density mask
 0003 =         DMN$XX	EQU	00000011B	;RFU mask
                ;Common Subroutines
CP/M MACRO ASSEM 2.0	#036	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;------------------
                ; Return a pointer to the current drives drive parameter entry
                ;-------------------------------------------------------------
                ;
 B091 2ABEB5    DMDPAR:	LHLD	DMDRIV			;Get the current drive number
 B094 2600      	MVI	H,0			;Drive number is a byte
 B096 29        	DAD	H			;Ten bytes per parameter table entry
 B097 54        	MOV	D,H
 B098 5D        	MOV	E,L
 B099 29        	DAD	H
 B09A 29        	DAD	H
 B09B 19        	DAD	D
 B09C 1141B0    	LXI	D,DPARAM		;Parameter table address
 B09F 19        	DAD	D
 B0A0 C9        	RET
                	PAGE
CP/M MACRO ASSEM 2.0	#037	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	MAXDM NE 0	;Start 8" drive's unique code section
                ;====================================================================	
                ;Device Specification Table for DJDMA controller with 8" drives
                ;==============================================================
                ;
 B0A1 02        DMDST:	DB	MAXDM			;Number of logical drives
 B0A2 B8B0      	DW	DMWARM			;Warm boot
 B0A4 26B1      	DW	DMTRAN			;Sector translation
 B0A6 42B1      	DW	DMLDR1			;Select drive 1
 B0A8 CDB1      	DW	DMLDR2			;Select drive 2
 B0AA F1B4      	DW	DMHOME			;Home drive
 B0AC FBB4      	DW	DMSEEK			;Seek to specified track
 B0AE 00B5      	DW	DMSEC			;Set sector
 B0B0 06B5      	DW	DMDMA			;Set DMA address
 B0B2 0CB5      	DW	DMREAD			;Read a sector
 B0B4 11B5      	DW	DMWRIT			;Write a sector
 B0B6 14B0      	DW	NOBAD			;No bad sector map
                	IF	DMORDER NE 1		;no warm boot possible
                ;DJDMA 8" warm boot dummy
                ;------------------------
                ;	1) If 8" DJDMA is not drive A (i.e. dmorder not equal 1) then
                ;	   it is not possible to warm boot from 8". So routine not needed.
                ;
                DMWARM:	RET				;return if called
                	ELSE
                ;DJDMA 8" warm boot loader
                ;-------------------------
                ;	1) This loader loads from the start of the CCP (track 0 sector 5)
                ;	   to the end of the BDOS (track 1 sector 3).  Only 768 (3/4k) bytes
                ;	   of track 1 sector 3 is read in since the warm boot routine is
                ;	   not allowed to load any the CBIOS code.
                ;	2) Sector 3 is read into the disk buffer and copied into its proper
                ;	   resting place.
                ;
 0B00 =         DMCOD8	EQU	22*128			;Amount of code on track 0 to load
 B0B8 CDE3B4    DMWARM:	CALL	DMSEL2			;Select drive 0
 B0BB 21E1B0    DMWBAD:	LXI	H,DMWCHN		;Warm boot command channel
 B0BE 112200    	LXI	D,DMWOFF
 B0C1 CD8AB5    	CALL	DMCMD			;Execute the channel
 B0C4 C2BBB0    	JNZ	DMWBAD			;Retry
 B0C7 3AECB0    	LDA	DMWST0			;Get track read status
 B0CA 2AF8B0    	LHLD	DMWST1			;Track ones status in L
 B0CD B5        	ORA	L
 B0CE FE40      	CPI	40H
 B0D0 C2BBB0    	JNZ	DMWBAD			;Loop on 'terrible' errors like no disk
 B0D3 010003    	LXI	B,300H			;Move .75 Kbytes of sector 3
 B0D6 110EB8    	LXI	D,BUFFER		;Sector 3 is in our buffer
 B0D9 2100AA    	LXI	H,CCP+1300H		;  and this is where we want it to go
 B0DC CDD5AF    	CALL	MOVBYT
 B0DF AF        	XRA	A
 B0E0 C9        	RET
 B0E1 23        DMWCHN:	DB	DMSDMA			;Set track 0 DMA address
 B0E2 0095      	DW	CCP-512			;First track DMA address - boot loader
 B0E4 00        	DB	0
 B0E5 29        	DB	RDTRCK			;Read track command
CP/M MACRO ASSEM 2.0	#038	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B0E6 00        	DB	0			;Track 0
 B0E7 00        	DB	0			;Side 0
 B0E8 00        	DB	0			;Drive 0
 B0E9 04B1      	DW	DMWMAP			;Sector load/status map
 B0EB 00        	DB	0
 B0EC 00        DMWST0:	DB	0			;Track read status
 B0ED 23        	DB	DMSDMA
 B0EE 00A2      	DW	CCP+DMCOD8		;DMA address for track 1
 B0F0 00        	DB	0
 B0F1 29        	DB	RDTRCK
 B0F2 01        	DB	1			;Track 1
 B0F3 00        	DB	0			;Side 0
 B0F4 00        	DB	0			;Drive 0
 B0F5 1EB1      	DW	DMWMAP+26		;Load map right after track 0 map
 B0F7 00        	DB	0
 B0F8 00        DMWST1:	DB	0			;Track read status
 B0F9 23        	DB	DMSDMA
 B0FA 0EB8      	DW	BUFFER			;Sector 3 gets loaded in system buffer
 B0FC 00        	DB	0
 B0FD 20        	DB	DMRSEC
 B0FE 01        	DB	1			;Track 1
 B0FF 03        	DB	3			;Side 0, sector 3
 B100 00        	DB	0			;Drive 0
 B101 00        	DB	0			;Read status
 B102 25        	DB	DMHALT			;Controller halt command
 B103 00        	DB	0
 0022 =         DMWOFF	EQU	$-DMWCHN-1		;Halt offset for the command channel
 B104 FFFFFFFF00DMWMAP:	DW	-1, -1, 0, 0, 0, 0, 0	;Do not load the boot loader
 B112 0000000000	DW	0, 0, 0, 0, 0, 0
 B11E 0000FFFFFF	DW	0, -1, -1, -1		;First 2 sectors on track 2
                	ENDIF				;end of 8" DJDMA warm boot
                ;DJDMA 8" sector translation
                ;---------------------------
                ;
 B126 03        DMTRAN:	INX	B			;Ajust sectors to start at 1
 B127 3AD4B5    	LDA	DMPSTA			;Test for double sided drives
 B12A E608      	ANI	DMS$DS
 B12C CA3BB1    	JZ	DMTRN0			;Skip if single sided
 B12F 3AFAB1    	LDA	DMCSPT			;Get SPT/2
 B132 91        	SUB	C			;Test for side one sectors
 B133 D23BB1    	JNC	DMTRN0			;Skip sector adjustment if on side zero
 B136 2F        	CMA				;'Knock off' first sides sectors
 B137 3C        	INR	A
 B138 4F        	MOV	C,A
 B139 0680      	MVI	B,80H			;Set side one flag
 B13B 69        DMTRN0:	MOV	L,C			;Make an index to the SECTRAN table
 B13C 2600      	MVI	H,0
 B13E 19        	DAD	D
 B13F 6E        	MOV	L,M			;Load the translated sector
 B140 60        	MOV	H,B			;Set the side bit
 B141 C9        	RET
                ;DJDMA 8" drive select 1
                ;-----------------------
                ;	1) Determine the sector size and the number of sides on the drive.
                ;	2) Return correct DPH.
                ;
CP/M MACRO ASSEM 2.0	#039	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B142 CDE3B4    DMLDR1:	CALL	DMSEL2			;Do logical select	
 B145 CDBCB4    	CALL	DMINIT			;Test for a controller
 B148 DAF8AF    	JC	ZRET			;Skip if no controller present
 B14B CD63B5    	CALL	DMSTAT			;Accm:= Djdma_returned_Drive_Status
 B14E DAF8AF    	JC	ZRET			;Skip on status check error
 B151 F5        	PUSH	PSW
 B152 E640      	ANI	DMS$T0			;Check for track 0
 B154 CA7CB1    	JZ	DMLDR0			;Skip if not on track 0 (status valid)
 B157 F1        	POP	PSW			;Clean stack
 B158 210100    	LXI	H,1			;read sector 1 ...
 B15B 2238B7    	SHLD	TRUESEC
 B15E 23        	INX	H			;... of track 2
 B15F 2236B7    	SHLD	CPMTRK			;because track 1 always single density
 B162 AF        	XRA	A
 B163 32F8AE    	STA	RDWR			;force read to get valid drive status
 B166 CD21AF    	CALL	FILL			;flush buffer and read
 B169 DAF8AF    	JC	ZRET			;exit with error if error
 B16C CD91B0    	CALL	DMDPAR			;Get the drive parameter address
 B16F 23        	INX	H
 B170 3600      	MVI	M,0			;Decalibrate the drive
 B172 CD23B5    	CALL	DMPARM
 B175 CD63B5    	CALL	DMSTAT			;Accm:= Djdma_returned_Drive_Status
 B178 DAF8AF    	JC	ZRET			;If (error eq true) goto error_return
 B17B F5        	PUSH	PSW
 B17C F1        DMLDR0:	POP	PSW			;Get drive status
 B17D 32D4B5    	STA	DMPSTA			;Set the physical status mode
 B180 CD80B5    	CALL	DMSPTR			;Save status in status table
 B183 77        	MOV	M,A
 B184 E603      	ANI	DMS$SS			;Mask in sector size bits
 B186 07        	RLC				;Make a word index
 B187 F5        	PUSH	PSW			;Used to select a DPB
 B188 5F        	MOV	E,A
 B189 1600      	MVI	D,0
 B18B 21DDB5    	LXI	H,XLTS			;Table of XLT table pointers
 B18E 19        	DAD	D
 B18F E5        	PUSH	H			;Save pointer to proper XLT
 B190 CDC3B1    	CALL	DMGDPH			;Get a pointer to the drives DPH
 B193 D1        	POP	D			;Copy XLT pointer from table to DPH
 B194 010200    	LXI	B,2
 B197 CDD5AF    	CALL	MOVBYT
 B19A 110800    	LXI	D,8			;Offset to DPB pointer
 B19D 19        	DAD	D
 B19E E5        	PUSH	H
 B19F 3AD4B5    	LDA	DMPSTA			;Test for a double sided drive
 B1A2 E608      	ANI	DMS$DS
 B1A4 11B3B6    	LXI	D,DPB128S		;Base for single sided DPB's
 B1A7 CAB0B1    	JZ	DMSOK
 B1AA CDE1B1    	CALL	DMFSTP			;Set controller to fast steping mode
 B1AD 11F3B6    	LXI	D,DPB128D		;Base of double sided DPB's
 B1B0 EB        DMSOK:	XCHG
 B1B1 F1        	POP	PSW			;Restore DPH pointed to DPB
 B1B2 F1        	POP	PSW			;Offset to correct DPB (sector size)
 B1B3 07        	RLC				;Times   4
 B1B4 07        	RLC				;	 8
 B1B5 07        	RLC				;	16 bytes per DPB
 B1B6 4F        	MOV	C,A			;Offset to the correct DPB
CP/M MACRO ASSEM 2.0	#040	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B1B7 0600      	MVI	B,0
 B1B9 09        	DAD	B
 B1BA EB        	XCHG				;Load the DPB pointer in the DPH
 B1BB 73        	MOV	M,E
 B1BC 23        	INX	H
 B1BD 72        	MOV	M,D
 B1BE 210F00    	LXI	H,15			;Offset to the sector size code
 B1C1 19        	DAD	D
 B1C2 4E        	MOV	C,M
 B1C3 3ABEB5    DMGDPH:	LDA	DMDRIV			;Get the DPH pointer
 B1C6 11FBB1    	LXI	D,DPHDM0
 B1C9 CD18B0    	CALL	RETDPH
 B1CC C9        	RET
                ;DJDMA 8in drive select 2
                ;-----------------------
                ;	1) Figure number of sectors_per_track for SECTRAN.							;
                ;
 B1CD CDE3B4    DMLDR2:	CALL	DMSEL2			;Perform logical drive select
 B1D0 CDC3B1    	CALL	DMGDPH			;Load the DPH pointer
 B1D3 110A00    	LXI	D,10			;Offset to the DPB pointer
 B1D6 19        	DAD	D
 B1D7 7E        	MOV	A,M			;Load the DPB pointer
 B1D8 23        	INX	H
 B1D9 66        	MOV	H,M
 B1DA 6F        	MOV	L,A
 B1DB 7E        	MOV	A,M			;Load the number of CP/M sectors/track
 B1DC 0F        	RRC				;Divide by two
 B1DD 32FAB1    	STA	DMCSPT			;Save CPM SPT
 B1E0 C9        	RET
                ;Set the drive's step rate to 3ms
                ;--------------------------------
                ;	1) The current drive is double sided  Thus it is safe to set the
                ;	   stepping rate to 3 ms with 10 ms settling.
                ;
 B1E1 CD91B0    DMFSTP:	CALL	DMDPAR			;Get the parameter table pointer
 B1E4 23        	INX	H			;Bump to the drive initialized flag
 B1E5 3600      	MVI	M,0			;Force reparamitization of this drive
 B1E7 23        	INX	H			;Offset to the Stepping rate constant
 B1E8 3666      	MVI	M,(LOW DMFSTE)		;Fast stepping rate constant
 B1EA 23        	INX	H
 B1EB 3600      	MVI	M,(HIGH DMFSTE)
 B1ED 110500    	LXI	D,5			;Skip over the reserved fields
 B1F0 19        	DAD	D
 B1F1 36FF      	MVI	M,(LOW DMFSET)		;Fast settling rate constant
 B1F3 23        	INX	H
 B1F4 3601      	MVI	M,(HIGH DMFSET)
 B1F6 CD23B5    	CALL	DMPARM			;Set drive parameters for the SA850
 B1F9 C9        	RET
                ;DJDMA 8" driver variables
                ;-------------------------
                ;
 B1FA 00        DMCSPT:	DB	0		;CPM sectors per track / 2
                ; 8" Disk parameter headers
                ;--------------------------
                ;
 B1FB 0000      DPHDM0:	DW	0		;translation table address
CP/M MACRO ASSEM 2.0	#041	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B1FD 0000      	DW	0
 B1FF 0000      	DW	0
 B201 0000      	DW	0
 B203 18BC      	DW	DIRBUF		;directory buffer
 B205 0000      	DW	0		;pointer to disk parameter block
 B207 98BC      	DW	CSVDM0		;scratch pad area for checking changed disks
 B209 D8BC      	DW	ALVDM0		;scratch pad for allocation information
 B20B 0000      DPHDM1:	DW	0		;translation table address
 B20D 0000      	DW	0
 B20F 0000      	DW	0
 B211 0000      	DW	0
 B213 18BC      	DW	DIRBUF		;directory buffer
 B215 0000      	DW	0		;pointer to disk parameter block
 B217 23BD      	DW	CSVDM1		;scratch pad area for checking changed disks
 B219 63BD      	DW	ALVDM1		;scratch pad for allocation information
 B21B 0000      DPHDM2:	DW	0		;translation table address
 B21D 0000      	DW	0
 B21F 0000      	DW	0
 B221 0000      	DW	0
 B223 18BC      	DW	DIRBUF		;directory buffer
 B225 0000      	DW	0		;pointer to disk parameter block
 B227 AEBD      	DW	CSVDM2		;scratch pad area for checking changed disks
 B229 EEBD      	DW	ALVDM2		;scratch pad for allocation information
 B22B 0000      DPHDM3:	DW	0		;translation table address
 B22D 0000      	DW	0
 B22F 0000      	DW	0
 B231 0000      	DW	0
 B233 18BC      	DW	DIRBUF		;directory buffer
 B235 0000      	DW	0		;pointer to disk parameter block
 B237 39BE      	DW	CSVDM3		;scratch pad area for checking changed disks
 B239 79BE      	DW	ALVDM3		;scratch pad for allocation information
                	ENDIF			;End of 8" drive's unique code
                	PAGE
CP/M MACRO ASSEM 2.0	#042	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	MAXMF NE 0	;Start of 5" drive's unique code section
                ;=======================================================================
                ;Drive specification table for DJDMA 5.25" drives
                ;================================================
                ;
 B23B 02        MFDST:	DB	MAXMF			;Number of logical drives
 B23C 52B2      	DW	MFWARM			;Warm boot
 B23E 53B2      	DW	MFTRAN			;Sector translation
 B240 71B2      	DW	MFLDR1			;Select drive 1
 B242 31B3      	DW	MFSEL2			;Select drive 2
 B244 F1B4      	DW	DMHOME			;Home drive
 B246 36B3      	DW	MFSEEK			;Seek to specified track
 B248 75B3      	DW	MFSSEC			;Set sector
 B24A 06B5      	DW	DMDMA			;Set DMA address
 B24C 81B3      	DW	MFREAD			;Read a sector
 B24E 87B3      	DW	MFWRIT			;Write a sector
 B250 14B0      	DW	NOBAD			;No bad sector map
                	IF	MFORDER NE 1		;no warm boot possible
                ;DJDMA 5.25" warm boot dummy
                ;---------------------------
                ;	1) If 5.25" DJDMA is not drive A (i.e. mforder not equal 1) then
                ;	   it is not possible to warm boot from 5.25". So routine not needed.
                ;
 B252 C9        MFWARM:	RET				;return if called
                	ELSE
                ;DJDMA 5.25" warm boot loader
                ;----------------------------
                ;	1) Load from the start of the CCP (track 0 sector 1) to the end
                ;	   of the BDOS (track 1 sector 1).
                MFTRCK	EQU	9*512			;Amount of code on track 0
                MFWARM:	CALL	MFSEL2			;Select drive 0
                MFWBAD:	LXI	H,MFWCHN		;Warm boot command channel
                	LXI	D,MFWLEN
                	CALL	DMCMD
                	JNZ	MFWBAD			;Loop on 'bad' errors
                	LDA	MFWST0
                	CPI	40H
                	JNZ	MFWBAD
                	XRA	A			;Return no error
                	RET
                MFWCHN:	DB	DMSDMA			;Set track 0 DMA address
                	DW	CCP-512			;First track DMA address - boot loader
                	DB	0
                	DB	RDTRCK			;Read track command
                	DB	0			;Track 0
                	DB	0			;Side 0
                	DB	4			;mini Drive 0
                	DW	MFWSEC			;Sector load/status map
                	DB	0
                MFWST0:	DB	0			;Track read status
                	DB	DMSDMA
                	DW	CCP+MFTRCK		;DMA address for track 1
                	DB	0
                	DB	RDTRCK
                	DB	1			;Track 1
CP/M MACRO ASSEM 2.0	#043	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	DB	0			;Side 0
                	DB	4			;mini Drive 0
                	DW	MFWSEC+10		;Load map right after track 0 map
                	DB	0
                	DB	0			;Track read status
                	DB	DMHALT
                	DB	0
                MFWLEN	EQU	$-MFWCHN-1		;Channel length
                MFWSEC:	DW	0FFH, 0, 0, 0, 0	;Do not load boot loader
                	DW	0, -1, -1, -1, -1	;first two sectors loaded
                	ENDIF				;DJDMA 5.25" warm boot routine
                ;DJDMA 5.25" sector translation
                ;------------------------------
                ;
 B253 3AD4B5    MFTRAN:	LDA	DMPSTA			;Test for soft sectored media
 B256 E604      	ANI	DMS$HS
 B258 21F3B3    	LXI	H,MFXLT1		;Soft sectored SECTRAN table
 B25B CA6CB2    	JZ	MFTRN
 B25E 3AD4B5    	LDA	DMPSTA			;Test disk density
 B261 E620      	ANI	DMS$DD
 B263 21CBB3    	LXI	H,MFXLTD		;Double density SECTRAN table
 B266 C26CB2    	JNZ	MFTRN
 B269 21B7B3    	LXI	H,MFXLTS		;Single density SECTRAN table
 B26C 09        MFTRN:	DAD	B
 B26D 6E        	MOV	L,M			;Load physical sector number
 B26E 2600      	MVI	H,0
 B270 C9        	RET
                ;DJDMA 5.25" first time select
                ;-----------------------------
                ;	1) This routine inpectes the disk. If the disk is hard sectored
                ;	   the the North Star configuration byte is read from track 0,
                ;	   sector 0 byte 5c.  If the media is soft sectored the the
                ;	   Morrow Designs Micro Decision format is assumed.
                ;
 B271 CD31B3    MFLDR1:	CALL	MFSEL2			;Do logical drive select
 B274 CDBCB4    	CALL	DMINIT			;Test for a controller
 B277 DAF8AF    	JC	ZRET
 B27A CD63B5    	CALL	DMSTAT			;Get the drive status byte
 B27D DAF8AF    	JC	ZRET			;Error exit if status not good
 B280 32D4B5    	STA	DMPSTA
 B283 CD80B5    	CALL	DMSPTR			;Save in the status table
 B286 77        	MOV	M,A
 B287 E604      	ANI	DMS$HS			;Test for hard sectored drives
 B289 C2B7B2    	JNZ	MFLD0			;Skip to hard sectored logger
 B28C CD04B3    	CALL	MFRDS1			;get sector 1 of track 0
 B28F 21A7B8    	LXI	H,BUFFER+80H+25		;longitudinal parity check the data
 B292 0619      	MVI	B,25			;number of bytes to check
 B294 AF        	XRA	A			;init long parity
 B295 5F        	MOV	E,A			;0-check byte
 B296 2B        MFCKL:	DCX	H			;next byte to check
 B297 AE        	XRA	M			;get long parity
 B298 57        	MOV	D,A			;save parity
 B299 B3        	ORA	E			;catch any 1 bits in 0-check byte
 B29A 5F        	MOV	E,A			;save 0-check
 B29B 7A        	MOV	A,D			;get parity again
 B29C 05        	DCR	B
CP/M MACRO ASSEM 2.0	#044	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B29D C296B2    	JNZ	MFCKL			;loop for whole table
 B2A0 B7        	ORA	A			;tests parity (should be 0 for valid)
 B2A1 C2B2B2    	JNZ	MFSFT			;assume single side if bad table
 B2A4 B3        	ORA	E			;test 0-check (should not be all 0)
 B2A5 CAB2B2    	JZ	MFSFT			;assume single side in all 0 table
 B2A8 3A8FB8    	LDA	BUFFER+81H		;get Morrow soft sector config byte
 B2AB E604      	ANI	4			;check double sided indicator
 B2AD 3EA9      	MVI	A,0A9H			;double sided config byte
 B2AF C2BDB2    	JNZ	MFLD1			;skip if double sided
 B2B2 3EA1      MFSFT:	MVI	A,0A1H			;Morrow Soft sectored floppy
 B2B4 C3BDB2    	JMP	MFLD1
 B2B7 CD04B3    MFLD0:	CALL	MFRDS1			;get sector 1 of track 0
 B2BA 3A6AB8    	LDA	BUFFER+5CH		;Get the North Star configuration byte
 B2BD B7        MFLD1:	ORA	A			;Old CP/M 1.4 systems did not have a
 B2BE CC1AB3    	CZ	MFLCL			;   configuration byte.  This routine
 B2C1 FEE5      	CPI	0E5H			;   will make a configuration byte for
 B2C3 CC1AB3    	CZ	MFLCL			;   these systems.
 B2C6 4F        	MOV	C,A
 B2C7 2196B3    	LXI	H,MFS			;Pointer to configuration table
 B2CA 7E        MFLD2:	MOV	A,M			;Get an entry
 B2CB B7        	ORA	A			;Check for end of the table
 B2CC CAF8AF    	JZ	ZRET			;Yes, select error
 B2CF B9        	CMP	C			;Check if entry matches selected drive
 B2D0 CADAB2    	JZ	MFLD3			;Match, get entry
 B2D3 23        	INX	H			;Skip to the next entry
 B2D4 23        	INX	H
 B2D5 23        	INX	H
 B2D6 23        	INX	H
 B2D7 C3CAB2    	JMP	MFLD2
 B2DA 23        MFLD3:	INX	H			;Bump to the true configuration byte
 B2DB 3AD4B5    	LDA	DMPSTA			;Get the physical status
 B2DE B6        	ORA	M			;Fill in the fields the hardware can't
 B2DF 32D4B5    	STA	DMPSTA			;   figure out
 B2E2 E5        	PUSH	H
 B2E3 CD80B5    	CALL	DMSPTR			;Load the status byte into the table
 B2E6 77        	MOV	M,A
 B2E7 E1        	POP	H
 B2E8 23        	INX	H			;Bump to the DPB pointer
 B2E9 7E        	MOV	A,M			;Load the DPB pointer
 B2EA 23        	INX	H
 B2EB 66        	MOV	H,M
 B2EC 6F        	MOV	L,A
 B2ED E5        	PUSH	H			;Save DPB address
 B2EE CD25B3    	CALL	MFGDPH			;Get a DPH pointer
 B2F1 110A00    	LXI	D,10			;Offset to DPB address in DPH
 B2F4 19        	DAD	D
 B2F5 D1        	POP	D
 B2F6 73        	MOV	M,E			;Store DPB address in DPH
 B2F7 23        	INX	H
 B2F8 72        	MOV	M,D
 B2F9 CD25B3    	CALL	MFGDPH			;Get the DPH pointer
 B2FC 3AD4B5    	LDA	DMPSTA			;Get physical status
 B2FF E603      	ANI	DMS$SS			;Mask sector size field
 B301 3C        	INR	A			;Make CBIOS sector size code
 B302 4F        	MOV	C,A
 B303 C9        	RET
CP/M MACRO ASSEM 2.0	#045	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;
                ; routine called by first time select to read sector 1 track 0
                ; for disk configuration byte checks for hard/soft sectored
                ; minifloppies.
                ;
 B304 210100    MFRDS1:	LXI	H,1			;Select sector 1 of track 0
 B307 2238B7    	SHLD	TRUESEC
 B30A 2B        	DCX	H
 B30B 2236B7    	SHLD	CPMTRK
 B30E AF        	XRA	A			;Make sure we are doing a read
 B30F 32F8AE    	STA	RDWR
 B312 CD21AF    	CALL	FILL			;Flush buffer and refill
 B315 D0        	RNC				;return if no error
 B316 E1        	POP	H			;flush return address
 B317 C3F8AF    	JMP	ZRET			;do error return
                ; Get the configuration byte for a North Star Disk
                ;-------------------------------------------------
                ;	1) This routine is only used by MFLDR1: (mini-floppy first time
                ;	   select
                ;	2) North Star configuration byte value is 0 or an E5.  Check
                ;	   physical disk density and generate correct configuration byte
                ;	   value.
                ;
 B31A 3AD4B5    MFLCL:	LDA	DMPSTA			;Get physical status
 B31D E620      	ANI	DMS$DD			;Test the double density bit
 B31F 3E10      	MVI	A,10H			;CP/M 1.4 single density configuration
 B321 C8        	RZ
 B322 3E90      	MVI	A,90H			;CP/M 1.4 double density configuration
 B324 C9        	RET
                ; Return a pointer to the current drives DPH
                ;-------------------------------------------									;
                ;	1) This routine is only used by MFLDR1: (mini-floppy first time
                ;	   select
                ;
 B325 3ABEB5    MFGDPH:	LDA	DMDRIV			;Get the current drive
 B328 D604      	SUI	4			;5.25 drives start at drive 4
 B32A 111CB4    	LXI	D,DPHMF0
 B32D CD18B0    	CALL	RETDPH
 B330 C9        	RET
                ;Select drive #2
                ;---------------
                ;	1) This driver configures the 5 1/4" drives as drives 4 to 7.						;
                ;
 B331 C604      MFSEL2:	ADI	4			;5.25" drives are drives 4-7
 B333 C3E3B4    	JMP	DMSEL2
                ;Set track
                ;---------
                ;	1) North Star implements double sided drives by doubling
                ;	   the number of tracks to 70.  Tracks 0 to 34 are on side 0 like a
                ;	   single sided floppy.  Tracks 35 to 69 are on side 1 in reverse
                ;	   (e.g. Track 35 is on track 34 side 1 and track 69 is on track 0
                ;	   side 1).
                ;
 B336 AF        MFSEEK:	XRA	A			;Clear double sided select flag
 B337 321BB4    	STA	MFSID1
 B33A 21D4B5    	LXI	H,DMPSTA		;Get the drive status
CP/M MACRO ASSEM 2.0	#046	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B33D 7E        	MOV	A,M
 B33E E604      	ANI	DMS$HS			;Test for hard sectored drives
 B340 CA61B3    	JZ	DMSOFT			;Skip if soft sectored
 B343 7E        	MOV	A,M			;Test for double sided drives
 B344 E608      	ANI	DMS$DS
 B346 CAFBB4    	JZ	DMSEEK			;Skip if single sided
 B349 7E        	MOV	A,M			;Test for track wrap mode
 B34A E610      	ANI	DMS$WR
 B34C CAFBB4    	JZ	DMSEEK			;Skip if not wrapping
 B34F 79        	MOV	A,C			;Test for tracks 35-69
 B350 FE23      	CPI	35
 B352 DAFBB4    	JC	DMSEEK			;Skip if less than track 35
 B355 3E45      	MVI	A,69			;Adjust tracks 35 -> 69 to 34 -> 0
 B357 91        	SUB	C
 B358 4F        	MOV	C,A
 B359 3E80      	MVI	A,080H			;Set side one flag
 B35B 321BB4    	STA	MFSID1
 B35E C3FBB4    	JMP	DMSEEK
 B361 7E        DMSOFT:	MOV	A,M			;get drive status again
 B362 E608      	ANI	DMS$DS			;check for double sided (cy = 0)
 B364 CAFBB4    	JZ	DMSEEK			;skip if not double sided
 B367 79        	MOV	A,C			;get track number
 B368 1F        	RAR				;divide by 2 for Morrow soft sectored
 B369 4F        	MOV	C,A
 B36A D2FBB4    	JNC	DMSEEK			;skip if on side 1
 B36D 3E80      	MVI	A,80H
 B36F 321BB4    	STA	MFSID1			;else indicate side 2
 B372 C3FBB4    	JMP	DMSEEK
                ;DJDMA 5.25" set sector
                ;----------------------
                ;
 B375 3AD4B5    MFSSEC:	LDA	DMPSTA			;if (drive .eq. soft_sectored)
 B378 E604      	ANI	DMS$HS			;	goto sector save routine
 B37A CA00B5    	JZ	DMSEC			;else
 B37D 0D        	DCR	C			;	adjust for first sect = zero
 B37E C300B5    	JMP	DMSEC
                ;DJDMA 5.25" read/write sector
                ;-----------------------------
                ;
 B381 CD8DB3    MFREAD:	CALL	MFSET			;Set up side flag
 B384 C30CB5    	JMP	DMREAD
 B387 CD8DB3    MFWRIT:	CALL	MFSET			;Set up side flag
 B38A C311B5    	JMP	DMWRIT
 B38D 3A1BB4    MFSET:	LDA	MFSID1			;Get the side flag
 B390 21BDB5    	LXI	H,DMSCTR		;Merge with the sector number
 B393 B6        	ORA	M
 B394 77        	MOV	M,A
 B395 C9        	RET
                ;DJDMA 5.25" driver variables
                ;----------------------------
                ;
                ;Mini-Floppy Configuration/DPB_Lookup table
                ;	1) This table is used by the mini-floppy first time select routine
                ;	   (mfsldr1) and is used to:
                ;		a) validate the drive configuration byte.
                ;		b) fill in the parameters that can't be determined by doing
CP/M MACRO ASSEM 2.0	#047	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;		   sense drive status (like sensing double sided drives).
                ;		c) returning a pointer to the proper DPB for the media.
                ;	2) There are four fields per entry.
                ;		Field_1: Drive configuration byte.
                ;		Field_2: Additional drive parameters that can't be determined
                ;			 by doing a sense drive status (i.e. double_sided and
                ;			 track_wrap).
                ;		Field_3: Pointer to the appropriate DPB
                ;
 B396 10        MFS:	DB	10H			;North Star CP/M 1.4
 B397 00        	DB	0			;Single density, 35 tracks, 1-sided
 B398 5CB4      	DW	DPBMF0			;1K groups
 B39A 90        	DB	90H			;North Star CP/M 1.4
 B39B 00        	DB	0			;Double density, 35 tracks, 1-sided
 B39C 6CB4      	DW	DPBMF1			;1K groups
 B39E B0        	DB	0B0H			;North Star CP/M 2.x
 B39F 00        	DB	0			;Double density, 35 tracks, 1-sided
 B3A0 7CB4      	DW	DPBMF2			;2K groups
 B3A2 F0        	DB	0F0H			;North Star CP/M 2.x
 B3A3 18        	DB	(DMS$DS OR DMS$WR)	;Double density, 35 tracks, 2-sided
 B3A4 8CB4      	DW	DPBMF3			;2K groups
 B3A6 A0        	DB	0A0H			;North Star CP/M 2.x  (fake 40 track)
 B3A7 00        	DB	0			;Double density, 35 tracks, 1-sided
 B3A8 7CB4      	DW	DPBMF2			;2K groups
 B3AA D0        	DB	0D0H			;North Star CP/M 2.x (fake 40 track)
 B3AB 18        	DB	(DMS$DS OR DMS$WR)	;Double density, 35 tracks, 2-sided
 B3AC 8CB4      	DW	DPBMF3			;2K groups
 B3AE A1        	DB	0A1H			;Morrow Designs CP/M 2.x Soft sectored
 B3AF 00        	DB	0			;Double density, 40 tracks, 1-sided
 B3B0 9CB4      	DW	DPBMF4
 B3B2 A9        	DB	0A9H			;Morrow Designs CP/M 2.x Soft sectored
 B3B3 08        	DB	DMS$DS			;Double density, 40 tracks, 2-sided
 B3B4 ACB4      	DW	DPBMF5
 B3B6 00        	DB	0			;End of configuration table
                ; Hard sectored single sided sector translation table
                ;
 B3B7 0102      MFXLTS:	DB	 1,  2
 B3B9 0304      	DB	 3,  4
 B3BB 0506      	DB	 5,  6
 B3BD 0708      	DB	 7,  8
 B3BF 090A      	DB	 9, 10
 B3C1 0B0C      	DB	11, 12
 B3C3 0D0E      	DB	13, 14
 B3C5 0F10      	DB	15, 16
 B3C7 1112      	DB	17, 18
 B3C9 1314      	DB	19, 20
                ; Hard sectored double sided sector translation table
                ;
 B3CB 01020304  MFXLTD:	DB	 1,  2,  3,  4
 B3CF 15161718  	DB	21, 22, 23, 24
 B3D3 05060708  	DB	 5,  6,  7,  8
 B3D7 191A1B1C  	DB	25, 26, 27, 28
 B3DB 090A0B0C  	DB	 9, 10, 11, 12
 B3DF 1D1E1F20  	DB	29, 30, 31, 32
 B3E3 0D0E0F10  	DB	13, 14, 15, 16
 B3E7 21222324  	DB	33, 34, 35, 36
CP/M MACRO ASSEM 2.0	#048	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B3EB 11121314  	DB	17, 18, 19, 20
 B3EF 25262728  	DB	37, 38, 39, 40
                ; Soft sectored single sided translation table
                ;
 B3F3 0102030405MFXLT1:	DB	 1,  2,  3,  4,  5,  6,  7,  8
 B3FB 191A1B1C1D	DB	25, 26, 27, 28, 29, 30, 31, 32
 B403 090A0B0C0D	DB	 9, 10, 11, 12, 13, 14, 15, 16
 B40B 2122232425	DB	33, 34, 35, 36, 37, 38, 39, 40
 B413 1112131415	DB	17, 18, 19, 20, 21, 22, 23, 24
 B41B 00        MFSID1:	DB	0		;On side one flag
                ;disk parameter headers
                ;----------------------
                ;
 B41C 0000      DPHMF0:	DW	0		;translation table address
 B41E 0000      	DW	0
 B420 0000      	DW	0
 B422 0000      	DW	0
 B424 18BC      	DW	DIRBUF		;directory buffer
 B426 5CB4      	DW	DPBMF0		;pointer to disk parameter block
 B428 C4BE      	DW	CSVMF0		;scratch pad area for checking changed disks
 B42A F4BE      	DW	ALVMF0		;scratch pad for allocation information
                ;
 B42C 0000      DPHMF1:	DW	0		;translation table address
 B42E 0000      	DW	0
 B430 0000      	DW	0
 B432 0000      	DW	0
 B434 18BC      	DW	DIRBUF		;directory buffer
 B436 6CB4      	DW	DPBMF1		;pointer to disk parameter block
 B438 0DBF      	DW	CSVMF1		;scratch pad area for checking changed disks
 B43A 3DBF      	DW	ALVMF1		;scratch pad for allocation information
                ;
 B43C 0000      DPHMF2:	DW	0		;translation table address
 B43E 0000      	DW	0
 B440 0000      	DW	0
 B442 0000      	DW	0
 B444 18BC      	DW	DIRBUF		;directory buffer
 B446 7CB4      	DW	DPBMF2		;pointer to disk parameter block
 B448 56BF      	DW	CSVMF2		;scratch pad area for checking changed disks
 B44A 86BF      	DW	ALVMF2		;scratch pad for allocation information
                ;
 B44C 0000      DPHMF3:	DW	0		;translation table address
 B44E 0000      	DW	0
 B450 0000      	DW	0
 B452 0000      	DW	0
 B454 18BC      	DW	DIRBUF		;directory buffer
 B456 8CB4      	DW	DPBMF3		;pointer to disk parameter block
 B458 9FBF      	DW	CSVMF3		;scratch pad area for checking changed disks
 B45A CFBF      	DW	ALVMF3		;scratch pad for allocation information
                ;disk parameter buffers
                ;----------------------
                ;
 B45C 1400      DPBMF0:	DW	20	;SPT
 B45E 03        	DB	3	;BSH
 B45F 07        	DB	7	;BLM
 B460 00        	DB	0	;EXM
 B461 4F00      	DW	79	;DSM
CP/M MACRO ASSEM 2.0	#049	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B463 3F00      	DW	63	;DRM
 B465 C0        	DB	0C0H	;AL0
 B466 00        	DB	0	;AL1
 B467 1000      	DW	16	;CKS
 B469 0300      	DW	3	;OFF
 B46B 02        	DB	2	;SECSIZ
                ;
 B46C 2800      DPBMF1:	DW	40	;SPT
 B46E 03        	DB	3	;BSH
 B46F 07        	DB	7	;BLM
 B470 00        	DB	0	;EXM
 B471 A400      	DW	164	;DSM
 B473 3F00      	DW	63	;DRM
 B475 C0        	DB	0C0H	;AL0
 B476 00        	DB	0	;AL1
 B477 1000      	DW	16	;CKS
 B479 0200      	DW	2	;OFF
 B47B 03        	DB	3	;SECSIZ
                ;
 B47C 2800      DPBMF2:	DW	40	;SPT
 B47E 04        	DB	4	;BSH
 B47F 0F        	DB	15	;BLM
 B480 01        	DB	1	;EXM
 B481 5100      	DW	81	;DSM
 B483 3F00      	DW	63	;DRM
 B485 80        	DB	080H	;AL0
 B486 00        	DB	0	;AL1
 B487 1000      	DW	16	;CKS
 B489 0200      	DW	2	;OFF
 B48B 03        	DB	3	;SECSIZ
                ;
 B48C 2800      DPBMF3:	DW	40	;SPT
 B48E 04        	DB	4	;BSH
 B48F 0F        	DB	15	;BLM
 B490 01        	DB	1	;EXM
 B491 A900      	DW	169	;DSM
 B493 3F00      	DW	63	;DRM
 B495 80        	DB	080H	;AL0
 B496 00        	DB	0	;AL1
 B497 1000      	DW	16	;CKS
 B499 0200      	DW	2	;OFF
 B49B 03        	DB	3	;SECSIZ
                ;
 B49C 2800      DPBMF4:	DW	40	;SPT
 B49E 04        	DB	4	;BSH
 B49F 0F        	DB	15	;BLM
 B4A0 01        	DB	1	;EXM
 B4A1 5E00      	DW	94	;DSM
 B4A3 7F00      	DW	127	;DRM
 B4A5 C0        	DB	0C0H	;AL0
 B4A6 00        	DB	0	;AL1
 B4A7 2000      	DW	32	;CKS
 B4A9 0200      	DW	2	;OFF
 B4AB 04        	DB	4	;SECSIZ
 B4AC 2800      DPBMF5:	DW	40	;SPT
 B4AE 04        	DB	4	;BSH
CP/M MACRO ASSEM 2.0	#050	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B4AF 0F        	DB	15	;BLM
 B4B0 01        	DB	1	;EXM
 B4B1 C200      	DW	194	;DSM
 B4B3 BF00      	DW	191	;DRM
 B4B5 E0        	DB	0E0H	;AL0
 B4B6 00        	DB	0	;AL1
 B4B7 3000      	DW	48	;CKS
 B4B9 0200      	DW	2	;OFF
 B4BB 04        	DB	4	;SECSIZ
                	PAGE
CP/M MACRO ASSEM 2.0	#051	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	ENDIF			;End of 5" drive's unique code section
                ;=====================================================================
                ;Common routines for the DJDMA with 8 and 5.25" drives
                ;=====================================================
                ;
                ;Set up the disk controller
                ;--------------------------
                ;
 B4BC 215000    DMINIT:	LXI	H,DMCHAN		;See if the controller will halt
 B4BF 3625      	MVI	M,DMHALT
 B4C1 23        	INX	H
 B4C2 3600      	MVI	M,0
 B4C4 D3EF      	OUT	DMKICK			;Start controller
 B4C6 110000    	LXI	D,0			;Set up timeout counter
 B4C9 7E        DMINWT:	MOV	A,M			;Test for status returned
 B4CA B7        	ORA	A
 B4CB C2D6B4    	JNZ	DMIOK			;Controller has responded
 B4CE 1B        	DCX	D			;Bump timeout counter
 B4CF 7A        	MOV	A,D
 B4D0 B3        	ORA	E
 B4D1 C2C9B4    	JNZ	DMINWT
 B4D4 37        	STC				;Set error flag
 B4D5 C9        	RET
 B4D6 CD23B5    DMIOK:	CALL	DMPARM			;Set the drive parameters
 B4D9 21A8B5    	LXI	H,DMSETU		;Set more parameters
 B4DC 110600    	LXI	D,6
 B4DF CD93B5    	CALL	DMDOIT
 B4E2 C9        	RET				;Return no error (C reset)
                ;Drive select two.
                ;-----------------
                ;	1) 8" drives are drives 0-3, 5.25" drives are drives 4-7.
                ;
 B4E3 32BEB5    DMSEL2:	STA	DMDRIV			;Save the drive name
 B4E6 32B0B5    	STA	DMGSTA+1		;(for sense status command)
 B4E9 CD80B5    	CALL	DMSPTR			;Get status pointer
 B4EC 7E        	MOV	A,M
 B4ED 32D4B5    	STA	DMPSTA			;Save current status
 B4F0 C9        	RET
                ;Seek to track 0
                ;---------------
                ;
 B4F1 CD91B0    DMHOME:	CALL	DMDPAR			;Get the drive parameter address
 B4F4 23        	INX	H
 B4F5 3600      	MVI	M,0			;Decalibrate the drive
 B4F7 CD23B5    	CALL	DMPARM
 B4FA C9        	RET
                ;Set track
                ;---------
                ;
 B4FB 79        DMSEEK:	MOV	A,C			;Set up DJDMA track
 B4FC 32BCB5    	STA	DMTRCK
 B4FF C9        	RET
                ;Set sector
                ;----------
                ;
CP/M MACRO ASSEM 2.0	#052	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B500 79        DMSEC:	MOV	A,C			;Set the sector number + side bit
 B501 B0        	ORA	B
 B502 32BDB5    	STA	DMSCTR
 B505 C9        	RET
                ;Set the DMA pointer
                ;-------------------
                ;
 B506 60        DMDMA:	MOV	H,B			;Set the DMA address
 B507 69        	MOV	L,C
 B508 22B8B5    	SHLD	DMCDMA
 B50B C9        	RET
                ;Read/write a sector.
                ;--------------------
                ;	1) Notice that the carry is returned set if there were any
                ;	   errors otherwise it is returned cleared. Also notice that
                ;	   the accm is equal to the djdma returned status (e.g. 40=no_error)
                ;
 B50C 3E20      DMREAD:	MVI	A,DMRSEC		;Read sector command
 B50E C313B5    	JMP	DMSRW
 B511 3E21      DMWRIT:	MVI	A,DMWSEC		;Write sector command
 B513 32BBB5    DMSRW:	STA	DMRWCM			;Set the disk command byte
 B516 21B7B5    	LXI	H,DMRDWR		;Read/write command channel address
 B519 110A00    	LXI	D,10
 B51C CD8AB5    	CALL	DMCMD			;Do the read/write
 B51F 37        	STC				;if (error eq true)
 B520 C0        	RNZ				;	return (carry_set=ERROR)
 B521 3F         	CMC				;else
 B522 C9        	RET				;	return (carry_cleared=NO_ERROR)
                ;Set floppy drive parameters.
                ;----------------------------
                ;	1) This routine inspects the DPARAM table and if the a drive
                ;	   has not been calibrated previously then that drives track
                ;	   count, stepping rate, and head settle time are loaded.
                ;
 B523 3E08      DMPARM:	MVI	A,8			;Eight drives
 B525 114013    	LXI	D,1340H			;Controllers drive parameter address
 B528 2142B0    	LXI	H,DPARAM+1		;CBIOS's drive parameter table
 B52B F5        DMSTR0:	PUSH	PSW			;Save the drive count
 B52C 7E        	MOV	A,M			;Load flags
 B52D B7        	ORA	A			;Does the drive need to be calibrated?
 B52E C253B5    	JNZ	DMSTR1			;No, do not fiddle around
 B531 E5        	PUSH	H			;Save the parameter table pointer
 B532 D5        	PUSH	D			;Save the controllers table pointer
 B533 35        	DCR	M			;Set to calibrated mode (0ffh)
 B534 2B        	DCX	H			;Back up to the track size byte
 B535 22C3B5    	SHLD	DMNTRK			;Set the number of tracks pointer
 B538 23        	INX	H
 B539 23        	INX	H
 B53A 22CBB5    	SHLD	DMSPAR			;Set the stepping constants pointer
 B53D EB        	XCHG				;Set the local parameter table pointer
 B53E 22C8B5    	SHLD	DMLOC0
 B541 23        	INX	H			;Offset to the stepping parameters
 B542 23        	INX	H
 B543 23        	INX	H
 B544 23        	INX	H
 B545 22D0B5    	SHLD	DMLOC1
CP/M MACRO ASSEM 2.0	#053	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B548 21C2B5    	LXI	H,DMWCON		;Write the drive constants out
 B54B 111100    	LXI	D,17			;Halt status offset
 B54E CD93B5    	CALL	DMDOIT
 B551 D1        	POP	D			;Retrieve the table pointers
 B552 E1        	POP	H
 B553 010A00    DMSTR1:	LXI	B,10			;Bump parameter table pointer
 B556 09        	DAD	B
 B557 EB        	XCHG
 B558 011000    	LXI	B,16			;Bump controller tables pointer
 B55B 09        	DAD	B
 B55C EB        	XCHG
 B55D F1        	POP	PSW			;Retrieve drive count
 B55E 3D        	DCR	A			;Bump count
 B55F C22BB5    	JNZ	DMSTR0			;Set up next drive
 B562 C9        	RET
                ;Return the selected drive's status
                ;----------------------------------
                ;	1) The status is returned in the (a) register in the following form:
                ;
                ;  bit=1 if				7  6  5  4  3  2  1  0
                ;  --------				^  ^  ^  ^  ^  ^  ^  ^
                ;		Reserved ---------------+  |  |  |  |  |  |  |
                ;  on track 0	Track zero ----------------+  |  |  |  |  |  |
                ;  dbl dens	Double density ---------------+  |  |  |  |  |
                ;  wrap trk	Track wrap flag -----------------+  |  |  |  |
                ;  2-sided	Double sided media -----------------+  |  |  |
                ;  hard sect	Hard sectored media -------------------+  |  |
                ;		Sector size MSB --------------------------+  |
                ;		Sector size LSB -----------------------------+
                ;		   00 = 128, 01 = 256, 10 = 512, 11 = 1024 bytes.
                ;
                ;	2) 5" drives are always reported as being single sided (because the
                ;	   hardware double sided line is not implemented).
                ;
 B563 21AFB5    DMSTAT:	LXI	H,DMGSTA		;Get controller status command
 B566 110700    	LXI	D,7
 B569 CD8AB5    	CALL	DMCMD
 B56C 37        	STC				;Set the error flag just in case
 B56D C0        	RNZ				;Return on error
                					;76543210 (STATUS REGISTER BITS)
 B56E 3AB1B5    	LDA	DMSTA1			;?????H?? Double density, hard Sectored
 B571 E612      	ANI	00010010B		;---D--H-
 B573 6F        	MOV	L,A			;---D--H-
 B574 3AB3B5    	LDA	DMSTA3			;??0??D?? Track 0, Double sided bits
 B577 E624      	ANI	00100100B		;--0--S--
 B579 B5        	ORA	L			;--0D-SH-
 B57A 07        	RLC				;-0D-SH--
 B57B 21B2B5    	LXI	H,DMSTA2		;-0D-SH--
 B57E B6        	ORA	M			;-0D-SHXX Sector size code
 B57F C9        	RET				;Return no error (C reset)
                ;Return a pointer to the current drives status byte
                ;--------------------------------------------------
                ;
 B580 11D5B5    DMSPTR:	LXI	D,DMSTBL		;Status byte table
 B583 2ABEB5    	LHLD	DMDRIV			;Current drive into L
 B586 2600      	MVI	H,0
CP/M MACRO ASSEM 2.0	#054	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B588 19        	DAD	D
 B589 C9        	RET
                ;Execute a DJDMA command, return command status results
                ;------------------------------------------------------
                ;	1) Enter this routine with:
                ;		DE = offset to the halt status
                ;		HL = pointer to the start of the command
                ;	2) This routine returns:
                ;		 A = command status
                ;		ZF = set on 40 command status value
                ;
 B58A CD93B5    DMCMD:	CALL	DMDOIT			;Do the desired command
 B58D 2B        	DCX	H			;Back up to the command status byte
 B58E 2B        	DCX	H
 B58F 7E        	MOV	A,M			;Load the command status byte
 B590 FE40      	CPI	40H			;Set flags
 B592 C9        	RET
                ;Execute a DJDMA command, no command status is returned
                ;------------------------------------------------------
                ;	1) Enter this routine with:
                ;		DE = offset to the halt status
                ;		HL = pointer to the start of the command
                ;	2) This routine returns no status
                ;
 B593 3E26      DMDOIT:	MVI	A,BRACHA		;Branch channel command
 B595 325000    	STA	DMCHAN
 B598 225100    	SHLD	DMCHAN+1		;Load command vector
 B59B AF        	XRA	A			;Clear extended address
 B59C 325300    	STA	DMCHAN+3
 B59F 19        	DAD	D			;Offset to the halt status
 B5A0 77        	MOV	M,A			;Clear the halt status indicator
 B5A1 D3EF      	OUT	DMKICK			;Start the controller
 B5A3 B6        DMWAIT:	ORA	M			;Wait for the operation complete status
 B5A4 CAA3B5    	JZ	DMWAIT
 B5A7 C9        	RET
                ;DJDMA commmand channel routines
                ;===============================
                ;
                ;Set the logical drive assignments and the retry count
                ;-----------------------------------------------------
                ;
 B5A8 2E        DMSETU:	DB	DMSETL			;Set the logical drive assignments
 B5A9 00        	DB	0			;Drives 0-3 are 8", 4-7 are 5.25"
 B5AA 00        	DB	0			;Old status
 B5AB 28        	DB	DMSERR			;Set the error retry count to 0
 B5AC 01        	DB	1			;One retry (the CBIOS does ten)
 B5AD 25        	DB	DMHALT
 B5AE 00        	DB	0
                ;Get a drive's status
                ;---------------------
                ;
 B5AF 22        DMGSTA:	DB	DMSTAC			;Controller/drive status command
 B5B0 00        	DB	0			;Drive to be sensed
 B5B1 00        DMSTA1:	DB	0			;Status byte 1
 B5B2 00        DMSTA2:	DB	0			;Status byte 2
 B5B3 00        DMSTA3:	DB	0			;Status byte 3
CP/M MACRO ASSEM 2.0	#055	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B5B4 00        	DB	0			;Return status
 B5B5 25        	DB	DMHALT
 B5B6 00        	DB	0
                ;Set the dma address and then do a read or a write
                ;-------------------------------------------------
                ;
 B5B7 23        DMRDWR:	DB	DMSDMA			;Set DMA address command
 B5B8 0000      DMCDMA:	DW	0			;DMA address
 B5BA 00        	DB	0			;X-addr
 B5BB 00        DMRWCM:	DB	0			;Read/write command filled in
 B5BC 00        DMTRCK:	DB	0			;Track
 B5BD 00        DMSCTR:	DB	0			;Sector
 B5BE 00        DMDRIV:	DB	0			;Drive
 B5BF 00        	DB	0			;Status
 B5C0 25        	DB	DMHALT			;Controller halt command
 B5C1 00        	DB	0			;Status
                ;Write a drive's constants into the controller's memory
                ;------------------------------------------------------
                ;
 B5C2 A1        DMWCON:	DB	WRITEM			;Write track size
 B5C3 0000      DMNTRK:	DW	0			;Number of tracks + desync
 B5C5 00        	DB	0			;X-address
 B5C6 0200      	DW	2			;Two bytes
 B5C8 0000      DMLOC0:	DW	0			;Local controller address
 B5CA A1        	DB	WRITEM			;Write stepping rate data
 B5CB 0000      DMSPAR:	DW	0			;Pointer to the stepping parameters
 B5CD 00        	DB	0
 B5CE 0800      	DW	8
 B5D0 0000      DMLOC1:	DW	0
 B5D2 25        	DB	DMHALT			;Controller halt
 B5D3 00        	DB	0			;Status
                ;Driver variables
                ;----------------
                ;
 B5D4 00        DMPSTA:	DB	0			;Physical status for the current drive
 B5D5 0000000000DMSTBL:	DB	0,0,0,0,0,0,0,0		;Physical status bytes for each drive
                	ENDIF				;End of djdma routines
                	PAGE
CP/M MACRO ASSEM 2.0	#056	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	MAXFD NE 0		;Include Discus 2D ?
                ;***********************************************************
                ; Begin the DJ2DB Driver (DDRV2)
                ;*******************************
                ;
                ;DJ2DB equates
                ;-------------
                ;	1) The following equates relate the Morrow Designs 2D/B
                ;	controller. If the controller is non standard (0F800H)
                ;	only the FDORIG equate need be changed.
                ;
                ; --NOTE-- 'fdorig' equate moved to top of source module
                ;fdorig	equ	0xxxxh		;Origin of Disk Jockey PROM
                FDBOOT	EQU	FDORIG+00H	;Disk Jockey 2D initialization
                FDCIN	EQU	FDORIG+03H	;Disk Jockey 2D character input routine
                FDCOUT	EQU	FDORIG+06H	;Disk Jockey 2D character output routine
                FDHOME	EQU	FDORIG+09H	;Disk Jockey 2D track zero seek
                FDSEEK	EQU	FDORIG+0CH	;Disk Jockey 2D track seek routine
                FDSEC	EQU	FDORIG+0FH	;Disk Jockey 2D set sector routine
                FDDMA	EQU	FDORIG+12H	;Disk Jockey 2D set DMA address
                FDREAD	EQU	FDORIG+15H	;Disk Jockey 2D read routine
                FDWRITE	EQU	FDORIG+18H	;Disk Jockey 2D write routine
                FDSEL	EQU	FDORIG+1BH	;Disk Jockey 2D select drive routine
                FDTSTAT	EQU	FDORIG+21H	;Disk Jockey 2D terminal status routine
                FDSTAT	EQU	FDORIG+27H	;Disk Jockey 2D status routine
                FDERR	EQU	FDORIG+2AH	;Disk Jockey 2D error, flash led
                FDDEN	EQU	FDORIG+2DH	;Disk Jockey 2D set density routine
                FDSIDE	EQU	FDORIG+30H	;Disk Jockey 2D set side routine
                FDRAM	EQU	FDORIG+400H	;Disk Jockey 2D RAM address
                DBLSID	EQU	20H		;Side bit from controller
                IO	EQU	FDORIG+3F8H	;Start of I/O registers
                DREG	EQU	IO+1
                CMDREG	EQU	IO+4
                CLRCMD	EQU	0D0H
                ;***************************************************************;
                ;								;
                ; Device Specification Table for the Disk Jockey 2D/B		;
                ;								;
                ;***************************************************************;
                FDDST:	DB	MAXFD		;Number of logical drives
                	DW	FDWARM		;Warm boot
                	DW	FDTRAN		;Sector translation
                	DW	FDLDRV		;Select drive 1
                	DW	FDSEL2		;Select drive 2
                	DW	FDLHOME		;Home drive
                	DW	FDSEEK		;Seek to specified track
                	DW	FDSSEC		;Set sector
                	DW	FDDMA		;Set DMA address
                	DW	FDREAD		;Read a sector
                	DW	FDWRITE		;Write a sector
                	DW	NOBAD		;No bad sector map
                	IF	FDORDER NE 1		;no warm boot possible
                ;DJ2D/B warm boot dummy
                ;---------------------------
                ;	1) If DJ2D/B is not drive A (i.e. fdorder not equal 1) then
CP/M MACRO ASSEM 2.0	#057	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;	   it is not possible to warm boot from DJ2D/B. So routine not needed.
                ;
                FDWARM:	RET				;return if called
                	ELSE
                ; DJ2D/B Floppy disk warm boot loader
                ;------------------------------------
                ;
                FDWARM:	MOV	C,A
                	CALL	FDSEL		;Select drive A
                	MVI	C,0		;Select side 0
                	CALL	FDSIDE
                WRMFAIL:CALL	FDHOME		;Track 0, single density
                	JC	WRMFAIL		;Loop if error
                				;The next block of code re-initializes
                				;   the warm boot loader for track 0
                	MVI	A,5-2		;Initialize the sector to read - 2
                	STA	NEWSEC
                	LXI	H,CCP-100H	;First revolution DMA - 100h
                	SHLD	NEWDMA
                				;Load all of track 0
                T0BOOT:	MVI	A,5-2		;First sector - 2
                NEWSEC	EQU	$-1
                	INR	A		;Update sector #
                	INR	A
                	CPI	27		;Size of track in sectors + 1
                	JC	NOWRAP		;Skip if not at end of track
                	JNZ	T1BOOT		;Done with this track
                	SUI	27-6		;Back up to sector 6
                	LXI	H,CCP-80H	;Memory address of sector - 100h
                	SHLD	NEWDMA
                NOWRAP:	STA	NEWSEC		;Save the updated sector #
                	MOV	C,A
                	CALL	FDSEC		;Set up the sector
                	LXI	H,CCP-100H	;Memory address of sector - 100h
                NEWDMA	EQU	$-2
                	LXI	D,100H		;Update DMA address
                	DAD	D
                NOWRP:	SHLD	NEWDMA		;Save the updated DMA address
                	MOV	B,H
                	MOV	C,L
                	CALL	FDDMA		;Set up the new DMA address
                	LXI	B,RETRIES*100H+0;Maximum # of errors, track #
                WRMFRED:PUSH	B
                	CALL	FDSEEK		;Set up the proper track
                	CALL	FDREAD		;Read the sector
                	POP	B
                	JNC	T0BOOT		;Continue if no error
                	DCR	B
                	JNZ	WRMFRED		;Keep trying if error
                	JMP	FDERR		;Too many errors, flash the light
                ;Load track 1, sector 1, sector 3 (partial), sector 2 (1024 byte sectors)
                T1BOOT:	MVI	C,1		;Track 1
                	CALL	FDSEEK
                	LXI	B,CCP+0B00H	;Address for sector 1
                	LXI	D,10*100H+1	;Retry count + sector 1
                	CALL	WRMREAD
CP/M MACRO ASSEM 2.0	#058	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	LXI	B,CCP+0F00H	;Address for sector 2
                	LXI	D,10*100H+3	;Retry count + sector 3
                	CALL	WRMREAD
                	LXI	B,0300H		;Size of partial sector
                	LXI	D,CCP+1300H	;Address for sector 3
                	LXI	H,CCP+0F00H	;Address of sector 3
                WRMCPY:	MOV	A,M		;Get a byte and
                	STAX	D		;   save it
                	INX	D		;Bump pointers
                	INX	H
                	DCX	B		;Bump counter
                	MOV	A,B		;Check if done
                	ORA	C
                	JNZ	WRMCPY		;   if not, loop
                	LXI	B,CCP+0F00H	;Address for sector 2
                	LXI	D,10*100H+2	;Retry count + sector 2
                	CALL	WRMREAD
                	XRA	A		;Clear error indicator
                	RET
                WRMREAD:PUSH	D
                	CALL	FDDMA		;Set DMA address
                	POP	B
                	CALL	FDSEC		;Set sector
                WRMFRD:	PUSH	B		;Save error count
                	CALL	FDREAD		;Read a sector
                	JC	WRMERR		;Do retry stuff on error
                	CALL	FDSTAT		;Sector size must be 1024 bytes
                	ANI	0CH		;Mask length bits
                	SUI	0CH		;Carry (error) will be set if < 0c0h
                WRMERR:	POP	B		;Fetch retry count
                	RNC			;Return if no error
                	DCR	B		;Bump error count
                	JNZ	WRMFRD
                	JMP	FDERR		;Error, flash the light
                	ENDIF			;end of DJ2D/B warm boot routine
                ;DJ2D/B Sector Translate Routine
                ;-------------------------------
                ;
                FDTRAN:	INX	B
                	PUSH	D		;Save table address
                	PUSH	B		;Save sector #
                	CALL	FDGET		;Get DPH for current drive
                	LXI	D,10		;Load DPH pointer
                	DAD	D
                	MOV	A,M
                	INX	H
                	MOV	H,M
                	MOV	L,A
                	MOV	A,M		;Get # of CP/M sectors/track
                	ORA	A		;Clear carry
                	RAR			;Divide by two
                	SUB	C		;Subtract sector number
                	PUSH	PSW		;Save adjusted sector
                	JM	SIDETWO
                SIDEA:	POP	PSW		;Discard adjusted sector
                	POP	B		;Restore sector requested
CP/M MACRO ASSEM 2.0	#059	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	POP	D		;Restore address of xlt table
                SIDEONE:XCHG			;hl <- &(translation table)
                	DAD	B		;bc = offset into table
                	MOV	L,M		;hl <- physical sector
                	MVI	H,0
                	RET
                SIDETWO:CALL	FDGSID		;Check out number of sides
                	JZ	SIDEA		;Single sided
                	POP	PSW		;Retrieve adjusted sector
                	POP	B
                	CMA			;Make sector request positive
                	INR	A
                	MOV	C,A		;Make new sector the requested sector
                	POP	D
                	CALL	SIDEONE
                	MVI	A,80H		;Side two bit
                	ORA	H		;	and sector
                	MOV	H,A
                	RET
                ;DJ2D/B First Time Drive Select Routine
                ;--------------------------------------
                ;
                FDLDRV:	STA	FDLOG		;Save logical drive
                	MOV	C,A		;Save drive #
                	MVI	A,0		;Have the floppies been accessed yet ?
                FLOPFLG	EQU	$-1
                	ANA	A
                	JNZ	FLOPOK
                	MVI	B,17		;Floppies havn't been accessed
                	LXI	H,FDBOOT	;Check if 2D controller is installed
                	MVI	A,(JMP)
                CLOPP:	CMP	M		;Must have 17 jumps
                	JNZ	ZRET
                	INX	H
                	INX	H
                	INX	H
                	DCR	B
                	JNZ	CLOPP
                	LXI	D,FDINIT	;Initialization sequence
                	LXI	H,FDORIG+7E2H	;Load address
                	LXI	B,30		;Byte count
                	CALL	MOVBYT		;Load controller RAM
                	MVI	A,0FFH		;Start 1791
                	STA	DREG
                	MVI	A,CLRCMD	;1791 reset
                	STA	CMDREG
                	MVI	A,1		;Set 2D initialized flag
                	STA	FLOPFLG
                FLOPOK:	CALL	FLUSH		;Flush buffer since we are using it
                	LDA	FDLOG		;Select new drive
                	MOV	C,A
                	CALL	FDSEL
                	CALL	FDLHOME		;Recalibrate the drive
                	LXI	H,1		;Select sector 1 of track 2
                	SHLD	TRUESEC
                	INX	H
CP/M MACRO ASSEM 2.0	#060	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	SHLD	CPMTRK
                	XRA	A		;Make sure we are doing a read
                	STA	RDWR
                	CALL	FILL		;Fill in buffer with sector
                	JC	ZRET		;Test for error return
                	CALL	FDSTAT		;Get status on current drive
                	STA	FDLDST		;Save drive status
                	ANI	0CH		;Mask in sector size bits
                	PUSH	PSW		;Used to select a DPB
                	RAR
                	LXI	H,XLTS		;Table of XLT addresses
                	MOV	E,A
                	MVI	D,0
                	DAD	D
                	PUSH	H		;Save pointer to proper XLT
                	CALL	FDGET		;Get pointer to proper DPH
                	POP	D
                	LXI	B,2		;Copy XLT pointer into DPH
                	CALL	MOVBYT
                	LXI	D,8		;Offset to DPB pointer in DPH
                	DAD	D		;HL <- &DPH.DPB
                	PUSH	H
                	CALL	FDGSID		;Get pointer to side flag table entry
                	LDA	FDLDST		;Get drive status
                	ANI	DBLSID		;Check double sided bit
                	MOV	M,A		;Save sides flag
                	LXI	D,DPB128S	;Base for single sided DPB's
                	JZ	SIDEOK
                	LXI	D,DPB128D	;Base of double sided DPB's
                SIDEOK:	XCHG
                	POP	D		;(HL) -> DPB base, (DE) -> &DPH.DPB
                	POP	PSW		;Offset to correct DPB
                	RAL
                	RAL			;Make 0, 10, 20, 30
                	MOV	C,A
                	MVI	B,0		;Make offset
                	DAD	B		;(hl) is now a DPB pointer
                	XCHG			;Put proper DPB address in DPH.DPB
                	MOV	M,E
                	INX	H
                	MOV	M,D
                	LXI	H,15		;Offset to DPB.SIZ
                	DAD	D
                	MOV	C,M		;Fetch sector size code
                FDGET:	LDA	FDLOG		;Return proper DPH
                	LXI	D,DPHFD0
                	JMP	RETDPH
                ;DJ2D/B Non-Initial Drive Select Routine
                ;---------------------------------------
                ;
                FDSEL2:	STA	FDLOG
                	MOV	C,A
                	JMP	FDSEL
                ;DJ2D/B Home Drive Routine
                ;-------------------------
                ;
CP/M MACRO ASSEM 2.0	#061	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                FDLHOME:MVI	C,0		;Select side 0
                	CALL	FDSIDE
                	JMP	FDHOME		;Do actual home
                ;DJ2D/B Set Sector Routine
                ;-------------------------
                ;
                FDSSEC:	PUSH	B		;Save sector number
                	MOV	A,B		;Check side select bit
                	RLC			;Move high bit to bit zero
                	ANI	1
                	MOV	C,A
                	CALL	FDSIDE		;Call select side 0 = side A, 1 = Side B
                	POP	B
                	JMP	FDSEC
                FDGSID:	LXI	H,FDLSID	;Side flag table
                	LDA	FDLOG		;Drive number
                	PUSH	D
                	MOV	E,A		;Make offset
                	MVI	D,0
                	DAD	D		;Offset to proper entry
                	POP	D
                	MOV	A,M		;Set up flags
                	ORA	A
                	RET
                FDINIT:	DW	0		;Initialization bytes loaded onto 2D/B
                	DW	1800H		;Head loaded timeout
                	DW	0		;DMA address
                	DB	0		;Double sided flag
                	DB	0		;Read header flag
                	DB	07EH		;Drive select constant
                	DB	0		;Drive number
                	DB	8		;Current disk
                	DB	0		;Head loaded flag
                	DB	9		;Drive 0 parameters
                	DB	0FFH		;Drive 0 track address
                	DB	9		;Drive 1 parameters
                	DB	0FFH		;Drive 1 track address
                	DB	9		;Drive 2 parameters
                	DB	0FFH		;Drive 2 track address
                	DB	9		;Drive 3 parameters
                	DB	0FFH		;Drive 3 track address
                	DB	9		;Current parameters
                	DB	0		;Side desired
                	DB	1		;Sector desired
                	DB	0		;Track desired
                	DB	0		;Header image, track
                	DB	0		;Sector
                	DB	0		;Side
                	DB	0		;Sector
                	DW	0		;CRC
                FDLOG:	DB	0
                FDLDST:	DB	0		;Floppy drive status byte
                FDLSID:	REPT	MAXFD
                	DB	0FFH		;Double sided flag 0 = single, 1 = double
                	ENDM
                	ENDIF
CP/M MACRO ASSEM 2.0	#062	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	PAGE
CP/M MACRO ASSEM 2.0	#063	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	(MAXFD NE 0) OR (MAXDM NE 0)	;DJDMA or DJ2DB present?
                ;***********************************************************************
                ; Begin Common Floppy Disk Translation tables and DPB's
                ;******************************************************
                ;
                ;Sector translation pointer table
                ;--------------------------------
                ;	1) Xlts is a table of address that point to each of the xlt
                ;	   tables for each sector size.
                ;
 B5DD E5B5      XLTS:	DW	XLT128		;Xlt for 128 byte sectors
 B5DF 00B6      	DW	XLT256		;Xlt for 256 byte sectors
 B5E1 35B6      	DW	XLT512		;Xlt for 512 byte sectors
 B5E3 72B6      	DW	XLT124		;Xlt for 1024 byte sectors
                ;Sector translation tables
                ;-------------------------
                ;
                ;	1) Xlt tables (sector skew tables) for CP/M 2.0. These tables
                ;	   define the sector translation that occurs when mapping CP/M
                ;	   sectors to physical sectors on the disk. There is one skew
                ;	   table for each of the possible sector sizes. Currently the
                ;	   tables are located on track 0 sectors 6 and 8. They are
                ;	   loaded into memory in the Cbios ram by the cold boot routine.
                ;
 B5E5 00        XLT128:	DB	0
 B5E6 01070D1319	DB	1,7,13,19,25
 B5EB 050B1117  	DB	5,11,17,23
 B5EF 03090F15  	DB	3,9,15,21
 B5F3 02080E141A	DB	2,8,14,20,26
 B5F8 060C1218  	DB	6,12,18,24
 B5FC 040A1016  	DB	4,10,16,22
                ;
 B600 00        XLT256:	DB	0
 B601 0102131425	DB	1,2,19,20,37,38
 B607 0304151627	DB	3,4,21,22,39,40
 B60D 0506171829	DB	5,6,23,24,41,42
 B613 0708191A2B	DB	7,8,25,26,43,44
 B619 090A1B1C2D	DB	9,10,27,28,45,46
 B61F 0B0C1D1E2F	DB	11,12,29,30,47,48
 B625 0D0E1F2031	DB	13,14,31,32,49,50
 B62B 0F10212233	DB	15,16,33,34,51,52
 B631 11122324  	DB	17,18,35,36
                ;
 B635 00        XLT512:	DB	0
 B636 0102030411	DB	1,2,3,4,17,18,19,20
 B63E 2122232431	DB	33,34,35,36,49,50,51,52
 B646 0506070815	DB	5,6,7,8,21,22,23,24
 B64E 2526272835	DB	37,38,39,40,53,54,55,56
 B656 090A0B0C19	DB	9,10,11,12,25,26,27,28
 B65E 292A2B2C39	DB	41,42,43,44,57,58,59,60
 B666 0D0E0F101D	DB	13,14,15,16,29,30,31,32
 B66E 2D2E2F30  	DB	45,46,47,48
                ;
 B672 00        XLT124:	DB	0
 B673 0102030405	DB	1,2,3,4,5,6,7,8
CP/M MACRO ASSEM 2.0	#064	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B67B 191A1B1C1D	DB	25,26,27,28,29,30,31,32
 B683 3132333435	DB	49,50,51,52,53,54,55,56
 B68B 090A0B0C0D	DB	9,10,11,12,13,14,15,16
 B693 2122232425	DB	33,34,35,36,37,38,39,40
 B69B 393A3B3C3D	DB	57,58,59,60,61,62,63,64
 B6A3 1112131415	DB	17,18,19,20,21,22,23,24
 B6AB 292A2B2C2D	DB	41,42,43,44,45,46,47,48
                ;Disk Parameter Buffers
                ;----------------------
                ;	1) Each of the following tables describes a diskette with the
                ;	   specified characteristics.
                ;
                ;128 byte sectors, single density, and single sided.
                ;---------------------------------------------------
                ;
 B6B3 1A00      DPB128S:DW	26		;CP/M sectors/track
 B6B5 03        	DB	3		;BSH
 B6B6 07        	DB	7		;BLM
 B6B7 00        	DB	0		;EXM
 B6B8 F200      	DW	242		;DSM
 B6BA 3F00      	DW	63		;DRM
 B6BC C0        	DB	0C0H		;AL0
 B6BD 00        	DB	0		;AL1
 B6BE 1000      	DW	16		;CKS
 B6C0 0200      	DW	2		;OFF
 B6C2 01        	DB	1		;128 byte sectors
                ;
                ;256 byte sectors, double density, and single sided.
                ;---------------------------------------------------
                ;
 B6C3 3400      DPB256S:DW	52		;CP/M sectors/track
 B6C5 04        	DB	4		;BSH
 B6C6 0F        	DB	15		;BLM
 B6C7 01        	DB	1		;EXM
 B6C8 F200      	DW	242		;DSM
 B6CA 7F00      	DW	127		;DRM
 B6CC C0        	DB	0C0H		;AL0
 B6CD 00        	DB	0		;AL1
 B6CE 2000      	DW	32		;CKS
 B6D0 0200      	DW	2		;OFF
 B6D2 02        	DB	2		;256 byte sectors
                ;
                ;512 byte sectors, double density, and single sided.
                ;---------------------------------------------------
                ;
 B6D3 3C00      DPB512S:DW	60		;CP/M sectors/track
 B6D5 04        	DB	4		;BSH
 B6D6 0F        	DB	15		;BLM
 B6D7 00        	DB	0		;EXM
 B6D8 1801      	DW	280		;DSM
 B6DA 7F00      	DW	127		;DRM
 B6DC C0        	DB	0C0H		;AL0
 B6DD 00        	DB	0		;AL1
 B6DE 2000      	DW	32		;CKS
 B6E0 0200      	DW	2		;OFF
 B6E2 03        	DB	3		;512 byte sectors
CP/M MACRO ASSEM 2.0	#065	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;
                ;1024 byte sectors, double density, and single sided.
                ;----------------------------------------------------
                ;
 B6E3 4000      DP1024S:DW	64		;CP/M sectors/track
 B6E5 04        	DB	4		;BSH
 B6E6 0F        	DB	15		;BLM
 B6E7 00        	DB	0		;EXM
 B6E8 2B01      	DW	299		;DSM
 B6EA 7F00      	DW	127		;DRM
 B6EC C0        	DB	0C0H		;AL0
 B6ED 00        	DB	0		;AL1
 B6EE 2000      	DW	32		;CKS
 B6F0 0200      	DW	2		;OFF
 B6F2 04        	DB	4		;1024 byte sectors
                ;
                ;128 byte sectors, single density, and double sided.
                ;----------------------------------------------------;
                ;
 B6F3 3400      DPB128D:DW	52		;CP/M sectors/track
 B6F5 04        	DB	4		;BSH
 B6F6 0F        	DB	15		;BLM
 B6F7 01        	DB	1		;EXM
 B6F8 F200      	DW	242		;DSM
 B6FA 7F00      	DW	127		;DRM
 B6FC C0        	DB	0C0H		;AL0
 B6FD 00        	DB	0		;AL1
 B6FE 2000      	DW	32		;CKS
 B700 0200      	DW	2		;OFF
 B702 01        	DB	1		;128 byte sectors
                ;
                ;256 byte sectors, double density, and double sided.
                ;---------------------------------------------------
                ;
 B703 6800      DPB256D:DW	104		;CP/M sectors/track
 B705 04        	DB	4		;BSH
 B706 0F        	DB	15		;BLM
 B707 00        	DB	0		;EXM
 B708 E601      	DW	486		;DSM
 B70A FF00      	DW	255		;DRM
 B70C F0        	DB	0F0H		;AL0
 B70D 00        	DB	0		;AL1
 B70E 4000      	DW	64		;CKS
 B710 0200      	DW	2		;OFF
 B712 02        	DB	2		;256 byte sectors
                ;
                ;512 byte sectors, double density, and double sided.
                ;---------------------------------------------------
                ;
 B713 7800      DPB512D:DW	120		;CP/M sectors/track
 B715 04        	DB	4		;BSH
 B716 0F        	DB	15		;BLM
 B717 00        	DB	0		;EXM
 B718 3102      	DW	561		;DSM
 B71A FF00      	DW	255		;DRM
 B71C F0        	DB	0F0H		;AL0
CP/M MACRO ASSEM 2.0	#066	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B71D 00        	DB	0		;AL1
 B71E 4000      	DW	64		;CKS
 B720 0200      	DW	2		;OFF
 B722 03        	DB	3		;512 byte sectors
                ;
                ;1024 byte sectors, double density, and double sided.
                ;----------------------------------------------------
                ;
 B723 8000      DP1024D:DW	128		;CP/M sectors/track
 B725 04        	DB	4		;BSH
 B726 0F        	DB	15		;BLM
 B727 00        	DB	0		;EXM
 B728 5702      	DW	599		;DSM
 B72A FF00      	DW	255		;DRM
 B72C F0        	DB	0F0H		;AL0
 B72D 00        	DB	0		;AL1
 B72E 4000      	DW	64		;CKS
 B730 0200      	DW	2		;OFF
 B732 04        	DB	4		;1024 byte sectors
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#067	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	MAXMW NE 0	;HDDMA controller present ?
                ;**********************************************************
                ; Begin the HDDMA Driver (DDRV3)
                ;*******************************
                ;
                ;HDDMA equates
                ;=============
                ;
                	;Specifications for a Seagate Technology 506
                	IF	ST506
                CYL	EQU	153		;Number of cylinders
                HEADS	EQU	4		;Number of heads per cylinder
                PRECOMP	EQU	64		;Cylinder to start write precomensation
                LOWCURR	EQU	128		;Cylinder to start low current
                STEPDLY	EQU	30		;Step delay (0-12.7 milliseconds)
                STEPRCL	EQU	30		;Recalibrate step delay
                HEADDLY	EQU	0		;Settle delay (0-25.5 milliseconds)
                	ENDIF
                	;Specifications for a Seagate ST412
                	IF	ST412
                CYL	EQU	306		;Number of cylinders
                HEADS	EQU	4		;Number of heads per cylinder
                PRECOMP	EQU	128		;Cylinder to start write precomensation
                LOWCURR	EQU	128		;Cylinder to start low current
                STEPDLY	EQU	0		;Step delay (0-12.7 milliseconds)
                STEPRCL	EQU	30		;Recalibrate step delay
                HEADDLY	EQU	0
                	ENDIF
                	;Specifications for an CMI 5619
                	IF	CM5619
                CYL	EQU	306		;Number of cylinders
                HEADS	EQU	6		;Number of heads per cylinder
                PRECOMP	EQU	128		;Cylinder to start write precomensation
                LOWCURR	EQU	128		;Cylinder to start low current
                STEPDLY	EQU	2		;Step delay (0-12.7 milliseconds)
                STEPRCL	EQU	30		;Recalibrate step delay
                HEADDLY	EQU	0
                	ENDIF
                SECTSIZ	EQU	7		;Sector size code (must be 7 for this Cbios)
                				; 0 =  128 byte sectors
                				; 1 =  256 byte sectors
                				; 3 =  512 byte sectors
                				; 7 = 1024 byte sectors (default)
                				; f = 2048 byte sectors
                				;Define controller commands
                DMAREAD	EQU	0		;Read sector
                DMAWRIT	EQU	1		;Write sector
                DMARHED	EQU	2		;Find a sector
                DMAWHED	EQU	3		;Write headers (format a track)
                DMALCON	EQU	4		;Load disk parameters
                DMASSTA	EQU	5		;Sense disk drive status
                DMANOOP	EQU	6		;Null controller operation
                RESET	EQU	54H		;Reset controller
                ATTN	EQU	55H		;Send a controller attention
                CHAN	EQU	50H		;Default channel address
CP/M MACRO ASSEM 2.0	#068	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                STEPOUT	EQU	10H		;Step direction out
                STEPIN	EQU	0		;Step direction in
                BAND1	EQU	40H		;No precomp, high current
                BAND2	EQU	0C0H		;Precomp, high current
                BAND3	EQU	80H		;precomp, low current
                TRACK0	EQU	1		;Track zero status
                WFLT	EQU	2		;Write fault from drive
                DREADY	EQU	4		;Drive ready
                SEKCMP	EQU	8		;Seek complete
                ;Drive Specification Table for the HD DMA hard disk controller
                ;-------------------------------------------------------------
                ;
                MWDST:	DB	MAXMW*MWLOG	;Number of logical drives
                	DW	MWWARM		;Warm boot
                	DW	MWTRAN		;Sector translation
                	DW	MWLDRV		;Select logical drive 1 (First time select)
                	DW	MWDRV		;Select logical drive 2 (General select)
                	DW	MWHOME		;Home current selected drive
                	DW	MWSEEK		;Seek to selected track
                	DW	MWSEC		;Select sector
                	DW	MWDMA		;Set DMA address
                	DW	MWREAD		;Read a sector
                	DW	MWWRITE		;Write a sector
                	IF	HEADS GT 2	;Test if drive is big enough for a bad spot map
                	DW	MWBAD		;Return bad sector map info
                	ELSE
                	DW	NOBAD
                	ENDIF
                	IF	MWORDER NE 1		;no warm boot possible
                ;HDDMA warm boot dummy
                ;---------------------------
                ;	1) If HDDMA is not drive A (i.e. mworder not equal 1) then
                ;	   it is not possible to warm boot from HDDMA. So routine not needed.
                ;
                MWWARM:	RET				;return if called
                	ELSE
                ;HDDMA Warm Boot Routine
                ;-----------------------
                ;
                MWWARM:	XRA	A
                	CALL	MWDRV		;Select drive A
                	CALL	MWHOME		;Home and reset the drive
                	LXI	B,0		;Make sure we are on track 0
                	CALL	MWSEEK
                	XRA	A
                	STA	MWHEAD		;Select head zero
                	STA	MWSECTR		;Select sector 1
                	LXI	H,BUFFER	;Load sector 1 into buffer
                	SHLD	DMADMA
                	CALL	MWWREAD		;Read CCP into buffer
                	RC			;Return if error
                	LXI	D,BUFFER+200H
                	LXI	H,CCP
                	LXI	B,200H		;Move 200h bytes
                	CALL	MOVBYT
                	LXI	H,CCP-200H	;Initial DMA address
CP/M MACRO ASSEM 2.0	#069	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	PUSH	H
                	XRA	A
                	PUSH	PSW		;Save first sector -1
                MWWLOD:	POP	PSW		;Restore sector
                	POP	H		;Restore DMA address
                	INR	A
                	STA	MWSECTR
                	CPI	6		;Past BDOS ?
                	RZ			;Yes, all done
                	INR	H		;Update DMA address by 1024 bytes
                	INR	H
                	INR	H
                	INR	H
                	SHLD	DMADMA
                	PUSH	H
                	PUSH	PSW
                	CALL	MWWREAD		;Read in a sector
                	JNC	MWWLOD
                	RET			;Return with error
                MWWREAD:MVI	C,RETRIES	;Retry counter
                MWWERR:	PUSH	B		;Save the retry count
                	CALL	MWREAD		;Read the sector
                	POP	B
                	RNC
                	DCR	C		;Update the error count
                	JNZ	MWWERR		;Keep trying if not too many errors
                	STC			;Set error flag
                	RET
                	ENDIF			;of HDDMA warm boot routine
                ;HDDMA First Time Drive Select Routine
                ;-------------------------------------
                ;
                MWLDRV:	STA	MWCURL		;Save current logical drive
                	CALL	MWRESET		;Reset controller card
                	JC	ZRET		;Controller failure
                	LDA	MWCURL
                	CALL	MWDRV		;Select drive
                	JC	ZRET		;Select error
                	CALL	MWSTAT		;Get drive status
                	ANI	DREADY		;Check if drive ready
                	JNZ	ZRET
                	CALL	MWHOME		;Home drive
                	LXI	D,DPHMW0	;Start of hard disk DPH's
                	LDA	MWCURL
                	MOV	L,A
                	MVI	H,0
                	DAD	H
                	DAD	H
                	DAD	H
                	DAD	H
                	DAD	D		;(hl) = pointer to DPH
                	MVI	C,4		;Return sector size of 1024
                	RET
                ;HDDMA Non-Initial Drive Select Routine
                ;--------------------------------------
                ;
CP/M MACRO ASSEM 2.0	#070	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                MWDRV:	STA	MWCURL
                	CALL	MWDLOG
                	MOV	A,C
                	STA	MWDRIVE		;Save new selected drive
                MWSEL:	MVI	A,DMANOOP
                	JMP	MWPREP		;Execute disk command
                MWDLOG:	MVI	C,0
                MWLLX:	SUI	MWLOG
                	RC
                	INR	C
                	JMP	MWLLX
                MWSTAT:	MVI	A,DMASSTA	;Sense status operation code
                	JMP	MWPREP		;Execute disk command
                ;HDDMA Home Drive Routine
                ;------------------------
                ;
                MWHOME:	CALL	MWRESET		;Reset controller, do a load constants
                	LXI	H,DMARG1	;Load arguments
                	MVI	M,STEPRCL	;Load step delay (slow rate)
                	INX	H
                	MVI	M,HEADDLY	;Head settle delay
                	CALL	MWISSUE		;Do load constants again
                	CALL	MWPTR		;Get pointer to current cylinder number
                	MVI	M,0FFH		;Fake at cylinder 65535 for max head travel
                	INX	H
                	MVI	M,0FFH
                	LXI	B,0		;Seek to cylinder 0
                	CALL	MWSEEK		;Recal slowly
                	JMP	MWRESET		;Back to fast stepping mode
                ;HDDMA Return Bad Map Position Routine
                ;-------------------------------------
                ;
                MWBAD:	LXI	H,MWBTAB	;Return pointer to bad sector location
                	RET
                MWBTAB:	DW	0		;Track 0
                	DW	19		;Head 2, sector 0  = (2 * SPT + 0) + 1
                ;HDDMA Set Track Routine
                ;-----------------------
                ;
                MWSEEK:	CALL	MWPTR		;Get track pointer
                	MOV	E,M		;Get old track number
                	INX	H
                	MOV	D,M
                	DCX	H
                	MOV	M,C		;Store new track number
                	INX	H
                	MOV	M,B
                	MOV	L,C		;Build cylinder word
                	MOV	H,B
                	SHLD	DMARG0		;Set command channel cylinder number
                	MOV	A,D
                	INR	A
                	LXI	H,0FFFFH
                	JNZ	MWSKIP0
                	MVI	C,STEPOUT
                	JMP	MWSKIP
CP/M MACRO ASSEM 2.0	#071	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                MWSKIP0:MOV	H,B		;(hl) = new track, (de) = old track
                	MOV	L,C
                	CALL	MWHLMDE
                	MVI	C,STEPOUT
                	MOV	A,H
                	ANI	80H		;Check hit bit for negitive direction
                	JNZ	MWSOUT		;Step in
                	MVI	C,0
                	JMP	MWSKIP
                MWSOUT:	CALL	MWNEGHL
                MWSKIP:	SHLD	DMASTEP
                	LDA	MWDRIVE
                	ORA	C
                	STA	DMASEL0
                	MVI	A,DMANOOP	;No-operation command for the channel
                	CALL	MWPREP		;Step to proper track
                	LXI	H,0		;Clear step counter
                	SHLD	DMASTEP
                	RET
                ;HDDMA Set DMA Address Routine
                ;-----------------------------
                ;
                MWDMA:	MOV	H,B		;Set DMA address
                	MOV	L,C
                	SHLD	DMADMA
                	RET
                ;HDDMA Set Sector Routine
                ;------------------------
                ;
                MWSEC:	MOV	A,C		;Load sector number
                	DCR	A		;Range is actaully 0-16
                	CALL	MWDSPT		;Figure out head number -> (c)
                	ADI	MWSPT		;Make sector number
                	STA	MWSECTR
                	MOV	A,C
                	STA	MWHEAD		;Save head number
                	RET
                MWDSPT:	MVI	C,0		;Clear head counter
                MWDSPTX:SUI	MWSPT		;Subtract a tracks worth of sectors
                	RC			;Return if all done
                	INR	C		;Bump to next head
                	JMP	MWDSPTX
                MWRESET:LHLD	CHAN		;Save the command channel for a while
                	SHLD	TEMPB
                	LDA	CHAN+2
                	STA	TEMPB+2
                	OUT	RESET		;Send reset pulse to controller
                	LXI	H,DMACHAN	;Address of command channel
                	SHLD	CHAN		;Default channel address
                	XRA	A
                	STA	CHAN+2		;Clear extended address byte
                	SHLD	40H		;Set up a pointer to the command channel
                	STA	42H
                	LHLD	DMARG0		;Save the track number
                	PUSH	H
                	LXI	H,DMASEL1	;Load arguments
CP/M MACRO ASSEM 2.0	#072	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	LDA	MWDRIVE		;Get the currently selected drive
                	ORI	03CH		;Raise *step and *dir
                	MOV	M,A		;Save in drive select register
                	LXI	D,5		;Offset to dmarg1
                	DAD	D
                	MVI	M,STEPDLY	;Load step delay
                	INX	H
                	MVI	M,HEADDLY	;Head settle delay
                	INX	H
                	MVI	M,SECTSIZ	;Sector size code
                	INX	H
                	MVI	M,DMALCON	;Load constants command
                	CALL	MWISSUE		;Do load constants
                	POP	H		;Restore the track number
                	SHLD	DMARG0
                	PUSH	PSW		;Save status
                	LHLD	TEMPB		;Restore memory used for the channel pointer
                	SHLD	CHAN
                	LDA	TEMPB+2
                	STA	CHAN+2
                	POP	PSW
                	RET
                ;HDDMA Read/Write Sector Routines
                ;--------------------------------
                ;
                MWREAD:	MVI	A,DMAREAD	;Load disk read commnd
                	JMP	MWPREP
                MWWRITE:MVI	A,DMAWRIT	;Load disk write command
                MWPREP:	STA	DMAOP		;Save command channel op code
                	MVI	C,BAND1
                	LHLD	DMARG0
                	LXI	D,PRECOMP
                	CALL	MWHLCDE
                	JC	MWPREPS
                	MVI	C,BAND2
                	LXI	D,LOWCURR
                	CALL	MWHLCDE
                	JC	MWPREPS
                	MVI	C,BAND3		;cylinder > low_current
                MWPREPS:LDA	MWHEAD		;Load head address
                	STA	DMARG2
                	CMA			;Negative logic for the controller
                	ANI	7		;3 bits of head select
                	RLC			;Shove over to bits 2 - 4
                	RLC
                	ORA	C		;Add on low current and precomp bits
                	MOV	C,A
                	LDA	MWDRIVE		;Load drive address
                	ORA	C		;Slap in drive bits
                	STA	DMASEL1		;Save in command channel head select
                	LDA	MWSECTR		;Load sector address
                	STA	DMARG3
                	IF	0		;Set to 1 for MW error reporter
                MWISSUE:CALL	MWDOIT		;Do desired operation
                	RNC			;Do nothing if no error
                	PUSH	PSW		;Save error info
CP/M MACRO ASSEM 2.0	#073	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	CALL	HEXOUT		;Print status
                	CALL	DSPOUT		;   and a space
                	LXI	H,DMACHAN
                	MVI	C,16		;16 bytes of status
                MWERR:	PUSH	B
                	PUSH	H
                	MOV	A,M
                	CALL	HEXOUT		;Print a byte of the status line
                	CALL	SPOUT
                	POP	H
                	POP	B
                	INX	H		;Bump command channel pointer
                	DCR	C
                	JNZ	MWERR
                	MVI	C,0AH		;Terminate with a CRLF
                	CALL	POUT
                	MVI	C,0DH
                	CALL	POUT
                	POP	PSW		;Restore error status
                	RET
                DSPOUT:	CALL	SPOUT		;Print two spaces
                SPOUT:	MVI	C,' '		;Print a space
                	JMP	POUT
                HEXOUT:	PUSH	PSW		;Poor persons number printer
                	RRC
                	RRC
                	RRC
                	RRC
                	CALL	NIBOUT
                	POP	PSW
                NIBOUT:	ANI	0FH
                	ADI	'0'
                	CPI	'9'+1
                	JC	NIBOK
                	ADI	27H
                NIBOK:	MOV	C,A
                	JMP	POUT
                MWDOIT	EQU	$
                	ELSE
                MWISSUE	EQU	$		;Do a disk command, handle timeouts + errors
                	ENDIF
                	LXI	H,DMASTAT	;Clear status byte
                	MVI	M,0
                	OUT	ATTN		;Start the controller
                	LXI	D,0		;Time out counter (65536 retries)
                MWILOOP:MOV	A,M		;Get status
                	ORA	A		;Set up CPU flags
                	RM			;Return no error (carry reset)
                	STC
                	RNZ			;Return error status
                	XTHL			;Waste some time
                	XTHL
                	XTHL
                	XTHL
                	DCX	D		;Bump timeout counter
                	MOV	A,D
CP/M MACRO ASSEM 2.0	#074	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	ORA	E
                	JNZ	MWILOOP		;Loop if still busy
                	STC			;Set error flag
                	RET
                MWPTR:	LDA	MWDRIVE		;Get currently select drives track address
                	RLC
                	MOV	E,A
                	MVI	D,0
                	LXI	H,MWTAB
                	DAD	D		;Offset into track table
                	RET
                MWTRAN:	MOV	H,B
                	MOV	L,C
                	INX	H
                	RET
                MWNEGHL:MOV	A,H
                	CMA
                	MOV	H,A
                	MOV	A,L
                	CMA
                	MOV	L,A
                	INX	H
                	RET
                MWHLMDE:XCHG
                	CALL	MWNEGHL
                	XCHG
                	DAD	D
                	RET
                MWHLCDE:MOV	A,H
                	CMP	D
                	RNZ
                	MOV	A,L
                	CMP	E
                	RET
                MWTAB	EQU	$		;Collection of track addresses
                	REPT	MAXMW
                	DB	0FFH		;Initialize to (way out on the end of the disk)
                	DB	0FFH
                	ENDM
                	DB	0FFH
                MWCURL:	DB	0		;Current logical drive
                MWDRIVE:DB	0FFH		;Currently selected drive
                MWHEAD:	DB	0		;Currently selected head
                MWSECTR:DB	0		;Currently selected sector
                DMACHAN	EQU	$		;Command channel area
                DMASEL0:DB	0		;Drive select
                DMASTEP:DW	0		;Relative step counter
                DMASEL1:DB	0		;Head select
                DMADMA:	DW	0		;DMA address
                	DB	0		;Extended address
                DMARG0:	DB	0		;First argument
                DMARG1:	DB	0		;Second argument
                DMARG2:	DB	0		;Third argument
                DMARG3:	DB	0		;Fourth argument
                DMAOP:	DB	0		;Operation code
                DMASTAT:DB	0		;Controller status byte
CP/M MACRO ASSEM 2.0	#075	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                DMALNK:	DW	DMACHAN		;Link address to next command channel
                	DB	0		;extended address
                TEMPB:	DS	4		;Command Channel Pointer Buffer
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#076	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	MAXHD NE 0	;Want HDC3 or 4 controller included ?
                ;****************************************************************************
                ; Begin the HDCA Driver (DDRV4)
                ;******************************
                ;
                ;HDCA equates
                ;------------
                ;
                HDORG	EQU	50H			;Hard Disk Controller origin
                HDSTAT	EQU	HDORG			;Disk Status
                HDCNTL	EQU	HDORG			;Disk Control
                HDRESLT	EQU	HDORG+1			;Disk Results
                HDCMND	EQU	HDORG+1			;Disk Commands
                HDSKOMP	EQU	HDORG+2			;Seek complete clear port (on HDC4)
                HDFUNC	EQU	HDORG+2			;Function port
                HDDATA	EQU	HDORG+3			;Data port
                ;	Status port (50)
                TKZERO	EQU	01H			;Track zero
                OPDONE	EQU	02H			;Operation done
                COMPLT	EQU	04H			;Seek complete
                TMOUT	EQU	08H			;Time out
                WFAULT	EQU	10H			;Write fault
                DRVRDY	EQU	20H			;Drive ready
                INDEX	EQU	40H			;Delta index
                ;	Control port (50)
                HDFREN	EQU	01H			;Enable external drivers
                HDRUN	EQU	02H			;Enable controllers state machine
                HDCLOK	EQU	04H			;Clock source control bit, high = disk
                HDWPRT	EQU	08H			;Write protect a drive
                ;	Result port (51)
                RETRY	EQU	02H			;Retry flag
                ;	Command port (51)
                IDBUFF	EQU	0			;Initialize data buffer pointer
                RSECT	EQU	1			;Read sector
                WSECT	EQU	5			;Write sector
                ISBUFF	EQU	8			;Initialize header buffer pointer
                ;	Function port (52)
                PSTEP	EQU	04H			;Step bit
                NSTEP	EQU	0FFH-PSTEP		;Step bit mask
                NULL	EQU	0FCH			;Null command
                ;	Misc constants
                HDRLEN	EQU	4			;Sector header length
                SECLEN	EQU	512			;Sector data length
                ;
                ;Device Specification Table for HDCA controller driver
                ;-----------------------------------------------------
                ;
                HDDST:	DB	MAXHD*HDLOG		;Number of logical drives
                	DW	HDWARM			;Warm boot
                	DW	HDTRAN			;Sector translation
                	DW	HDLDRV			;First time select
                	DW	HDDRV			;General select
                	DW	HDHOME			;Home current selected drive
                	DW	HDSEEK			;Seek to selected track
                	DW	HDSEC			;Select sector
CP/M MACRO ASSEM 2.0	#077	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	DW	HDDMA			;Set DMA address
                	DW	HDREAD			;Read a sector
                	DW	HDWRITE			;Write a sector
                	DW	NOBAD			;No bad sector map
                	IF	HDORDER NE 1		;no warm boot possible
                ;HDCA warm boot dummy
                ;---------------------------
                ;	1) If HDCA is not drive A (i.e. hdorder not equal 1) then
                ;	   it is not possible to warm boot from HDCA. So routine not needed.
                ;
                HDWARM:	RET				;return if called
                	ELSE
                ;HDCA Warm Boot Routine
                ;----------------------
                ;
                HDWARM:	CALL	DIVLOG			;Get physical drive number in (c)
                	XRA	A
                	LXI	H,CCP-200H		;Initial DMA address
                	PUSH	H
                	STA	HEAD			;Select head zero
                	INR	A			; 1 -> (a)
                	PUSH	PSW			;Save first sector - 1
                	CALL	HDD2			;Select drive
                	MVI	C,0
                	CALL	HDHOME			;Home the drive
                HDWRLD:	POP	PSW			;Restore sector
                	POP	H			;Restore DMA address
                	INR	A
                	STA	HDSECT
                	CPI	13			;Past BDOS ?
                	RZ				;Yes, all done
                	INR	H			;Update DMA address
                	INR	H
                	SHLD	HDADD
                	PUSH	H
                	PUSH	PSW
                HDWRRD:	LXI	B,RETRIES*100H+0	;Retry counter
                HDWR:	PUSH	B			;Save the retry count
                	CALL	HDREAD			;Read the sector
                	POP	B
                	JNC	HDWRLD			;Test for error
                	DCR	B			;Update the error count
                	JNZ	HDWR			;Keep trying if not too many errors
                	STC				;Error flag
                	RET
                	ENDIF				;HDCA warm boot routine
                ;HDCA Sector Translate Routine
                ;-----------------------------
                ;
                HDTRAN:	MOV	H,B			;Sector translation is handled via
                	MOV	L,C			;   physical sector header skewwing
                	INX	H
                	RET
                ;HDCA First Time Drive Select Routine
                ;------------------------------------
                ;
CP/M MACRO ASSEM 2.0	#078	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                HDLDRV:	STA	HDCUR			;Save logical disk
                	CALL	DIVLOG			;Divide by logical disks per drive
                	MOV	A,C
                	STA	HDDISK			;Save new physical drive
                	CALL	HDPTR			;Get track pointers
                	MOV	A,M			;Get current track
                	INR	A			;Check if -1
                	JNZ	HDL2			;Nope, allready accessed
                	ORI	NULL			;Select drive
                	OUT	HDFUNC
                	MVI	A,HDFREN+HDCLOK		;Enable drivers
                	OUT	HDCNTL
                	MVI	C,239			;Wait 2 minutes for disk ready
                	LXI	H,0
                HDTDEL:	DCX	H
                	MOV	A,H
                	ORA	L
                	CZ	DCRC
                	JZ	ZRET			;Drive not ready error
                	IN	HDSTAT			;Test if ready yet
                	ANI	DRVRDY
                	JNZ	HDTDEL
                	IF	NOT FUJITSU
                	LXI	H,0			;Time one revolution of the drive
                	MVI	C,INDEX
                	IN	HDSTAT
                	ANA	C
                	MOV	B,A			;Save current index level in B
                HDINXD1:IN	HDSTAT
                	ANA	C
                	CMP	B			;Loop untill index level changes
                	JZ	HDINXD1
                HDINDX2:INX	H
                	IN	HDSTAT			;Start counting untill index returns to
                	ANA	C			;	previous state
                	CMP	B
                	JNZ	HDINDX2
                	IF	M10			;Memorex M10's have 40 ms head settle
                	DAD	H			;HL*2
                	ENDIF
                	IF	M26			;Shugart M26's have 30 ms head settle
                	XRA	A			;HL/2 + HL (same as HL*1.5)
                	MOV	A,H
                	RAR
                	MOV	D,A
                	MOV	A,L
                	RAR
                	MOV	E,A
                	DAD	D
                	ENDIF
                	SHLD	SETTLE			;Save the count for timeout delay
                	ENDIF
                	CALL	HDHOME
                HDL2:	LDA	HDCUR			;Load logical drive
                	LXI	D,DPHHD0		;Start of hard disk DPH's
                	MVI	C,3			;Hard disk sector size equals 512 bytes
CP/M MACRO ASSEM 2.0	#079	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	JMP	RETDPH
                DCRC:	DCR	C			;Conditional decrement C routine
                	RET
                DIVLOG:	MVI	C,0
                DIVLX:	SUI	HDLOG
                	RC
                	INR	C
                	JMP	DIVLX
                ;HDCA Non-Initial Drive Select Routine
                ;-------------------------------------
                ;
                HDDRV:	STA	HDCUR
                	CALL	DIVLOG			;Get the physical drive #
                HDD2:	MOV	A,C
                	STA	HDDISK			;Select the drive
                	ORI	NULL
                	OUT	HDFUNC
                	MVI	A,HDFREN+HDRUN+HDCLOK+HDWPRT	;Write protect
                	OUT	HDCNTL
                	RET
                ;HDCA Home Disk Routine
                ;----------------------
                ;
                HDHOME:	CALL	HDPTR			;Get track pointer
                	MVI	M,0			;Set track to zero
                	IN	HDSTAT			;Test status
                	ANI	TKZERO			;At track zero ?
                	RZ				;Yes
                	IF	NOT FUJITSU
                HDSTEPO:IN	HDSTAT			;Test status
                	ANI	TKZERO			;At track zero ?
                	JZ	HDDELAY
                	MVI	A,1
                	STC
                	CALL	ACCOK			;Take one step out
                	JMP	HDSTEPO
                	ELSE
                	XRA	A
                	JMP	ACCOK
                	ENDIF
                	IF	NOT FUJITSU
                HDDELAY:LHLD	SETTLE			;Get hddelay
                DELOOP:	DCX	H			;Wait 20ms
                	MOV	A,H
                	ORA	L
                	INX	H
                	DCX	H
                	JNZ	DELOOP
                	RET
                	ENDIF
                ;HDCA Set Track Routine
                ;----------------------
                ;
                HDSEEK:	CALL	HDPTR			;Get pointer to current track
                	MOV	E,M			;Get current track
                	MOV	M,C			;Update the track
CP/M MACRO ASSEM 2.0	#080	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	MOV	A,E			;Need to seek at all ?
                	SUB	C
                	RZ
                	CMC				;Get carry into direction
                	JC	HDTRK2
                	CMA
                	INR	A
                	IF	FUJITSU
                HDTRK2:	JMP	ACCOK
                	ELSE
                HDTRK2:	CALL	ACCOK
                	JMP	HDDELAY
                	ENDIF
                ACCOK:	MOV	B,A			;Prep for build
                	CALL	BUILD
                SLOOP:	ANI	NSTEP			;Get step pulse low
                	OUT	HDFUNC			;Output low step line
                	ORI	PSTEP			;Set step line high
                	OUT	HDFUNC			;Output high step line
                	DCR	B			;Update repeat count
                	JNZ	SLOOP			;Keep going the required # of tracks
                	JMP	WSDONE
                ;HDCA Set DMA Address Routine
                ;----------------------------
                ;
                HDDMA:	MOV	H,B			;Save the DMA address
                	MOV	L,C
                	SHLD	HDADD
                	RET
                WSDONE:	IN	HDSTAT			;Wait for seek complete to finish
                	ANI	COMPLT
                	JZ	WSDONE
                	IN	HDSKOMP			;Clear sdone bit on an HDCA4
                	RET
                ;HDCA Set Sector Routine for M26 Disk
                ;------------------------------------
                ;
                	IF	M26
                HDSEC:	MVI	A,01FH			;For compatibility with Cbios revs.
                					;  2.3 and 2.4
                	ANA	C			;Mask in sector number (0-31)
                	CZ	GETSPT			;Translate sector 0 to sector 32
                	STA	HDSECT			;Save translated sector number (1-32)
                	MVI	A,0E0H			;Get the head number
                	ANA	C
                	RLC
                	RLC
                	RLC
                	STA	HEAD			;Save the head number
                GETSPT:	MVI	A,HDSPT
                	RET
                	ELSE
                ;HDCA Set Sector Routine for M10 and M20 Disks
                ;---------------------------------------------
                ;
                HDSEC:	MOV	A,C
CP/M MACRO ASSEM 2.0	#081	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	CALL	DIVSPT
                	ADI	HDSPT
                	ANA	A
                	CZ	GETSPT
                	STA	HDSECT
                	MOV	A,C
                	STA	HEAD
                GETSPT:	MVI	A,HDSPT
                	DCR	C
                	RET
                DIVSPT:	MVI	C,0
                DIVSX:	SUI	HDSPT
                	RC
                	INR	C
                	JMP	DIVSX
                	ENDIF
                ;HDCA Read Sector Routine
                ;------------------------
                ;
                HDREAD:	CALL	HDPREP
                	RC
                	XRA	A
                	OUT	HDCMND
                	CMA
                	OUT	HDDATA
                	OUT	HDDATA
                	MVI	A,RSECT			;Read sector command
                	OUT	HDCMND
                	CALL	PROCESS
                	RC
                	XRA	A
                	OUT	HDCMND
                	MVI	B,SECLEN/4
                	LHLD	HDADD
                	IN	HDDATA
                	IN	HDDATA
                RTLOOP:	IN	HDDATA			;Move four bytes
                	MOV	M,A
                	INX	H
                	IN	HDDATA
                	MOV	M,A
                	INX	H
                	IN	HDDATA
                	MOV	M,A
                	INX	H
                	IN	HDDATA
                	MOV	M,A
                	INX	H
                	DCR	B
                	JNZ	RTLOOP
                	RET
                ;HDCA Write Sector Routine
                ;-------------------------
                ;
                HDWRITE:CALL	HDPREP			;Prepare header
                	RC
CP/M MACRO ASSEM 2.0	#082	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	XRA	A
                	OUT	HDCMND
                	LHLD	HDADD
                	MVI	B,SECLEN/4
                WTLOOP:	MOV	A,M			;Move 4 bytes
                	OUT	HDDATA
                	INX	H
                	MOV	A,M
                	OUT	HDDATA
                	INX	H
                	MOV	A,M
                	OUT	HDDATA
                	INX	H
                	MOV	A,M
                	OUT	HDDATA
                	INX	H
                	DCR	B
                	JNZ	WTLOOP
                	MVI	A,WSECT			;Issue write sector command
                	OUT	HDCMND
                	CALL	PROCESS
                	RC
                	MVI	A,WFAULT
                	ANA	B
                	STC
                	RZ
                	XRA	A
                	RET
                PROCESS:IN	HDSTAT			;Wait for command to finish
                	MOV	B,A
                	ANI	OPDONE
                	JZ	PROCESS
                	MVI	A,HDFREN+HDRUN+HDCLOK	;Write protect
                	OUT	HDCNTL
                	IN	HDSTAT
                	ANI	TMOUT			;Timed out ?
                	STC
                	RNZ
                	IN	HDRESLT
                	ANI	RETRY			;Any retries ?
                	STC
                	RNZ
                	XRA	A
                	RET
                HDPREP:	IN	HDSTAT
                	ANI	DRVRDY
                	STC
                	RNZ
                	MVI	A,ISBUFF		;Initialize pointer
                	OUT	HDCMND
                	CALL	BUILD
                	ORI	0CH
                	OUT	HDFUNC
                	LDA	HEAD
                	OUT	HDDATA			;Form head byte
                	CALL	HDPTR			;Get pointer to current drives track
CP/M MACRO ASSEM 2.0	#083	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	MOV	A,M			;Form track byte
                	OUT	HDDATA
                	ANA	A
                	MVI	B,80H
                	JZ	ZKEY
                	MVI	B,0
                ZKEY:	LDA	HDSECT			;Form sector byte
                	OUT	HDDATA
                	MOV	A,B
                	OUT	HDDATA
                	MVI	A,HDFREN+HDRUN+HDCLOK	;Write protect
                	OUT	HDCNTL
                	MVI	A,HDFREN+HDRUN+HDCLOK+HDWPRT	;Write protect
                	OUT	HDCNTL
                	XRA	A
                	RET
                HDPTR:	LHLD	HDDISK			;Get a pointer to the current drives
                	MVI	H,0			;   track position
                	XCHG
                	LXI	H,HDTRAK
                	DAD	D
                	RET
                BUILD:	LDA	HEAD			;Build a controller command byte
                	RAL
                	RAL
                	RAL
                	RAL
                	LXI	H,HDDISK
                	ORA	M
                	XRI	0F0H
                	RET
                HDCUR:	DB	0			;Current logical disk
                HDADD:	DW	0			;DMA address
                HDDISK:	DB	0			;Current physical disk number
                HEAD:	DB	0			;Current physical head number
                HDSECT:	DB	0			;Current physical sector number
                HDTRAK:	DB	0FFH			;Track pointer for each drive
                	DB	0FFH			;All drive default to an uncalibrated
                	DB	0FFH			;   state (ff)
                	DB	0FFH
                SETTLE:	DW	0			;Time delay constant for head settle
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#084	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;********************
                ; End of Disk Drivers
                ;********************
                ;
                ; Cbios ram locations that don't need initialization.
                ;====================================================
                ;
                	IF	NOSTAND NE 0	;Unallocated writting variables
                UNALOC:	DB	0		;Unallocated write in progress flag
                OBLOCK:	DW	0		;Last unallocated block number written
                UNADRV:	DB	0		;Drive that the block belongs to
                	ENDIF
 B733 0000      CPMSEC:	DW	0		;CP/M sector #
 B735 00        CPMDRV:	DB	0		;CP/M drive #
 B736 0000      CPMTRK: DW	0		;CP/M track #
 B738 0000      TRUESEC:DW	0		;Physical sector that contains CP/M sector
 B73A 00        ERROR:	DB	0		;Buffer's error status flag
 B73B 00        BUFDRV:	DB	0		;Drive that buffer belongs to
 B73C 0000      BUFTRK:	DW	0		;Track that buffer belongs to
 B73E 0000      BUFSEC:	DW	0		;Sector that buffer belongs to
 B740 0000      ALTTRK:	DW	0		;Alternate track
 B742 0000      ALTSEC:	DW	0		;Alterante sector
 B744 00        LASTDRV:DB	0		;Last selected drive
                ;***************************************************************;
                ;								;
                ; DPB and DPH area.						;
                ;								;
                ;***************************************************************;
                	IF	MAXHD NE 0
                DPHDSK	SET	0		;Generate DPH's for the HDCA hard disks
                	REPT	MAXHD
                LDSK	SET	0
                	REPT	HDLOG
                	DPHGEN	HD,%DPHDSK,DPBHD,%LDSK
                LDSK	SET	LDSK+1
                DPHDSK	SET	DPHDSK+1
                	ENDM
                	ENDM
                	IF	M26 NE 0
                DPBHD0:	DW	1024		;CP/M sectors/track
                	DB	5		;BSH
                	DB	31		;BLM
                	DB	1		;EXM
                	DW	2015		;DSM
                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	1		;OFF
                	DB	3		;SECSIZ
                DPBHD1:	DW	1024		;CP/M sectors/track
                	DB	5		;BSH
                	DB	31		;BLM
                	DB	1		;EXM
                	DW	2015		;DSM
CP/M MACRO ASSEM 2.0	#085	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	64		;OFF
                	DB	3		;SECSIZ
                DPBHD2:	DW	1024		;CP/M sectors/track
                	DB	5		;BSH
                	DB	31		;BLM
                	DB	1		;EXM
                	DW	2047		;DSM
                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	127		;OFF
                	DB	3		;SECSIZ
                	ENDIF
                	IF	M10 NE 0
                DPBHD0:	DW	336		;CP/M sectors/track
                	DB	5		;BSH
                	DB	31		;BLM
                	DB	1		;EXM
                	DW	1269		;DSM
                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	1		;OFF
                	DB	3		;SECSIZ
                DPBHD1:	DW	336		;CP/M sectors/track
                	DB	5		;BSH
                	DB	31		;BLM
                	DB	1		;EXM
                	DW	1280		;DSM
                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	122		;OFF
                	DB	3		;SECSIZ
                	ENDIF
                	IF	M20 NE 0
                DPBHD0:	DW	672		;CP/M sectors/track
                	DB	5		;BSH
                	DB	31		;BLM
                	DB	1		;EXM
                	DW	2036		;DSM
                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	1		;OFF
                	DB	3		;SECSIZ
                DPBHD1:	DW	672		;CP/M sectors/track
                	DB	5		;BSH
CP/M MACRO ASSEM 2.0	#086	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	DB	31		;BLM
                	DB	1		;EXM
                	DW	2036		;DSM
                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	98		;OFF
                	DB	3		;SECSIZ
                DPBHD2:	DW	672		;CP/M sectors/track
                	DB	5		;BSH
                	DB	31		;BLM
                	DB	1		;EXM
                	DW	1028		;DSM
                	DW	511		;DRM
                	DB	0FFH		;AL0
                	DB	0FFH		;AL1
                	DW	0		;CKS
                	DW	195		;OFF
                	DB	3		;SECSIZ
                	ENDIF
                	ENDIF			;End of HD DPH's and DPB's
                ; DPH's for DJ2DB
                ;----------------
                ;
                	IF	MAXFD NE 0
                DN	SET	0
                	REPT	MAXFD
                	DPHGEN	FD,%DN,0,0
                DN	SET	DN+1
                	ENDM
                	ENDIF
                	IF	MAXMW NE 0
                ;***************************************************************;
                ;								;
                ; mwsectp is the number of 128 byte sectors per cylinder.	;
                ; mwsectp = 72 * heads						;
                ;								;
                ; mwtrks is the total number of data cylinders.			;
                ; mwtrks = tracks - 1						;
                ;								;
                ;***************************************************************;
                	IF	ST506 NE 0
                	MWSECPT	EQU	288		;Sectors per track
                	MWTRKS	EQU	152		;Total data tracks
                	ENDIF
                	IF	ST412 NE 0
                	MWSECPT	SET	288
                	MWTRKS	SET	305
                	ENDIF
                	IF	CM5619 NE 0
                	MWSECPT	SET	432
                	MWTRKS	SET	305
                	ENDIF
                DPHDSK	SET	0		;Generate DPH's for the HDDMA hard disks
                	REPT	MAXMW
CP/M MACRO ASSEM 2.0	#087	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                LDSK	SET	0
                	REPT	MWLOG
                	DPHGEN	MW,%DPHDSK,DPBMW,%LDSK
                DPHDSK	SET	DPHDSK+1
                LDSK	SET	LDSK+1
                	ENDM
                	ENDM
                OFF	SET	1			;Initial system track offset
                TRKOFF	SET	8192/(MWSECPT/8)+1	;The number of tracks in a partition
                BLOCKS	SET	MWSECPT/8*MWTRKS	;The number of blocks on the drive
                PSIZE	SET	TRKOFF*(MWSECPT/8)	;The number of blocks in a partition
                LDSK	SET	0
                	REPT	BLOCKS/8192	;Generate some 8 megabyte DPB's
                	DPBGEN	MW,%LDSK,%MWSECPT,5,31,1,2047,1023,0FFH,0FFH,0,%OFF,4
                OFF	SET	OFF+TRKOFF
                BLOCKS	SET	BLOCKS-PSIZE
                LDSK	SET	LDSK+1
                	ENDM
                BLOCKS	SET	BLOCKS/4
                	IF	BLOCKS GT 256	;If there is any stuff left, then use it
                BLOCKS	SET	BLOCKS-1
                	DPBGEN	MW,%LDSK,%MWSECPT,5,31,1,%BLOCKS,1023,0FFH,0FFH,0,%OFF,4
                	ENDIF
                	ENDIF
                ;*********************************************************
                ;Begin Definitions for the Console and List Device Drivers
                ;*********************************************************
                ;
                ;Define Printer Character Constants
                ;----------------------------------
 000D =         ACR	EQU	0DH		;Carriage return
 000A =         ALF	EQU	0AH		;Line Feed
 001A =         CLEAR	EQU	1AH		;Clear screen on an ADM 3
 0013 =         XOFF	EQU	13H		;Xoff character
 0011 =         XON	EQU	11H		;Xon character
                	IF	(CONTYP EQ 2) OR (LSTTYP GE 2)	;Multio or Wunderbuss
                ;Multio/Wunderbuss Equates
                ;-------------------------
                ;	The following equates will define the Decision I mother
                ;	board I/O or the Multi I/O environments if needed.
                ;
                ;Location Definitions
                ;--------------------
 0048 =         MBASE	EQU	48H		;Base address of Multi I/O or Decision I
 0048 =         RBR	EQU	MBASE		;Read data buffer
 0048 =         THR	EQU	MBASE		;Tranmitter data buffer
 0048 =         DLL	EQU	MBASE		;Divisor (lsb)
 0048 =         STROBE	EQU	MBASE		;parallel port strobe out
 0048 =         STATUS	EQU	MBASE		;parallel port status in
 0049 =         DLM	EQU	MBASE+1		;Divisor (msb)
 0049 =         IER	EQU	MBASE+1		;Interupt enable register
 0049 =         SENSESW	EQU	MBASE+1		;Sense switches, only in gp 06
 0049 =         DATA	EQU	MBASE+1		;parallel port data buffer
 004A =         CLK	EQU	MBASE+2		;WB14 printer select port
 004B =         LCR	EQU	MBASE+3		;Line control register
 004C =         MCR	EQU	MBASE+4
CP/M MACRO ASSEM 2.0	#088	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 004D =         LSR	EQU	MBASE+5		;Line status register
 004E =         MSR	EQU	MBASE+6
 004F =         GRPSEL	EQU	MBASE+7		;Group select port
                ;
                ;Define Transmitter/Reciever Mask Bytes
                ;--------------------------------------
 0001 =         DR	EQU	01H		;Line status DR bit
 0010 =         CTS	EQU	10H		;Clear to send
 0020 =         DSR	EQU	20H		;Data set ready
 0020 =         THRE	EQU	20H		;Status line THRE bit
 0080 =         DLAB	EQU	80H		;Divisor latch access bit
                ;
 0001 =         WLS0	EQU	1		;Word length select bit 0
 0002 =         WLS1	EQU	2		;Word length select bit 1 for 8 bit word
 0004 =         STB	EQU	4		;Stop bit count - 2 stop bits
                ;
                ; Define Modem Control Register bits
                ;-----------------------------------
 0001 =         DTRENB	EQU	1		;DTR enable
 0002 =         RTSENB	EQU	2		;RTS enable
                ;
                ;Define group select Masks
                ;-------------------------
 0000 =         SPP	EQU	0		;select parallel port
 0001 =         S0	EQU	01H		;Group number (0-3)
 0002 =         S1	EQU	02H
 0003 =         SMASK	EQU	03H
 0004 =         BANK	EQU	04H
 0008 =         ENINT	EQU	08H
 0010 =         RESTOR	EQU	10H		;Printer restore on Multi I/O
 0020 =         BUSY	EQU	20H		;parallel printer busy mask
 0020 =         DENABLE	EQU	20H		;Driver enable on Multi I/O
                ;
                ;Group Port Assignments
                ;----------------------
 0001 =         CONGRP	EQU	1		;Console port (1=p1, 2=p2, 3=p3)
 0003 =         LSTGRP	EQU	3		;Printer port (1=p1, 2=p2, 3=p3)
                	ENDIF			;For Multio/Wunderbuss Definitions
                	PAGE
CP/M MACRO ASSEM 2.0	#089	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;****************************
                ;Begin Console Device Drivers
                ;****************************
                	IF	CONTYP EQ 0
                ;************************
                ;Begin Prom Patch (CDRV0)
                ;************************
                ;	This driver simply defines the four jumps normally needed to get to
                ;	your actual console drivers. The assumption is that you already have
                ;	these drivers in a ROM; And, furthermore, that the ROM'ed drivers
                ;	exactly match the specs given in the CPM alteration guide for CONIN,
                ;	CONOUT and CONST. Conint is involked during the cold boot process.
                ;
                CONIN:	JMP	$		;Console input
                CONOUT:	JMP	$		;Console output
                CONST:	JMP	$		;Console input status
                CONINT:	JMP	$		;Console initialization
                	ENDIF			;End of Prom Patch Console Routines
                	IF	CONTYP EQ 1
                ;***********************************
                ;Begin Patch Area (128 byte) (CDRV1)
                ;***********************************
                ;	This driver provides you with a 128 byte area for patching in your
                ;	own i/o routines. This first 12 bytes are taken up by jumps to the
                ;	appropriate routines (CONIN, CONOUT and CONST). See the CPM user
                ;	reference manual section on system alteration for a description of
                ;	these routines and the parameter passing conventions.
                ;
                ;	The console initialization routine (conint) is usually placed
                ;	just after the cold boot loader.
                ;
                CONIN:	JMP	$			;Console input
                CONOUT:	JMP	$			;Console output
                CONST:	JMP	$			;Console input status
                CONINT:	JMP	$			;Console initialization
                	DS	116			;(reserve the remaining space)
                	ENDIF				;End of Patch Area Console Routines
                	IF	CONTYP EQ 2
                ;****************************************************
                ;Begin Multi I/O or Decision I Console Driver (CDRV2)
                ;****************************************************
                ;	1) This driver on cold boot will inspect bits 1-3 of the sense
                ;	   switches.  If the value found is in the range 0-6 then the
                ;	   console baud rate will be taken from the rate table.  Otherwise
                ;	   the baud rate will be set from the DEFCON word which is found
                ;	   just below the regular Cbios jump table.  The standard divisor
                ;	   table is given below.
                ;
                ;		Sense switch: 123  (0 = off, 1 = on)
                ;			000 = 110
                ;			001 = 300
                ;			010 = 1200
                ;			011 = 2400
                ;			100 = 4800
                ;			101 = 9600
CP/M MACRO ASSEM 2.0	#090	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;			110 = 19200
                ;		     defcon = 9600
                ;
                ;	2) If you are using a Multio then the switches will not be
                ;	   available so the baud rate will be taken from DEFCON.
                ;	
                ;Console input
                ;-------------
                ;
 B745 00        	DB	0		;used by swap.com
 B746 CD5EB7    CONIN:	CALL	CONST		;select console and test for char
 B749 CA46B7    	JZ	CONIN
 B74C DB48      	IN	RBR		;Read character
 B74E E67F      	ANI	7FH		;Strip parity
 B750 C9        	RET
                 
                ;Console Output
                ;--------------
                ;
 B751 01        	DB	1		;used by swap.com
 B752 CD69B7    CONOUT:	CALL	CONOST		;Select console and test status
 B755 CA52B7    	JZ	CONOUT
 B758 79        	MOV	A,C		;Character is in (c)
 B759 E67F      	ANI	7FH
 B75B D348      	OUT	THR		;Output to transmitter buffer
 B75D C9        	RET
                ;Console Status
                ;--------------
                ;	1) Returns zero if character is not ready to be read; Otherwise,
                ;	   this routine returns 255 indicating a ready condition.
                ;
 B75E CD74B7    CONST:	CALL	SELCON		;Select console
 B761 DB4D      	IN	LSR		;Read status register
 B763 E601      	ANI	DR
 B765 C8        	RZ			;No charactter ready
 B766 3EFF      	MVI	A,0FFH		;Character ready
 B768 C9        	RET
                ;Console Output Status Routine
                ;-----------------------------
                ;
 B769 CD74B7    CONOST:	CALL	SELCON
 B76C DB4D      	IN	LSR
 B76E E620      	ANI	THRE
 B770 C8        	RZ
 B771 3EFF      	MVI	A,0FFH
 B773 C9        	RET
                ;Console Select Routine
                ;----------------------
                ;
 B774 11BAAD    SELCON:	LXI	D,GROUP		;pass to application
 B777 1A        	LDAX	D
 B778 F601      	ORI	CONGRP
 B77A D34F      	OUT	GRPSEL
 B77C C9        	RET
                	ENDIF			;End of Multio/Wunderbuss Console Driver
                	IF	CONTYP EQ 3
CP/M MACRO ASSEM 2.0	#091	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;**********************************
                ;Begin DJ2DB Console Driver (CDRV3)
                ;**********************************
                ;
                ;Console Input
                ;-------------
                ;
                CONIN:	JMP	FDCIN		;Console input
                ;Console Output
                ;--------------
                ;
                CONOUT:	MOV	A,C
                	ANI	7FH
                	MOV	C,A
                	JMP	FDCOUT		;Console output
                ;Console Status
                ;--------------
                ;
                CONST:	CALL	FDTSTAT		;Console status
                	MVI	A,0FFH
                	RZ
                	INR	A
                	RET
                	ENDIF			;End of DJ2DB Console Driver
                	IF	CONTYP EQ 4
                ;**********************************
                ;Begin DJDMA Console Driver (CDRV4)
                ;**********************************
                ;
                ;Console Input
                ;-------------
                ;
                CONIN:	LXI	H,SERIN+1	;Serial input status
                	XRA	A
                CI2:	CMP	M		;Wait till 40h deposited at 3fH
                	JZ	CI2
                	MOV	M,A		;Clear status
                	DCX	H		;Point to input data
                	MVI	A,7FH		;For masking out parity
                	ANA	M
                	RET
                ;Console Output
                ;--------------
                ;
                CONOUT:	LXI	H,DMCHOT+1	;Character output location
                	MOV	A,C
                	ANI	7FH
                	MOV	M,A		;store character in command
                	DCX	H		;Back up to start of command
                	LXI	D,4		;offset to returned status
                	CALL	DMDOIT		;Write a character
                	RET
                ;Console Status
                ;--------------
                ;
                CONST:	LDA	SERIN+1		;Pick up serial input status
CP/M MACRO ASSEM 2.0	#092	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	ORA	A
                	RZ			;If zero then no character ready
                	MVI	A,0FFH		;Set character ready
                	RET
                ;DJDMA Command Strings For Console I/O
                ;-------------------------------------
                ;
                DMCHOT:	DB	SEROUT		;Serial output command
                	DB	0		;The character to be output
                	DB	0		;dummy status
                	DB	DMHALT		;Halt Command
                	DB	0		;returned status
                	ENDIF			;End of DJDMA Console Driver
                	IF	CONTYP EQ 5
                ;****************************************
                ;Begin Switchboard Console Driver (CDRV5)
                ;****************************************
                ;
                ;Swithboard Equates
                ;------------------
                ;
                SWBASE	EQU	0		;Base of the SWITCHBOARD
                ;Console Input
                ;-------------
                ;
                CONIN:	IN	SWBASE+2	;Get switchboard status
                	ANI	4		;Test for data ready
                	JZ	CONIN
                	IN	SWBASE		;Get a character
                	ANI	7FH		;Strip off parity
                	RET
                ;Console Output
                ;--------------
                ;
                CONOUT:	IN	SWBASE+2	;Check status
                	ANI	8		;Wait till output buffer empty
                	JZ	CONOUT
                	MOV	A,C		;Write a character
                	ANI	7FH
                	OUT	SWBASE
                	RET
                ;Console Status
                ;--------------
                ;
                CONST:	IN	SWBASE+2	;Get the first ports status
                	ANI	4		;Mask the data ready bits
                	RZ			;Return console not ready
                	MVI	A,0FFH
                CONINT:	RET			;NULL terminal initialization
                	ENDIF			;End of Switchboard Console Driver
                	IF	CONTYP EQ 6
                ;***************************************
                ;Begin North Star Console Driver (CDRV6)
                ;***************************************
                ;
                ;General Information
CP/M MACRO ASSEM 2.0	#093	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;===================
                ;	The following code implements the North Star console I/O system.
                ;	This system is for users who purchase a Morrow Designs disk
                ;	system to replace their North Star disk system.  The Mapping of
                ;	the logical to physical entry points is performed as follows:
                ;
                ;	Device name		Left	Right	Parallel
                ;				serial	serial	port
                ;
                ;		Console	CON: =	TTY:	CRT:	UC1:
                ;		Reader	RDR: =	TTY:	PTR:	UR1:
                ;		Punch	PUN: =	TTY:	PTP:	UP1:
                ;		List	LST: =	TTY:	CRT:	UL1:
                ;
                ;	For example, to use a printer connected to the right serial port,
                ;	use the CP/M command:
                ;
                ;		STAT LST:=CRT:
                ;
                ;	Likewise, the CP/M command "STAT LST:=UL1:" is used if you have a
                ;	printer connected to the parallel port.
                ;
                ;North Star Equates
                ;==================
                ;
                NSLDAT	EQU	2		;Left serial port data port
                NSLSTA	EQU	3		;Left serial port status port
                NSRDAT	EQU	4		;Right serial port data port
                NSRSTA	EQU	5		;Right serial port status port
                NSSTBE	EQU	1		;Transmitter buffer empty status bit
                NSSRBR	EQU	2		;Reciever buffer ready status bit
                				;See the 8251 data sheets for more
                				;   configuration information.
                NSLIN1	EQU	0CEH		;Left serial port initialization # 1
                NSRIN1	EQU	0CEH		;Right serial port initialization # 1
                				;76543210 Bit definations
                				;11001110 Default configuration
                				;xxxxxx00 Synchronous mode
                				;xxxxxx01 1X clock rate
                				;xxxxxx10 16X clock rate
                				;xxxxxx11 64X clock rate
                				;xxxx00xx 5 bit characters
                				;xxxx01xx 6 bit characters
                				;xxxx10xx 7 bit characters
                				;xxxx11xx 8 bit characters
                				;xxx0xxxx Parity disbable
                				;xxx1xxxx Parity enable
                				;xx0xxxxx Odd parity generation/check
                				;xx1xxxxx Even parity generation/check
                				;00xxxxxx Invalid
                				;01xxxxxx 1 stop bit
                				;10xxxxxx 1.5 stop bits
                				;11xxxxxx 2 stop bits
                NSLIN2	EQU	37H		;Left serial port initialization # 2
                NSRIN2	EQU	37H		;Right serial port initialization # 2
                				;76543210 Bit definations
CP/M MACRO ASSEM 2.0	#094	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                				;00110111 Default configuration
                				;xxxxxxx1 Enable transmitter
                				;xxxxxx1x Assert DTR;
                				;xxxxx1xx Enable reciever
                				;xxxx1xxx Send break character, TxD low
                				;xxx1xxxx Reset PE, OE, FE error flags
                				;xx1xxxxx Assert RTS;
                				;x1xxxxxx Internal reset
                				;1xxxxxxx Enter hunt mode (for sync)
                NSPDAT	EQU	0		;Parallel data port
                NSPSTA	EQU	6		;Parallel status port
                NSPRBR	EQU	1		;Reciever buffer ready status bit
                NSPTBE	EQU	2		;Transmitter buffer empty status bit
                NSRAM	EQU	0C0H		;North Star memory parity port,
                				;   set to 0 for no North Star RAM
                ;North Star IOBYTE Implementation
                ;================================
                ;	The following code performs the mapping of logical to physical
                ;	serial I/O devices.  The physical entry points are CONIN, CONOUT,
                ;	CONIST, RDRIN, PUNOUT, LSTOUT, and LSTOST.  These entry points
                ;	are mapped via the Intel standard I/O byte (IOBYTE) at location 3
                ;	in the base page to the low level device drivers.
                ;
                ;	Note:  A naming convention has been chosen to reduce label
                ;	colisions.  The first three characters of a name indicate the
                ;	device drivers name, the following three characters indicated the
                ;	function performed by that particular device routine.  The device
                ;	names are defined and described in the "An Introduction to CP/M
                ;	Features and Facilities" manual in the section on the STAT
                ;	command and in the "CP/M Interface Guide" in the IOBYTE section.
                ;	The device function postfixes are as follows.
                ;
                ;		devSET	Initial device setup and initialzation
                ;		devIN	Read one character from the device
                ;		devOUT	Write one character to the device
                ;		devIST	Return the device character input ready status
                ;		devOST	Return the device character output ready status
                ;
                ;	The setup routine initializes the device and returns.  The input
                ;	routine returns one character in the A register (parity reset).
                ;	The output routine write one character from the C register.  The
                ;	input status routine returns in the A register a 0 if the device
                ;	does not have a character ready for input for 0ffh if a character
                ;	is ready for input.  The output status routine returns in the A
                ;	register a 0 if the device is not ready accept a character and a
                ;	0ffh if the device is ready.  The input and output routines
                ;	should wait untill the device is ready for the desired operation
                ;	before the doing the operation and returning.
                ;
                ;	Not all of these functions need to be implemented for all the
                ;	devices.  The following is a table of the entry points needed for
                ;	each device handler.
                ;
                ;		device	setup	input	output	input	output
                ;		name				status	status
                ;
CP/M MACRO ASSEM 2.0	#095	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;		CON:		CONIN	CONOUT	CONIST
                ;		RDR:		RDRIN		RDRIST
                ;		PUN:			PUNOUT
                ;		LST:			LSTOUT		LSTOST
                ;
                ;		TTY:	TTYSET	TTYIN	TTYOUT	TTYIST	TTYOST
                ;		CRT:	CRTSET	CRTIN	CRTOUT	CRTIST	CRTOST
                ;		UC1:	UC1SET	UC1IN	UC1OUT	UC1IST
                ;
                ;		PTR:	PTRSET	PTRIN		PTRIST
                ;		UR1:	UR1SET	UR1IN		UR1IST
                ;		UR2:	UR2SET	UR2IN		UR2IST
                ;
                ;		PTP:	PTPSET		PTPOUT
                ;		UP1:	UP1SET		UP1OUT
                ;		UP2:	UP2SET		UP2OUT
                ;
                ;		LPT:	LPTSET		LPTOUT		LPTOST
                ;		UL1:	UL1SET		UL1OUT		UL1OST
                ;
                ;	The CONIN, CONOUT, CONIST, RDRIN, RDRIST, PUNOUT, LSTOUT, and
                ;	LSTOST routines are the logical device driver entry points
                ;	provided by this device mapper.  The other entry names must be
                ;	provided by the physical device drivers.
                ;
                ;Console Input
                ;-------------
                ;
                CONIN:	MVI	E,1			;Console input
                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYIN			;CON: = TTY:	xxxxxx00
                	DW	CRTIN			;CON: = CRT:	xxxxxx01
                	DW	RDRIN			;CON: = BAT:	xxxxxx10
                	DW	UC1IN			;CON: = UC1:	xxxxxx11
                ;Console Output
                ;--------------
                ;
                CONOUT:	MVI	E,1			;Console output
                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYOUT			;CON: = TTY:	xxxxxx00
                	DW	CRTOUT			;CON: = CRT:	xxxxxx01
                	DW	LSTOUT			;CON: = BAT:	xxxxxx10
                	DW	UC1OUT			;CON: = UC1:	xxxxxx11
                ;Console Status
                ;--------------
                ;
                CONST:	MVI	E,1			;Console input status
                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYIST			;CON: = TTY:	xxxxxx00
                	DW	CRTIST			;CON: = CRT:	xxxxxx01
                	DW	RDRIST			;CON: = BAT:	xxxxxx10
                	DW	UC1IST			;CON: = UC1:	xxxxxx11
                ;Reader Input
                ;------------
                ;
                RDRIN:	MVI	E,7			;Reader input
CP/M MACRO ASSEM 2.0	#096	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYIN			;RDR: = TTY:	xxxx00xx
                	DW	PTRIN			;RDR: = PTR:	xxxx01xx
                	DW	UR1IN			;RDR: = UR1:	xxxx10xx
                	DW	UR2IN			;RDR: = UR2:	xxxx11xx
                ;Reader Status
                ;-------------
                ;
                RDRIST:	MVI	E,7			;Reader input status
                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYIST			;RDR: = TTY:	xxxx00xx
                	DW	PTRIST			;RDR: = PTR:	xxxx01xx
                	DW	UR1IST			;RDR: = UR1:	xxxx10xx
                	DW	UR2IST			;RDR: = UR2:	xxxx11xx
                ;Punch Output
                ;-----------
                ;
                PUNOUT:	MVI	E,5			;Punch output
                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYOUT			;PUN: = TTY:	xx00xxxx
                	DW	PTPOUT			;PUN: = PTP:	xx01xxxx
                	DW	UP1OUT			;PUN: = UP1:	xx10xxxx
                	DW	UP2OUT			;PUN: = UP2:	xx11xxxx
                ;List Output
                ;-----------
                ;
                LSTOUT:	MVI	E,3			;List output
                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYOUT			;LST: = TTY:	00xxxxxx
                	DW	CRTOUT			;LST: = CRT:	01xxxxxx
                	DW	LPTOUT			;LST: = LPT:	10xxxxxx
                	DW	UL1OUT			;LST: = UL1:	11xxxxxx
                ;List Status
                ;-----------
                ;
                LSTOST:	MVI	E,3			;List output status
                	CALL	REDIR			;	IOBYTE:	76543210
                	DW	TTYOST			;LST: = TTY:	00xxxxxx
                	DW	CRTOST			;LST: = CRT:	01xxxxxx
                	DW	LPTOST			;LST: = LPT:	10xxxxxx
                	DW	UL1OST			;LST: = UL1:	11xxxxxx
                ;Redirect the I/O
                ;----------------
                ;
                REDIR:	LDA	IOBYTE			;Get the INTEL standard iobyte
                REDIR0:	RLC				;Shift the next field in
                	DCR	E			;Bump the shift count
                	JNZ	REDIR0
                REDIR1:	ANI	110B			;Mask the redirection field
                	MOV	E,A			;Make the word table offset
                	MVI	D,0
                	POP	H			;Get the table base
                	DAD	D			;Offset into our table
                	MOV	A,M			;Load the low level i/o routine pointer
                	INX	H
                	MOV	H,M
CP/M MACRO ASSEM 2.0	#097	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	MOV	L,A
                	PCHL				;Execute the low level i/o driver
                ;Left serial port routines.  Use TTY: device.
                ;--------------------------------------------
                ;
                TTYIN:	IN	NSLSTA			;Read a character
                	ANI	NSSRBR
                	JZ	TTYIN			;Wait till a character is ready
                	IN	NSLDAT			;Get the character
                	ANI	7FH			;Strip parity
                	RET
                TTYOUT:	IN	NSLSTA			;Write a character
                	ANI	NSSTBE
                	JZ	TTYOUT			;Wait till the buffer is empty
                	MOV	A,C			;Write the character
                	ANI	7FH
                	OUT	NSLDAT
                	RET
                TTYIST:	IN	NSLSTA			;Return input buffer status
                	ANI	NSSRBR
                	RZ				;Return not ready
                	MVI	A,0FFH
                	RET				;There is a character ready
                TTYOST:	IN	NSLSTA			;Return output buffer status
                	ANI	NSSTBE
                	RZ				;Return not ready
                	MVI	A,0FFH
                	RET				;Return ready
                ;Right serial port routines.  Use CRT:, PTR:, and PTP: devices.
                ;--------------------------------------------------------------
                ;
                CRTIN:
                PTRIN:	IN	NSRSTA			;Read a character
                	ANI	NSSRBR
                	JZ	CRTIN			;Wait till a character is ready
                	IN	NSRDAT			;Get the character
                	ANI	7FH			;Strip parity
                	RET
                CRTOUT:
                PTPOUT:	IN	NSRSTA			;Write a character
                	ANI	NSSTBE
                	JZ	CRTOUT			;Wait till the buffer is empty
                	MOV	A,C			;Write the character
                	ANI	7FH
                	OUT	NSRDAT
                	RET
                CRTIST:
                PTRIST:	IN	NSRSTA			;Return input buffer status
                	ANI	NSSRBR
                	RZ				;Return not ready
                	MVI	A,0FFH
                	RET				;There is a character ready
                CRTOST:	IN	NSRSTA			;Return output buffer status
                	ANI	NSSTBE
                	RZ				;Return not ready
                	MVI	A,0FFH
CP/M MACRO ASSEM 2.0	#098	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	RET				;Return ready
                ;Parallel Port Routines
                ;----------------------
                ;	Use UC1: UR1: UP1: UP2: LPT: and UL1: devices.
                ;
                UC1IN:
                UR1IN:
                UR2IN:	IN	NSPSTA			;Read a character
                	ANI	NSPRBR
                	JZ	UC1IN			;Wait till a character is ready
                	IN	NSPDAT			;Get the character
                	PUSH	PSW
                	MVI	A,30H			;Reset the parallel input flag
                	OUT	NSPSTA
                	POP	PSW
                	ANI	7FH			;Strip parity
                	RET
                UC1OUT:
                UP1OUT:
                UP2OUT:
                LPTOUT:
                UL1OUT:	IN	NSPSTA			;Write a character
                	ANI	NSPTBE
                	JZ	UC1OUT			;Wait till the buffer is empty
                	MVI	A,20H			;Reset the parallel output flag
                	OUT	NSPSTA
                	MOV	A,C			;Write the character, strobe bit 7
                NSPOUT:	ORI	80H
                	OUT	NSPDAT
                	ANI	7FH
                	OUT	NSPDAT
                	ORI	80H
                	OUT	NSPDAT
                	RET
                UC1IST:
                UR1IST:
                UR2IST:	IN	NSPSTA			;Return input buffer status
                	ANI	NSPRBR
                	RZ				;Return not ready
                	MVI	A,0FFH
                	RET				;Return ready
                LPTOST:		
                UL1OST:	IN	NSPSTA			;Return output buffer status
                	ANI	NSPTBE
                	RZ				;Return not ready
                	MVI	A,0FFH
                	RET				;Return ready
                	ENDIF				;North Star I/O configuration
                	PAGE
CP/M MACRO ASSEM 2.0	#099	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;*************************
                ;Begin List Device Drivers
                ;*************************
                ;
                	IF	LSTTYP EQ 0
                ;*******************************
                ;Begin Prom Patch Driver (LDRV0)
                ;*******************************
                ;	The driver entries LSTOUT and LSTOST are defined in the CP/M
                ;	alternation guide (e.g.  Input parameters are in register C and
                ;	results are returned in register A). The LSTSET routine is used
                ;	for initialization code. It should execute a RET when complete.
                ;
                ;	The LSTSET routine could be placed just below the CBOOT routine.
                ;	This space (below CBOOT) is recyled for use as a disk buffer
                ;	after CBOOT is done.
                ;
                ;	These routines all point to lstskp initially so that the system
                ;	won't hang up, waiting for a non-existant list device to become
                ;	ready.
                ;
                LSTOUT:	JMP	LSTSKP		;Printer output
                LSTOST:	JMP	LSTSKP		;Printer output status
                LSTSET:	JMP	LSTSKP		;Printer initialization
                LSTSKP:	RET
                	ENDIF			;End of Patch Area for List Drivers
                	IF	LSTTYP EQ 1
                ;*******************************************
                ;Begin Patch Area Driver (128 bytes) (LDRV1)
                ;*******************************************
                ;	The driver entries LSTOUT and LSTOST are defined in the CP/M
                ;	alternation guide (e.g.  Input parameters are in register C and
                ;	results are returned in register A). The LSTSET routine is used
                ;	for initialization code. It should execute a RET when complete.
                ;
                ;	The LSTSET routine could be placed just below the CBOOT routine.
                ;	This space (below CBOOT) is recyled for use as a disk buffer
                ;	after CBOOT is done.
                ;
                ;	These routines all point to lstskp initially so that the system
                ;	won't hang up, waiting for a non-existant list device to become
                ;	ready.
                ;
                LSTOUT:	JMP	LSTSKP		;Printer output
                LSTOST:	JMP	LSTSKP		;Printer output status
                LSTSET:	JMP	LSTSKP		;Printer initialization
                LSTSKP:	RET
                	DS	118		;(reserve the remaining space)
                	ENDIF			;End of Patch Area for List Drivers
                	IF	(LSTTYP GE 2) AND (LSTTYP LE 5)
                ;*****************************************************
                ;Begin Other List Devices (LDRV2, LDRV3, LDRV4, LDRV5)
                ;*****************************************************
                ;	All other list devices are Multio/Wunderbuss Serial I/O With
                ;	different types of i/o protocols.
CP/M MACRO ASSEM 2.0	#100	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;	Altered rev E4, lsttyp 2 thru 5 always include centronics punch
                ;	NOTE: first instruction in output routine must be call to status
                ;	so swap program can re-assign list status routine.
                ;	Also, the pointer to the device name string must be just ahead of
                ;	the entry point
                ;
                ;List Output
                ;-----------
 B77D 02        	DB	2		;used by swap.com
                ;
 B77E CD89B7    LSTOUT:	CALL	LSTOST		;Check printer status
 B781 B7        	ORA	A
 B782 CA7EB7    	JZ	LSTOUT		;Loop if not ready
 B785 79        	MOV	A,C		;Print the character
 B786 D348      	OUT	THR
 B788 C9        	RET
                ;List Status
                ;-----------
                ;
 B789 CDB3B7    LSTOST:	CALL	SELLST		;Printer status routine
 B78C DB4D      	IN	LSR		;Check if transmitter buffer empty
 B78E E620      	ANI	THRE
 B790 C8        	RZ			;Return busy if buffer is not empty
 B791 2ABFAD    	LHLD	LSTAND		;Fetch handshake mask bits
 B794 DB4E      	IN	MSR		;Get MODEM Status Register
 B796 A5        	ANA	L		;Strip out hand-shake lines
 B797 AC        	XRA	H		;Invert status
 B798 C8        	RZ			;Return busy if printer is busy
 B799 3AC1AD    	LDA	LASTCH		;Get last character recieved from the printer
 B79C 47        	MOV	B,A
 B79D DB4D      	IN	LSR		;Check for a character from the printer
 B79F E601      	ANI	DR
 B7A1 CAACB7    	JZ	XSKIP		;Skip if no character present
 B7A4 DB48      	IN	RBR		;Get the character
 B7A6 E67F      	ANI	7FH		;Strip parity
 B7A8 32C1AD    	STA	LASTCH		;Save last character recieved
 B7AB 47        	MOV	B,A
 B7AC 78        XSKIP:	MOV	A,B
 B7AD D613      	SUI	XOFF		;Check for Xoff char (control S)
 B7AF C2BCB7    	JNZ	XSDONE		;Printer ready
 B7B2 C9        	RET			;Printer not ready (return zero)
                ;Group select routines
                ;---------------------
                ;
 B7B3 11BAAD    SELLST:	LXI	D,GROUP		;pass to application
 B7B6 1A        	LDAX	D		;Select printer group
 B7B7 F603      	ORI	LSTGRP
 B7B9 D34F      	OUT	GRPSEL
 B7BB C9        	RET
 B7BC 3EFF      XSDONE:	MVI	A,0FFH		;Printer ready for data
 B7BE C9        	RET
                ;Reader Input
                ;-----------
                ;
 B7BF 04        	DB	4		;used by swap.com
                RDRIN:
CP/M MACRO ASSEM 2.0	#101	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B7C0 CDCBB7    	CALL	RDRIST
 B7C3 CAC0B7    	JZ	RDRIN		;wait for char avail
 B7C6 DB48      	IN	RBR		;get data
 B7C8 E67F      	ANI	7FH
 B7CA C9        	RET
                RDRIST:
 B7CB CDB3B7    	CALL	SELLST		;it's the list device kiddies
 B7CE DB4D      	IN	LSR		;check for char
 B7D0 E601      	ANI	DR		;data ready?
 B7D2 C8        	RZ			;exit false
 B7D3 3EFF      	MVI	A,0FFH		;true
 B7D5 C9        	RET
                ;Punch Output
                ;-----------
 B7D6 03        	DB	3		;used by swap.com
                ;
 B7D7 CD00B8    PUNOUT:	CALL	PUNOST		;select group zero, sensesw
 B7DA CAD7B7    	JZ	PUNOUT
 B7DD DB49      	IN	SENSESW		;read motherboard switches
 B7DF FEFF      	CPI	0FFH		;FF means Multio
 B7E1 CAF2B7    	JZ	PMULT
 B7E4 79        	MOV	A,C		;Print the character
 B7E5 D349      	OUT	DATA
 B7E7 3EBF      	MVI	A,0BFH
 B7E9 D348      	OUT	STROBE		;strobe low (asserted)
 B7EB E3        	XTHL
 B7EC E3        	XTHL			;stall 10 us
 B7ED 3EFF      	MVI	A,0FFH
 B7EF D348      	OUT	STROBE		;strobe high (inactive)
 B7F1 C9        	RET
 B7F2 79        PMULT:	MOV	A,C		;Print the character
 B7F3 D348      	OUT	STROBE		;really 'data'
 B7F5 3EBF      	MVI	A,0BFH
 B7F7 D349      	OUT	DATA		;strobe low (asserted) (really strobe)
 B7F9 E3        	XTHL
 B7FA E3        	XTHL			;stall 10 us
 B7FB 3EFF      	MVI	A,0FFH
 B7FD D349      	OUT	DATA		;strobe high (inactive)	(really strobe)
 B7FF C9        	RET
                ;Punch Status
                ;-----------
                ;
 B800 11BAAD    PUNOST:	LXI	D,GROUP		;pass to application
 B803 1A        	LDAX	D
 B804 D34F      	OUT	GRPSEL		;select parallel printer group
 B806 DB48      	IN	STATUS
 B808 E620      	ANI	BUSY
 B80A C8        	RZ			;Return busy if buffer is not empty
 B80B 3EFF      	MVI	A,0FFH
 B80D C9        	RET			;return not busy
                	ENDIF			;Multio Wbio Serial Drivers
                	PAGE
CP/M MACRO ASSEM 2.0	#102	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;************************
                ;Start of the Disk Buffer
                ;************************
                ;	All of the Routines following this equate will be overwritten
                ;	by disk accesses.
                ;
 B80E =         BUFFER	EQU	$
                	PAGE
CP/M MACRO ASSEM 2.0	#103	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;***********************************************
                ;Console and list device initialization routines
                ;***********************************************
                ;
                	IF	CONTYP EQ 2
                ;*********************************************************************
                ;Begin Multio I/O or Wunderbus Console Initialization Routine (CIDRV2)
                ;*********************************************************************
                ;	This routine reads the sense switch on the WB-14 and sets
                ;	the speed accordingly.
                ;
 B80E CD62B8    CONINT:	CALL	SELG0		;Select group 0
 B811 DB49      	IN	SENSESW		;Get sense switch (ff on a Multio)
 B813 F5        	PUSH	PSW
 B814 CD74B7    	CALL	SELCON		;Select console
 B817 F1        	POP	PSW
 B818 F5        	PUSH	PSW
 B819 CD26B8    	CALL	TINI0		;Initialize the console
 B81C F1        	POP	PSW
 B81D F5        	PUSH	PSW
 B81E CD68B8    	CALL	SELRDR		;Select the reader/punch
 B821 F1        	POP	PSW
 B822 CD26B8    	CALL	TINI0		;Initialize the reader/punch
 B825 C9        	RET
 B826 E6E0      TINI0:	ANI	0E0H		;Mask in upper three bits
 B828 07        	RLC			;Move into lower 3 bits
 B829 07        	RLC
 B82A 07        	RLC
 B82B FE07      	CPI	7		;check for sense = 7 (Default setting)
 B82D CA3EB8    	JZ	DFBAUD		;Use default baud rate
 B830 2170B8    	LXI	H,BTAB		;Pointer to baud rate table
 B833 87        	ADD	A		;Table of words so double
 B834 5F        	MOV	E,A		;Make a 16 bit number into (de)
 B835 1600      	MVI	D,0
 B837 19        	DAD	D		;Get a pointer into baud rate table
 B838 5E        	MOV	E,M		;Get lower byte of word
 B839 23        	INX	H		;Bump to high byte of word
 B83A 56        	MOV	D,M		;Get upper byte. (de) now has divisor
 B83B C342B8    	JMP	SETIT		;Set baud rate
 B83E 2ABBAD    DFBAUD:	LHLD	DEFCON		;Use default baud rate
 B841 EB        	XCHG
                	;Enable divisor access latch
 B842 3E87      SETIT:	MVI	A,DLAB+WLS1+WLS0+STB
 B844 D34B      	OUT	LCR		;Set the baud rate in (de)
 B846 7A        	MOV	A,D
 B847 D349      	OUT	DLM		;Set upper divisor
 B849 7B        	MOV	A,E
 B84A D348      	OUT	DLL		;Set lower divisor
                	;Clear Divisor latch
 B84C 3E07      	MVI	A,WLS1+WLS0+STB
 B84E D34B      	OUT	LCR
 B850 AF        	XRA	A
 B851 D349      	OUT	IER		;Set no interrupts
 B853 D34D      	OUT	LSR		;Clear status
 B855 3E03      	MVI	A,DTRENB+RTSENB	;Enable DTR and RTS outputs to terminal
CP/M MACRO ASSEM 2.0	#104	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B857 D34C      	OUT	MCR
 B859 DB4E      	IN	MSR		;Clear MODEM Status Register
 B85B DB4D      	IN	LSR		;Clear Line Status Register
 B85D DB48      	IN	RBR		;Clear reciever buffers
 B85F DB48      	IN	RBR
 B861 C9        	RET
 B862 3ABAAD    SELG0:	LDA	GROUP		;Select group zero
 B865 D34F      	OUT	GRPSEL
 B867 C9        	RET
 B868 3ABAAD    SELRDR:	LDA	GROUP		;Select reader/punch group
 B86B F602      	ORI	5-LSTGRP	;Use 'other' serial port
 B86D D34F      	OUT	GRPSEL
 B86F C9        	RET
 B870 1704      BTAB:	DW	1047		;110 Baud	000
 B872 8001      	DW	384		;300		001
 B874 6000      	DW	96		;1200		010
 B876 3000      	DW	48		;2400		011
 B878 1800      	DW	24		;4800		100
 B87A 0C00      	DW	12		;9600		101
 B87C 0600      	DW	6		;19200		110
                				;DEFCON		111
                	ENDIF			;End Multi I/O, Decision I Con Init
                	IF	CONTYP EQ 3
                ;***************************************************
                ;Begin DJ2DB Console Initialization Routine (CIDRV3)
                ;***************************************************
                ;
                CONINT:	CALL	FDTSTAT		;Clean input buffer
                	RNZ			;All empty
                	CALL	FDCIN
                	JMP	CONINT
                	ENDIF			;End 2D/B console Initialization
                	IF	CONTYP EQ 4
                ;***************************************************
                ;Begin DJDMA Console Initialization Routine (CIDRV4)
                ;***************************************************
                ;
                CONINT:	CALL	DMINIT		;See if controller present
                	RC			;No controller, return
                	LXI	H,0		;clear
                	SHLD	SERIN		;initialize no char present
                	LXI	H,DMACI		;Console initialization sequence
                	LXI	D,3		;Halt offset
                	CALL	DMDOIT
                	RET
                ;DJDMA Initialization Command String
                ;-----------------------------------
                ;
                DMACI:	DB	SENABL		;Enable serial input
                	DB	1
                	DB	DMHALT
                	DB	0
                	ENDIF			 ;End DJDMA Console intialization
                	IF	CONTYP EQ 6
                ;********************************************************
                ;Begin North Star Console Initialization Routine (CIDRV6)
CP/M MACRO ASSEM 2.0	#105	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;********************************************************
                ;	Initialize the North Star Mother board, left serial port, right
                ;	serial port, and North Star RAM parity.
                ;
                	;Initialize mother board
                CONINT:	XRA	A		;Set up the parallel port + motherboard
                	OUT	6
                	OUT	6
                	OUT	6
                	OUT	6
                	MVI	A,30H		;Reset the parallel port input flag
                	OUT	NSPSTA
                	MVI	A,60H		;Set the parallel port output flag
                	OUT	NSPSTA
                	MVI	A,ACR		;Force a CR out the parallel port
                	CALL	NSPOUT
                	;Initialize the left serial port
                	MVI	A,NSLIN1	;See the equates for bit definations
                	OUT	NSLSTA
                	MVI	A,NSLIN2
                	OUT	NSLSTA
                	XRA	A		;Clear the input/output buffers
                	OUT	NSLDAT
                	IN	NSLDAT
                	IN	NSLDAT
                	;Initialize the right serial port
                	MVI	A,NSRIN1	;See the equates for bit definations
                	OUT	NSRSTA
                	MVI	A,NSRIN2
                	OUT	NSRSTA
                	XRA	A		;Clear the input/output buffers
                	OUT	NSRDAT
                	IN	NSRDAT
                	IN	NSRDAT
                	IF	NSRAM NE 0	;Reset parity on North Star RAMs
                	MVI	A,40H		;Disable parity logic
                	OUT	NSRAM
                	LXI	H,0		;Starting address
                NSET0:	MOV	A,M		;Get a byte
                	MOV	M,A		;Rewrite, set proper parity
                	INR	L		;Bump the address pointer
                	JNZ	NSET0
                NSET1:	INR	H		;Skip to the next memory page
                	JZ	NSET2		;Skip if all done 
                	LXI	D,$ + 100H	;fix for assem with rmac
                	MOV	A,D
                ;	mvi	a,(high $) + 1	;Is the pointer above us?
                	CMP	H		;Set carry if pointer is <= our page+1
                	JC	NSET0		;Reset the next pages parity
                	MOV	A,M		;Test for a PROM or no memory
                	MOV	B,A		;Save the original byte
                	CMA			;See if this location will change
                	MOV	M,A
                	CMP	M		;Test for a change
                	MOV	M,B		;Restore the original value
                	JZ	NSET0		;Value complemented, must be RAM
CP/M MACRO ASSEM 2.0	#106	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	ORA	A		;Test for no memory present
                	JZ	NSET1		;Skip to the next page if no memory
                	LXI	D,700H		;Skip 2K bytes of 'PROM'
                	DAD	D
                	JNC	NSET1		;Do a page check if no overflow
                NSET2:	MVI	A,41H		;Re-enable parity on the memory boards
                	OUT	NSRAM
                	ENDIF
                CRTSET:	;Null routines
                PTRSET:
                PTPSET:
                UC1SET:
                UR1SET:
                UR2SET:
                UP1SET:
                UP2SET:
                LPTSET:
                UL1SET:	RET
                	ENDIF			;End North Star Initialization
                	PAGE
CP/M MACRO ASSEM 2.0	#107	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                	IF	(LSTTYP GE 2) AND (LSTTYP LE 5)
                ;*******************************************************************
                ;Begin Multio I/O or Wunderbuss List and Punch Initialization 
S               ;Routine
                ;*******************************************************************
                ;
 B87E CDB3B7    LSTSET:	CALL	SELLST		;Select printer group
 B881 3E80      	MVI	A,DLAB		;Access divisor latch
 B883 D34B      	OUT	LCR
 B885 2ABDAD    	LHLD	DEFLST		;Get LST: baud rate divisor
 B888 7C        	MOV	A,H
 B889 D349      	OUT	DLM		;Set upper baud rate
 B88B 7D        	MOV	A,L
 B88C D348      	OUT	DLL
 B88E 3E07      	MVI	A,STB+WLS0+WLS1	;2 stop bits + 8 bit word
 B890 D34B      	OUT	LCR
 B892 3E03      	MVI	A,DTRENB+RTSENB	;DTR + RTS enabled
 B894 D34C      	OUT	MCR
 B896 DB48      	IN	RBR		;Clear input buffer
 B898 AF        	XRA	A
 B899 D349      	OUT	IER		;No interrupts
                	;fall thru to centronics init
                ;*******************************************************************
                ;Begin Multio I/O or Wunderbuss Parallel List Initialization Routine
                ;*******************************************************************
                ;
 B89B 3ABAAD    PUNSET:	LDA	GROUP
 B89E D34F      	OUT	GRPSEL		;select parallel port
 B8A0 DB49      	IN	SENSESW		;read motherboard switches
 B8A2 FEFF      	CPI	0FFH		;FF is Multio
 B8A4 CAB8B8    	JZ	IMULT
 B8A7 3EFF      	MVI	A,0FFH
 B8A9 D348      	OUT	STROBE		;turn strobes off
 B8AB 3EC0      	MVI	A,0C0H
 B8AD D34A      	OUT	CLK		;turn on drivers
 B8AF 3E7F      	MVI	A,07FH
 B8B1 D348      	OUT	STROBE		;assert restore (low true)
 B8B3 3EFF      	MVI	A,0FFH
 B8B5 D348      	OUT	STROBE		;inactivate restore
 B8B7 C9        	RET
 B8B8 3ABAAD    IMULT:	LDA	GROUP
 B8BB F620      	ORI	DENABLE
 B8BD 32BAAD    	STA	GROUP		;turn parallel port drivers on
 B8C0 D34F      	OUT	GRPSEL		;select parallel port
 B8C2 3EC0      	MVI	A,0C0H
 B8C4 D348      	OUT	STROBE		;turn data strobe off
 B8C6 3ABAAD    	LDA	GROUP
 B8C9 F610      	ORI	RESTOR
 B8CB D34F      	OUT	GRPSEL		;assert restore
 B8CD 3ABAAD    	LDA	GROUP
 B8D0 D34F      	OUT	GRPSEL		;de-assert restore
 B8D2 C9        	RET
                	ENDIF			;End Multio/Wbio punch / list init
                	PAGE
CP/M MACRO ASSEM 2.0	#108	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;**********************
                ;Begin Cold Boot Loader
                ;**********************
                ;	Cboot is the cold boot loader. All of CP/M has been loaded in
                ;	when control is passed here.
                ;
 B8D3 310001    CBOOT:	LXI	SP,TPA			;Set up stack
 B8D6 AF        	XRA	A			;Clear cold boot flag
 B8D7 32A5AD    	STA	CWFLG
 B8DA 32BAAD    	STA	GROUP			;Clear group select byte
 B8DD 3235B7    	STA	CPMDRV			;Select disk A:
 B8E0 320400    	STA	CDISK
 B8E3 2103AD    	LXI	H,CBIOS+3		;Patch cold boot to warm code
 B8E6 7C        	MOV	A,H
 B8E7 3200AE    	STA	BPAGE			;set CBIOS base page number
 B8EA 2201AD    	SHLD	CBIOS+1
 B8ED 3AB9AD    	LDA	IOBYT			;Initialize the IOBYTE
 B8F0 320300    	STA	IOBYTE
 B8F3 AF        	XRA	A
 B8F4 110EBC    	LXI	D,BADMAP		;Clear out bad map
 B8F7 12        	STAX	D
 B8F8 210FBC    	LXI	H,BADMAP+1
 B8FB 010900    	LXI	B,9*BADSIZ		;32 map entries
 B8FE CDD5AF    	CALL	MOVBYT
 B901 36FF      	MVI	M,0FFH			;End marker
                	IF	CONTYP NE 6		;Non IOBYTE inits
 B903 CD0EB8    	CALL	CONINT			;Initialize the terminal
 B906 CD7EB8    	CALL	LSTSET			;Initialize the list device
                	ELSE				;Do IOBYTE inits
                	LXI	H,DEVSET		;Device setup routine pointer table
                CBOOT0:	MOV	E,M			;Load a routine address
                	INX	H
                	MOV	D,M
                	INX	H
                	MOV	A,D			;Test for the end of the table
                	ORA	E
                	JZ	CBOOT2
                	PUSH	H			;Save the table pointer
                	LXI	H,CBOOT1		;Return address
                	PUSH	H
                	XCHG
                	PCHL				;'CALL' a device setup routine
                CBOOT1:	POP	H			;Restore the table pointer
                	JMP	CBOOT0
                ;Device setup routine pointers
                ;-----------------------------
                DEVSET:	DW	CONINT, CRTSET, UC1SET
                	DW	PTRSET, UR1SET, UR2SET
                	DW	PTPSET, UP1SET, UP2SET
                	DW	LPTSET, UL1SET, 0
                CBOOT2	EQU	$
                	ENDIF
 B909 2112B9    	LXI	H,PROMPT		;Prep for sending signon message
 B90C CDEBAF    	CALL	MESSAGE			;Send the prompt
 B90F C350AD    	JMP	GOCPM
CP/M MACRO ASSEM 2.0	#109	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                ;Signon message output during cold boot
                ;--------------------------------------
                ;	Print a message like:
                ;
                ;	Morrow Designs 48K CP/M 2.2 E4
                ;	AB: DJ/DMA 8", CD: DJ/DMA 5 1/4", E: HDC/DMA M5
                ;
                ;Print String for the first line of the Sign-on message
                ;------------------------------------------------------
 B912 801A      PROMPT:	DB	80H, CLEAR		;Clean buffer and screen
 B914 0D0A0A    	DB	ACR, ALF, ALF
 B917 4D6F72726F	DB	'Morrow Designs '
 B926 34        	DB	'0'+MSIZE/10		;CP/M memory size
 B927 38        	DB	'0'+(MSIZE MOD 10)
 B928 4B2043502F	DB	'K CP/M '		;CP/M version number
 B92F 32        	DB	CPMREV/10+'0'
 B930 2E        	DB	'.'
 B931 32        	DB	(CPMREV MOD 10)+'0'
 B932 20        	DB	' '
 B933 45        	DB	(REVNUM/10)+'A'-1
 B934 34        	DB	(REVNUM MOD 10)+'0'
 B935 0D0A      	DB	ACR, ALF
                ;Macros To generate the second line of the sign-on message
                ;---------------------------------------------------------
 0000 #         MSDRV	SET	0			;Start with drive A:
                MSBUMP	MACRO	NDRIVES			;Print a drive name
                	IF	DN GT 1
                	DB	', '
                	ENDIF
                	REPT	NDRIVES
                	DB	MSDRV+'A'
                MSDRV	SET	MSDRV+1
                	ENDM
                	DB	': '
                	ENDM
                PRHEX	MACRO	DIGIT			;Write a byte in hex
                	PRNIB	DIGIT/10H
                	PRNIB	DIGIT
                	ENDM
                PRNIB	MACRO	DIGIT			;Write a digit in hex
                TEMP	SET	DIGIT AND 0FH
                	IF	TEMP LT 10
                	DB	TEMP + '0'
                	ELSE
                	DB	TEMP - 10 + 'A'
                	ENDIF
                	ENDM
 0001 #         DN	SET	1			;Generate the drive messages
                	REPT	16			;Run off at least 16 drives
                	IF	DN EQ HDORDER		;Generate the HDCA's message
                	MSBUMP	MAXHD*HDLOG
                	DB	'HDCA '
                	IF	MAXHD GT 1
                	DB	'(', MAXHD+'0', ')'
                	ENDIF
                	IF	M10 NE 0
CP/M MACRO ASSEM 2.0	#110	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	IF	M10M NE 0
                	DB	'Memorex'
                	ELSE
                	DB	'Fujitsu'
                	ENDIF
                	DB	' M10'
                	ENDIF
                	IF	M20 NE 0
                	DB	'Fujitsu M20'
                	ENDIF
                	IF	M26 NE 0
                	DB	'Shugart M26'
                	ENDIF
                	ENDIF
                	IF	DN EQ MWORDER		;Generate the HDDMA's message
                	MSBUMP	MAXMW*MWLOG
                	DB	'HDC/DMA'
                	IF	MWQUIET EQ 0
                	DB	' '
                	IF	MAXMW GT 1
                	DB	'(', MAXMW+'0', ')'
                	ENDIF
                	IF	ST506 NE 0
                	DB	'M5'
                	ENDIF
                	IF	ST412 NE 0
                	DB	'M10'
                	ENDIF
                	IF	CM5619 NE 0
                	DB	'M16'
                	ENDIF
                	ENDIF
                	ENDIF
                	IF	DN EQ FDORDER		;Generate the 2D/B message
                	MSBUMP	MAXFD
                	DB	'DJ2D/B @'
                	PRHEX	FDORIG/100H
                	PRHEX	FDORIG
                	ENDIF
                	IF	DN EQ DMORDER		;Generate the DJDMA 8 message
                	MSBUMP	MAXDM
                	DB	'DJ/DMA 8"'
                	ENDIF
                	IF	DN EQ MFORDER		;Generate the DJDMA 5 1/4 message
                	MSBUMP	MAXMF
                	DB	'DJ/DMA 5 1/4"'
                	ENDIF
                DN	SET	DN+1
                	ENDM
 B937+41        	DB	MSDRV+'A'
 B938+42        	DB	MSDRV+'A'
 B939+3A20      	DB	': '
 B93B+444A2F444D	DB	'DJ/DMA 8"'
 B944+2C20      	DB	', '
 B946+43        	DB	MSDRV+'A'
 B947+44        	DB	MSDRV+'A'
CP/M MACRO ASSEM 2.0	#111	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 B948+3A20      	DB	': '
 B94A+444A2F444D	DB	'DJ/DMA 5 1/4"'
 B957 0D0A      	DB	ACR,ALF
 B959 00        	DB	0			;End of message
                	PAGE
CP/M MACRO ASSEM 2.0	#112	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Debugging checks
                ;----------------
 B95A =         CODEND	EQU	$
 BC5A =         SAVLN	EQU	CODEND+300H		;for movcpm
 0C5A =         CODELEN	EQU	($ - CBIOS)		;Length of Cbios code
                	IF	CODELEN GT 1000H	;Test for SYSGEN problems
                	'FATAL ERROR, system is too big for SYSGEN rev. 4.X'
                DBGTMP	SET	CODELEN		;Cbios code length   !   <DEBUG>
                	ENDIF
                	IF	DEBUG
                DBGTMP	SET	CODELEN		;Cbios code length   !   <DEBUG>
                	ENDIF
                ;Reserve the space for the disk buffer
                ;-------------------------------------
 B95A           	DS	512-($-BUFFER)		;Buffer for 512 byte sectors
                	IF	(MAXFD NE 0) OR (MAXDM NE 0) OR (MAXMW NE 0) OR (MAXMF NE 0)
 BA0E           	DS	512			;Additional space for 1k sector devices
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#113	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;******************************
                ;Begin Uninitialized Data Areas
                ;******************************
                ;
                ;Bad Map Space
                ;=============
                ;	Each bad map entry consists of 9 bytes:
                ;		Logical drive number (1 byte)
                ;		Track number of bad sector (2 bytes)
                ;		Sector number of bad sector (2 bytes)
                ;		Track number of alternate sector (2 bytes)
                ;		Sector number of alternate sector (2 bytes)
                ;
 BC0E           BADMAP:	DS	BADSIZ*9+1		;32 entries + end marker
                ;Directory Buffer
                ;================
                ;
 BC18           DIRBUF:	DS	128			;Directory buffer
                ;Allocation and checked directory table area
                ;============================================
                ;
                ;DJDMA 8" Drives
                ;---------------
                ;
                	IF	MAXDM NE 0
                	;Drive_0
 BC98           CSVDM0:	DS	64
 BCD8           ALVDM0:	DS	75
                	;Drive_1
 BD23           CSVDM1:	DS	64
 BD63           ALVDM1:	DS	75
                	;Drive_2
 BDAE           CSVDM2:	DS	64
 BDEE           ALVDM2:	DS	75
                	;Drive_3
 BE39           CSVDM3:	DS	64
 BE79           ALVDM3:	DS	75
                ;dn	set	0
                ;	rept	maxdm
                ;	alloc	dm,%dn,75,64
                ;dn	set	dn+1
                ;	endm
                	ENDIF
                ;DJDMA 5" Drives
                ;---------------
                ;
                	IF	MAXMF NE 0
                	;Drive_4
 BEC4           CSVMF0:	DS	48
 BEF4           ALVMF0:	DS	25
                	;Drive_5
 BF0D           CSVMF1:	DS	48
 BF3D           ALVMF1:	DS	25
                	;Drive_6
 BF56           CSVMF2:	DS	48
CP/M MACRO ASSEM 2.0	#114	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

 BF86           ALVMF2:	DS	25
                	;Drive_7
 BF9F           CSVMF3:	DS	48
 BFCF           ALVMF3:	DS	25
                ;dn	set	0
                ;	rept	maxmf
                ;	alloc	mf,%dn,25,48
                ;dn	set	dn+1
                ;	endm
                	ENDIF
                ;DJ2DB Drives
                ;------------
                ;
                	IF	MAXFD NE 0
                DN	SET	0
                	REPT	MAXFD
                	ALLOC	FD,%DN,75,64
                DN	SET	DN+1
                	ENDM
                	ENDIF
                ;HDDMA Drives
                ;------------
                ;
                	IF	MAXMW NE 0
                DN	SET	0
                TRKOFF	SET	8192/(MWSECPT/8)+1
                PSIZE	SET	TRKOFF*(MWSECPT/8)
                	REPT	MAXMW
                BLOCKS	SET	MWSECPT/8*MWTRKS
                	REPT	BLOCKS/8192		;Generate some 8 megabyte ALV's
                	ALLOC	MW,%DN,256,0
                BLOCKS	SET	BLOCKS-PSIZE
                DN	SET	DN+1
                	ENDM
                BLOCKS	SET	BLOCKS/4
                	IF	BLOCKS GT 256		;Use the remainder
                BLOCKS	SET	BLOCKS-1
                ALV	SET	(BLOCKS/8)+1
                	ALLOC	MW,%DN,%ALV,0
                DN	SET	DN+1
                	ENDIF
                	ENDM
                	ENDIF
                ;HDCA Drives
                ;-----------
                ;
                	IF	MAXHD NE 0
                DN	SET	0
                	REPT	MAXHD
                	IF	M26 NE 0
                	ALLOC	HD,%DN,252,0
                DN	SET	DN+1
                	ALLOC	HD,%DN,252,0
                DN	SET	DN+1
                	ALLOC	HD,%DN,256,0
                DN	SET	DN+1
CP/M MACRO ASSEM 2.0	#115	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                	ENDIF
                	IF	M10 NE 0
                	ALLOC	HD,%DN,159,0
                DN	SET	DN+1
                	ALLOC	HD,%DN,161,0
                DN	SET	DN+1
                	ENDIF
                	IF	M20 NE 0
                	ALLOC	HD,%DN,255,0
                DN	SET	DN+1
                	ALLOC	HD,%DN,255,0
                DN	SET	DN+1
                	ALLOC	HD,%DN,129,0
                DN	SET	DN+1
                	ENDIF
                	ENDM
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#116	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Debugging Aids
                ;--------------
                ;
 0013 =         BIOSLEN	EQU	(HIGH ($ - CBIOS)) + 1	;BIOS length in pages
                	IF	BIOSLEN GT BIOSLN	;Test for overflow
                	'FATAL ERROR, system overflow.  BIOSLN must be at least'
                DBGTMP	SET	BIOSLEN		;BIOSLN! <DEBUG>
                	ENDIF
                	IF	DEBUG
                DBGTMP	SET	BIOSLN		;Current BIOSLN! <DEBUG>
                	IF	BIOSLN GT BIOSLEN
                DBGTMP	SET	BIOSLEN		;Optimal BIOSLN! <DEBUG>
                	ENDIF
                	ENDIF
                	PAGE
CP/M MACRO ASSEM 2.0	#117	CBIOS-CP/M_2.2 Rev_E.4 07_Sep_83  Copyright 1983 Morrow Designs

                
                ;Revision History
                ;================
                ;
                ;
                ;  Date    Programmer	Description
                ;
                ;  9 17 83 west       * Public release of E.4 for dj/dma and hdc/dma.
                ;  9 13 83 west		repaired dj console init/drivers
                ;  9 12 83 west		multio initialization selects switches correctly
                ;  8 23 83 west		all multio/wbio devices have names for swap.com
                ;  8 22 83 west		PREP: now allows normal seeks to track zero
                ;  8 21 83 west		all multio/wbio character devices return pointer
                ;			to 'group' in [de] to TPA program	
                ;  8 15 83 west		all multio/wbio serial list have centronics punch
                ;			and rdr: implemented as list input
                ;  5  5 83 F.R.K.	add parallel centronics printer thru Mulito/Wbio
                ;  3 28 83 F.R.K.	add dbl-sided soft sector, fix for rmac
                ;  1 18 83 JZ		Did a cosmetic restructuring of the code Dealing
                ;			with the disks at both the hi and lo levels.
                ;  1 17 83 JZ		Now reads 5" soft sectored single density disks
                ;  1 16 83 JZ		Patched up various holes in the disk error handeling
                ;			routines in the Hi-Level routines SETDRV, READ, and
                ;			WRITE and in the DJDMA Drivers
                ;*11 20 82 Marc		Public release of revision E.31
 BFE8           	END
