;
; grammar file for the hitech stdio library replacement for which do not have
; source code - this is what it is linked to p1
;
; this stdio has no read/write/open/close, with fread, fopen, fflush, fwrite,
; built directly on top of bdos calls.
;
; zcrtcpm.obj - this is org'ed at 0x100, and we can extract a lot of symbols
; directly from it and cascade down from there
;
; the stdio from hitech has an array of fcb's corresponding to the file entries.
; the fcb has an 32 bit file offset after the usual cp/m fcb.
;
; symbols starting with _ are c-visible, either generated by the compiler
; or explicitly in assembly code to be seen by C code.
;

;
; c startup code found at 0x100
; CRTCPM.OBJ
;
block crt
	match 0100
		2a 06 00 f9
		11 __Lbss
		b7
		21 __Hbss
		ed 52 4d 44
		0b 6b 62 13
		36 00 ed b0
		21 ANY ANY
		e5 21 80 00
		4e 23 06 00
		09 36 00
		21 81 00 e5
		CALL startup c1 c1 e5
		2a _argc
		e5
		CALL _main e5
		CALL _exit
		JUMP 0000
	end

	;
	; micronix gives us argc, argv, right on the stack.
	; we don't need to grunge it out of the unparsed command tail at 0x80

	patch crt 61
		ld		de,__Lbss
		xor		a
		ld		hl,__Hbss	
		sbc		hl,de
		ld		c,l
		ld		b,h
		dec		bc
		ld		l,e
		ld		h,d
		inc		de
		ld		(hl),a
		pop		bc
		ld		h,b
		ld		l,c
		ld		(_argc),hl
		ex		de,hl
		ld		hl,0
		add		hl,sp
		push	hl
		push	de
		call	_main
		pop		bc
		pop		bc
		push	hl
		jp		_exit
	end
	;
	; make a dummy function that is guaranteed to breakpoint
	;
	define _lose crt+40
	patch _lose
		call 0005
	end
end

;
; a whole lot of patterns for recognizing symbols for other blocks
;

;
; function prolog that establishes a stack frame pointer in IX and saves IY
; csv.obj
;
block csv
	match
		e1 fd e5 dd e5 dd 21 00 00 
		dd 39 e9
	end
end

;
; function prolog that saves IY, puts a frame pointer in IX, and bumps the
; stack pointer to allocate automatic variable space with a negative offset
; off of IX.
; csv.obj
;
block ncsv
	match
		e1 fd e5 dd e5 dd 21 00 00 
		dd 39 5e 23 56 23 eb 39 f9 
		eb e9 
	end
end

;
; function epilog that pops everything off the stack, restores IY and returns
; to the function's caller.
; csv.obj
;
block cret
	match
		dd f9 dd e1 fd e1
		RET
	end
end

;
; just an indirect jump through hl
;
block indir
	match cret+7
		e9
	end
end

;
; function that compares bytes, used as anchor
; brelop.obj
;
block brelop
	match
		d5 5f a8 
		fa ANY ANY
		7b 98 d1 RET
		7b e6 80 57 7b 98 7a 3c d1 RET
	end
end

;
; bdos call, returning 8 bit value, sign extended to HL
;
block _bdosa
	match
		CALL csv
		dd 5e 08 dd 56 09
		dd 4e 06 
		dd e5 CALL 0005 dd e1
		6f 17 9f 67
		JUMP cret
	end
end

;
; bdos call, returning 16 bits
; bdoshl.obj
;
block _bdoshl
	match
		CALL csv 
		dd 5e 08 dd 56 09 dd 4e 06 
		dd e5 CALL 0005 dd e1
		JUMP cret
	end
end

block _bufallo
	match
		CALL csv 
		fd 2a freep fd e5 e1 7d b4 28 0b 
		fd 6e 00 fd 66 01 22 freep 18 0b 
		21 00 02 e5 CALL _sbrk c1 e5 fd e1 fd e5 e1 
		JUMP cret
	end
end

;
; the stdio version found in the compiler
; this calls fclose on 6 files starting at _iob
;
block _exit
	match
		CALL csv
		e5
		dd 36 ff 05	
		fd 21 __iob
		fd e5 e1
		01 0008 09 e5 fd e1 ed 42
		e5 CALL _fclose c1
		dd 7e ff c6 ff
		dd 77 ff b7 20 e4
		dd 6e 06 dd 66 07
		22 0080
		CALL 0000
		JUMP cret
	end
	patch _exit+49
		db 0xcf, 01
	end
end

;
; this is the fclose found in the compiler passes
;
block _fclose
	match
		CALL csv
		e5 
		dd 6e 06 dd 66 07 e5 fd e1 
		11 __iob fd e5 e1 b7 ed 52
		11 08 00 CALL adiv
		11 29 00 CALL lmul
		11 __fcb 19
		dd 75 fe dd 74 ff
		fd 7e 06 e6 03 b7 20 06
		21 ff ff JUMP cret
		fd e5 CALL _fflush c1 
		fd 7e 06 e6 f8
		fd 77 06 
		dd 5e fe dd 56 ff
		21 24 00 19 7e fe 02 28 0c
		21 0c 00 e5 CALL _bdoshl c1 
		cb 44 28 10
		dd 6e fe dd 66 ff 
		e5 21 10 00 e5 CALL _bdosa c1 c1
		dd 5e fe dd 56 ff
		21 24 00 19 36 00
		21 00 00 JUMP cret
	end
	patch _fclose 133
		call	csv
		ld		l,(ix+6)		; get the iob ptr
		ld		h,(ix+7)
		push	hl
		pop		iy				; put it into struct ptr
		ld		a,(iy+6)		; get flag byte
		and		0x3				; if not open, skip
		jr		z,noflush
		push	iy
		call	_fflush			; fflush(file)
		pop		bc
		ld		a,(iy+6)		; iob->flag &= ~7
		and		0xfc
		ld		(iy+6),a
	noflush:
		ld		l,(iy+7)		; get file descriptor
		ld		h,0
		db		0xcf, 06
		ld		hl,0
		jp		cret
		ret
	end
end

;
; and this one, which knows about fcb's, etc.
; no source code
;
block _fflush
	match _fflush
		CALL csv
		e5 dd 6e 06 dd 66 07 
		e5 fd e1 11 __iob
		fd e5 e1 b7 ed 52
		11 0008 CALL adiv
		11 0029 CALL lmul
		11 __fcb 19
		dd 75 fe dd 74 ff
		fd cb 06 4e 20 06
		21 ff ff
		JUMP cret
		fd 7e 02 e6 7f
		6f af 67 7d b4 28 27
		06 04 
		dd 5e fe dd 56 ff
		21 24 00
		19 7e CALL brelop 30 15
		fd 6e 00 fd 66 01
		36 1a fd 6e 02 fd 66 03
		2b fd 75 02 fd 74 03
		fd 6e 04 fd 66 05 
		fd 75 00 fd 74 01
		7d b4 20 06
		21 00 00 JUMP cret
		fd 5e 02 fd 56 03
		21 00 02 b7 ed 52
		fd 75 02 fd 74 03
		dd 5e fe dd 56 ff
		21 24 00 19 7e fe 02 28 52
		fe 04 28 3a
		fd 36 02 00 fd 36 03 00
		fd 6e 04 fd 66 05
		fd 75 00 fd 74 01
		fd 36 02 00 fd 36 03 02 18 b7
		fd 6e 00 fd 66 01 
		7e 23 fd 75 00 fd 74 01 
		6f 17 9f 67 
		e5 21 02 00 e5 CALL bdosa c1 c1 
		fd 6e 02 fd 66 03 2b
		fd 75 02 fd 74 03 23 7d b4 20 d2 18 b2
		fd 5e 02 fd 56 03 
		21 7f 00 19 11 80 00 cd adiv 
		fd 75 02 fd 74 03 18 34 
		fd 6e 00 fd 66 01 
		e5 21 1a 00 e5 CALL bdosa c1
		dd 6e fe dd 66 ff e3 
		21 15 00 e5 CALL bdosa c1 c1 
		7d b7 c2 ANY ANY
		11 80 00 fd 6e 00 fd 66 01 19 
		fd 75 00 fd 74 01 fd 6e 02 fd 66 03 2b
		fd 75 02 fd 74 03 23 7d b4 20 ba 
		c3 ANY ANY
	end
	code _fflush
		struct iob { char *ptr; int cnt; char *base ; unsigned char flag ; unsigned char fd; };
		int
		_fflush(struct iob *f) {
			if ((f->flag & 2)) return -1;
			if ((f->base == 0) || (f->cnt == 0x200)) return 0;
		}
	end
;	patch _fflush
;		call csv
;		ld l,(ix+6)	; get FILE ptr
;		ld h,(ix+7)
;		push hl
;		pop iy
;		bit 1,(iy+6) ; if IOWRT
;		jr z,retffl
;	retffl:
;		ld hl,0
;		jp cret	
;	end
end

;
; remove a file
; unlink.obj
;
block _unlink
	match
		CALL ncsv d3 ff 
		dd 6e 06 dd 66 07 e5
		dd e5 d1 21 d6 ff 19 e5 CALL _setfcb c1 c1 
		7d b7 28 06 21 00 00 JUMP cret
		CALL _getuid 
		dd 75 d5 dd 6e ff 26 00 
		e5 CALL _setuid dd e5 d1 21 d6 ff 19 e3 
		21 13 00 e5 CALL _bdos c1 
		7d 17 9f 67 
		dd 75 d3 dd 74 d4 dd 6e d5 26 00 
		e3 CALL _setuid c1 
		dd 6e d3 dd 66 d4
		JUMP cret 
	end
end

;
; used by the compiler passes, it does all the work for fopen
; the fopen itself does not need any patching
; FILE *reopen(char *name, char *mode, FILE *
block _freopen
	match
	CALL csv 
	e5 e5 dd 6e 0a dd 66 0b e5 
	fd e1 e5 CALL _fclose c1 
	11 __iob fd e5 e1 b7 ed 52
	11 08 00 CALL adiv 
	7d fd 77 07 6f 17 9f 67 
	11 29 00 CALL lmul
	11 __fcb 19 
	dd 75 fc dd 74 fd 
	dd 36 ff 00 dd 36 fe 0f 
	fd 7e 06 e6 4f fd 77 06 
	dd 6e 08 dd 66 09 7e fe 72 28 0b 
	fe 77 20 17 
	dd 34 ff dd 36 fe 16 dd 6e 08 dd 66 09 
	23 7e fe 62 20 04 
	fd 36 06 80 
	dd 6e 06 dd 66 07 e5 
	dd 6e fc dd 66 fd e5 CALL _setfcb c1 c1
	dd 7e fe fe 16 dd 6e fc dd 66 fd e5 20 0f 
	21 13 00 e5 CALL bdosa c1 
	dd 6e fc dd 66 fd e3 dd 6e fe 26 00 
	e5 CALL bdosa c1 c1 
	7d fe ff 20 06 
	21 00 00 JUMP cret 
	dd 7e ff b7 20 05 
	21 01 00 18 03 
	21 02 00 7d dd 5e fc dd 56 fd 
	21 24 00 19 77 
	dd 7e ff 3c 5f fd 7e 06 b3 fd 77 06 e6 0c b7 20 16 
	fd 7e 04 fd b6 05 20 0e 
	21 00 02 e5 CALL _sbrk c1 
	fd 75 04 fd 74 05 
	fd 6e 04 fd 66 05 fd 75 00 fd 74 01 
	7d fd b6 05 28 10 
	dd 7e ff b7 fd 36 02 00 28 0a 
	fd 36 03 02 18 08 
	fd 36 02 00 fd 36 03 00 fd e5 e1 JUMP cret
	end

	;
	; we're not going to try for full library compatibility
	; just enough to make the compiler work. 
	; the specific hair that we are not going to split is a
	; stream open for both read and write.  what's the file
	; pointer? how does this interact with flushing?
	; screw that.
	; file * freopen(char *name, char *mode, file *fp)
	;
	patch _freopen 295
		call	csv

		ld		h,(ix+11)	; close the file
		ld		l,(ix+10)
		push	hl
		push	hl
		pop		iy
		call	_fclose

		ld		h,(ix+9)	; parse mode: rwa = 012
		ld		l,(ix+8)
		ld		b,0
		set		0,(iy+6)	; set read bit
		ld		a,(hl)
		cp		'r'
		jr		z,modeset
		res		0,(iy+6)	; reset read bit
		set		1,(iy+6)	; set write bit
		inc		b
		cp		'w'
		jr		z,modeset
		set		1,b			; set append bit
	modeset:
		ld		a,5			; open syscall number
		ld		(sys+1),a
		ld		a,b			; mode r,w = 0,1
		and		1
		ld		(sys+4),a
		push	hl
		ld		h,(ix+7)	; copy name pointer to syscall
		ld		l,(ix+6)
		ld		(sys+2),hl

	sys:
		db		0xcf, 0x5, 0x0, 0x0, 0x0, 0x0
		jr		nc, opened

		dec		b			; mode 0 must succeed
		jp		m, openfail
		ld		a,8			; change it to a creat	
		ld		(sys+1),a
		ld		hl,666O		; permissive mode
		ld		(sys+4),hl
		db		0xcf, 0x0	; indirect
		dw		sys
		jr		c,openfail

	opened:
		ld		(iy+7),l	; iob->file = file descriptor
		bit		1,b			; is append set
		jr		z,noseek
		db		0xcf, 19, 0, 0, 2, 0

	noseek:
		ld		hl,0		; iob->count = 0
		ld		(iy+2),l
		ld		(iy+3),h
		ld		a,(iy+6)
		and		0xc
		jr		nz,noalloc
		call	_bufallo
		ld		(iy+4),l	; iob->base = bufalloc()
		ld		(iy+5),h
		bit		0,(iy+6)
		jr		nz, noalloc	; if read, iob->count=0
		ld		(iy+3),2	; iob->count = 512
	noalloc:
		ld		l,(iy+4)	; iob->ptr = iob->base
		ld		h,(iy+5)
		ld		(iy+0),l
		ld		(iy+1),h
		push	iy
		pop		hl
		jp		cret
	openfail:
		ld		hl,0
		jp		cret
	end
end

;
; the compiler system interface uses 
; fopen, fclose, fwrite, fread, fflush
;
; iob { char *ptr, int cnt, char *base, char flag, char fd }
; flags (bits 0-7): rd wr nbuf mybuf eof err string binary

; this is called from fgetc, and the compiler version knows all about setdma, sectors, and all that.
; filbuf(file *fp)
;
block _filbuf
	match
		CALL csv 
		e5 dd 6e 06 dd 66 07 e5 fd e1 
		11 __iob fd e5 e1 b7 ed 52 
		11 08 00 CALL adiv 
		11 29 00 CALL lmul 
		11 __fcb 19 
		dd 75 fe dd 74 ff 
		fd 36 02 00 fd 36 03 00 
		CALL _concheck 
		dd 5e fe dd 56 ff 
		21 24 00 19 7e 
		fe 01 c2 ANY ANY 
		fd 6e 04 fd 66 05 
		fd 75 00 fd 74 01 18 33 
		fd 6e 00 fd 66 01 
		e5 21 1a 00 e5 CALL bdosa c1 
		dd 6e fe dd 66 ff e3 
		21 14 00 e5 CALL bdosa c1 c1 
		7d b7 20 26 
		11 80 00 
		fd 6e 00 fd 66 01 19 
		fd 75 00 fd 74 01 
		fd 5e 04 fd 56 05 
		21 00 02 19 eb 
		fd 6e 00 fd 66 01 CALL wrelop 38 b7 
		fd 5e 04 fd 56 05 fd 6e 00 fd 66 01 
		b7 ed 52 
		fd 75 02 fd 74 03 6b 62 
		fd 75 00 fd 74 01 fd 7e 02 fd b6 03 20 06 
		21 ff ff JUMP cret 
		fd 6e 02 fd 66 03 2b 
		fd 75 02 fd 74 03 fd 6e 00 fd 66 01 23 
		fd 75 00 fd 74 01 2b 6e 26 00 JUMP cret
	end
	; f->cnt = read(f->fd, f->ptr, count);
	; if (f->cnt > 0) {
	;   f->cnt--;
	;   return(*f->fptr++);
	; }
    ; if (f->cnt == 0) f->flag |= EOF
	; if (f->cnt < 0) f->flag |= ERR
	; return eof
	;
	patch
		pop hl				; get f into de
		pop de
		push de
		push hl

		; if (f->flag & IORD) return EOF
		ld hl,6
		add hl,de
		bit 0,(hl)
		jr z,feof
	
		; if (f->base) {
		;     bc = f->base ; count = 512 ;
		; } else {
		;	  bc = fend + 1 ; count = 1;
		; }
		dec hl				; get base
		ld b,(hl)
		dec hl
		ld c,(hl)
		ld a,b
		or c
		jr nz, fbuf			; if base, use it
		ld bc,fend+1		; else use fend+1
	fbuf:
		ld (m_read+2),bc
		ld bc,0x200			; count = BUFSIZE
		jr nz,fcnt
		ld bc,1				; if !base count = 1
	fcnt:
		ld (m_read+4),bc
		dec hl
		ld bc,-1		; assume eof 
		ld (fend+1),bc
		ld bc,0

	m_read:			; read(fd, base, 0x200 - cnt)
		defb 0xcf, 5, 0, 0, 0, 0

		ld a,0x20	; ERR bit
		jr c,fret
		ld a,h		; is byte count 0?
		or l

	feof:
		ld a,0x10	; EOF bit
		jr z,fret

		ld b,h		; save returned byte count for f->cnt
		ld c,l

	fret:			; a = bits for flags, bc = count
		ld hl,6
		add hl,de
		or (hl)	
		ld (hl),a
		or a
		jr z,fr
		ld bc,0		; if err ret, f->cnt = 0
	fr:
		dec hl		; f->cnt = bc
		dec hl
		dec hl
		ld (hl),b
		dec hl
		ld (hl),c

	fend:
		ld hl,-1	; store into this instruction data field
		ret	
	end
end

