;
; grammar file for the hitech c library replacement
;
; blocks with no patch are used as pattern verifiers for called
; functions and to extract labels
;
; there are 2 distinct hitech libraries that we endeavor to patch:
; the one you get from compiling with the supplied libraries, and
; the one that was used to generate the compiler itself.
;
; they differ in that the supplied library source has stdio built on top
; of open/close/read/write, etc.
;
; the compiler has no such layer, with fread, fopen, fflush, fwrite,
; built directly on top of bdos calls.
;
; the intention is to have the patch completely fill the space occupied
; by the replaced function, padding it out with NOPs
;
; zcrtcpm.obj - this is org'ed at 0x100, and we can extract a lot of symbols
; directly from it and cascade down from there
;
; the stdio from hitech has an array of fcb's corresponding to the file entries.
; the fcb has an 32 bit file offset after the usual cp/m fcb.
;
; symbols starting with _ are c-visible, either generated by the compiler
; or explicitly in assembly code to be seen by C code.
;

;
; c startup code found at 0x100
; CRTCPM.OBJ
;
block crt
	match 0100
		2a 06 00 f9
		11 _Lbss			; 0x104 bss start
		b7
		21 _Hbss 			; 0x108 bss end
		ed 52 4d 44
		0b 6b 62 13
		36 00 ed b0
		21 ANY ANY 			; 0x117 nularg
		e5 21 80 00
		4e 23 06 00
		09 36 00
		21 81 00 e5
		CALL startup 		; 0x129 startup
		c1 c1 e5
		2a _argc			; 0x12f argc
		e5
		CALL _main			; 0x133 _main
		e5
		CALL _exit			; 0x137 _exit
		JUMP 0000			; 0x13a warmboot
	end
	;
	; nop-out the setting of the stack pointer, since this has been done
	; by the exec() call
	;
	replace crt+0
		00 00 00 00
	end
	;
	; micronix gives us argc, argv, right on the stack.
	; we don't need to grunge it out of the unparsed command tail at 0x80
	;
	patch crt+0x17
		pop		bc
		ld		h,b
		ld		l,c
		ld		(_argc),hl
		ex		de,hl
		ld		hl,0
		add		hl,sp
		push	hl
		push	de
		call	_main
		pop		bc
		pop		bc
		push	hl
		jp		_exit
		ds		16,0		
	end
end

;
; a whole lot of patterns for recognizing symbols for other blocks
;

;
; function prolog that establishes a stack frame pointer in IX and saves IY
; csv.obj
;
block csv
	match
		e1 fd e5 dd e5 dd 21 00 00 
		dd 39 e9
	end
end

;
; function prolog that saves IY, puts a frame pointer in IX, and bumps the
; stack pointer to allocate automatic variable space with a negative offset
; off of IX.
; csv.obj
;
block ncsv
	match
		e1 fd e5 dd e5 dd 21 00 00 
		dd 39 5e 23 56 23 eb 39 f9 
		eb e9 
	end
end

;
; function epilog that pops everything off the stack, restores IY and returns
; to the function's caller.
; csv.obj
;
block cret
	match
		dd f9 dd e1 fd e1
		RET
	end
end

;
; function that compares bytes, used as anchor
; brelop.obj
;
block brelop
	match
		d5 5f a8 
		fa ANY ANY
		7b 98 d1 RET
		7b e6 80 57 7b 98 7a 3c d1 RET
	end
end

;
; bdos call, returning 8 bit value, sign extended to HL
;
block _bdosa1
	match
		CALL csv
		dd 5e 08
		dd 56 09
		dd 4e 06
		dd e5
		CALL 0005
		dd e1
		6f
		17
		9f
		67
		JUMP cret
	end
end

;
; variation of bdosa1, that saves and restores IY.  redundantly,
; since this is done by csv already.
; bdos.obj
;
block _bdosa
	match
		CALL csv
		dd 5e 08 dd 56 09 dd 4e 06
		dd e5 fd e5
		CALL 0005
		fd e1 dd e1 6f 17 9f 67
		JUMP cret
	end
end

;
; bdos call, returning 16 bits
; bdoshl.obj
;
block _bdoshl
	match
		CALL csv
		dd 5e 08 dd 56 09 dd 4e 06 dd e5
		CALL 0005
		dd e1
		JUMP cret
	end
end

;
; one variation of exit.  calls cpm_clean
; and puts the return address into 0x80, presumably
; where the shell (NOT CCP) can test the exit status
; _exit.obj
;
block __exit
	match
		CALL cpm_clean
		e1 e1 22 0080
		JUMP 0000
	end
	;
	; micronix exit simply uses the value in hl.
	;
	patch __exit
		pop hl			; return address
		pop hl			; exit code
		db 0xcf, 01		; exit(hl)
		ds	8,0
	end
end

;
; another variation on exit.  just calls __cpm_clean after
; storing hl into 0x80.  nothing on the stack, apparently
;
block exit
	match
		22 0080
		cd __cpm_clean
		c3 0000
	end
	patch exit
		db 0xcf, 01		; exit(hl)
	end
end

;
; finally, the c version.  this calls _cleanup, which calls fclose on
; all the stdio FILES.  we'll do this too.
; this isn't the one found in the compiler binaries
; exit.obj
;
block _exit
	match
		CALL csv
		CALL __cleanup
		dd 6e 06 dd 66 07 e5
		CALL __exit
		JUMP cret			
	end
end

;
; the stdio version found in the compiler
; - note: no source code available.
;
block _exit
	match
		CALL csv
		e5					; push hl      - make space for counter
		dd 36 ff 05			; ld (ix-1),5  - 5 files
		fd 21 __iob			; ld iy,_iob   - end of iob
		fd e5				; push iy
		e1					; pop hl
		01 0008				; ld bc,8
		09					; add hl,bc
		e5					; push hl
		fd e1				; pop iy
		ed 42				; sbc hl,bc
		e5					; push hl
		CALL _fclose		; call fclose
		c1
		dd 7e ff
		c6 ff
		dd 77 ff
		b7
		20 e4
		dd 6e 06
		dd 66 07
		22 0080
		CALL 0000
		JUMP cret
	end
end

;
; fclose.obj
;
block _fclose
	match
		CALL csv
		dd 6e 06 dd 66 07 e5 fd e1
		fd 7e 06 e6 03 b7 20 06
		21 ff ff
		JUMP cret
		fd e5
		CALL _fflush	
		c1 fd 7e 06 e6 f8 fd 77 06 
		fd 7e 04 fd b6 05 28 19 fd 
		cb 06 5e 20 13 fd 6e 04 fd 
		66 05 e5
		CALL __buffree 
		c1 fd 36 04 00 fd 36 05 00 
		fd 6e 07 26 00 e5 
		CALL _close 
		c1 11 ff ff b7 ed 52 28 b9 
		fd cb 06 6e 20 b3 21 00 00 
		JUMP cret 
	end
end

;
; we find 2 versions of fflush.  this one, which is a simple C implementation
; found in fflush.obj
;
block _fflush
	match
		CALL csv
		e5 dd 6e 06
		dd 66 07
		e5
		fd e1
		fd cb 06 4e
	end
	;
	; if(!(f->_flag & _IOWRT) || 
	;    f->_base == (char *)NULL || 
	; (cnt = BUFSIZ - f->_cnt) == 0)
	;		return 0;
	; if (write(fileno(f), f->_base, cnt) != cnt)
	;	f->_flag |= _IOERR;
	;	f->_cnt = BUFSIZ;
	;	f->_ptr = f->_base;
	;	if(f->_flag & _IOERR)
	;		return(EOF);
	;	return 0;
	;
	patch _fflush
		pop hl			; de = file *
		pop de
		push de
		push hl
		ld hl,6			; get flags
		add hl,de
		bit 1,(hl)		; not write
		jr z, ferr

		ld hl,2
		add hl,de
		ld c,(hl)		; bc = cnt
		inc hl
		ld b,(hl)
		ld hl,0x200		; BUFSIZE - cnt
		or a
		sbc hl,bc
		ld a,h
		or l
		jr z,fend
		ld b,h			; bc = to_write
		ld c,l
	
		ld hl,4			; if base == 0, no buffer
		add hl,de
		ld a,(hl)
		inc hl
		or (hl)
		jr z,fend

		push de			; save our file *
		push bc			; save our count

		ld (m_write+4),bc
		ld b,(hl)
		dec hl
		ld c,(hl)
		ld (m_write+2),bc
		inc hl
		inc hl
		inc hl
		ld l,(hl)
		ld h,0

	m_write:			; write(fd, base, 0x200 - cnt)
		defb 0xcf, 5, 0, 0, 0, 0

		pop bc			; restore file *, cnt
		pop de

		ld a,h			; if ret != cnt
		cp b
		jr nz,fioer
		ld a,l
		cp c
		jr z,fok
	fioer:
		ld hl,6
		add hl,de
		ld a,(hl)		; set error
		or 0x20
		ld (hl),a
	fok:	
		dec hl
		ld b,(hl)
		dec hl
		ld c,(hl)
		dec hl
		ld (hl),2		; f->cnt = 0x200
		dec hl
		ld (hl),0
		dec hl
		ld (hl),b		; f->ptr = f->base
		dec hl
		ld (hl),c	
		and 0x20
		jr nz,ferr
	fend:
		ld hl, 0
		ret	
	ferr:
		ld hl, 0xffff
		ret
	end 
end

;
; and this one, which knows about fcb's, etc.
; no source code
;
block _fflush
	match _fflush
		CALL csv
		e5
		dd 6e 06
		dd 66 07
		e5
		fd e1
		11 __iob
		fd e5
		e1
		b7
		ed 52
		11 0008
		cd ANY ANY
		11 0029
		cd ANY ANY
		11 ANY ANY
		19
		dd 75 fe
		dd 74 ff
		fd cb 06 4e
		20 06
		21 ff ff
		JUMP cret
	end
	patch _fflush
		call csv
		ld l,(ix+6)	; get FILE ptr
		ld h,(ix+7)
		push hl
		pop iy
		bit 1,(iy+6) ; if IOWRT
		jr z,retffl
	retffl:
		ld hl,0
		jp cret	
	end
end

;
; close finds the fcb and calls cp/m close on it.
; close.obj
block _close
	match
		CALL csv 
		e5 06 08 dd 7e 06 CALL brelop 
		38 06 21 ff ff JUMP cret 
		11 2a 00 dd 6e 06 26 00 CALL amul 
		11 __fcb 
		19 e5 fd e1 CALL _getuid 
		dd 75 ff fd 6e 29 26 00 e5 
		CALL _setuid 
		c1 fd 7e 28 fe 02 28 1d fe 
		03 28 19 21 0c 00 e5 CALL _bdoshl 
		c1 af 6f 7c e6 05 67 7d b4 
		28 12 fd 7e 28 fe 01 20 0b 
		fd e5 21 10 00 e5 CALL _bdos 
		c1 c1 fd 36 28 00 dd 6e ff 
		26 00 e5 CALL _setuid 
		c1 21 00 00 JUMP cret 
	end
	patch _close+20
		ld		l,(IX+6)
		ld		h,0
		db		0xcf, 06
		ld		hl,0
		jp		cret
		ds		88, 0
	end
end

block write
	match
		CALL ncsv
		79 ff
		06 08
		dd 7e 06
		CALL brelop
		38 06
		21 ff ff
		JUMP cret
		11 2a 00
		dd 6e 06
		26 00
		CALL ANY ANY
		11 fcb
	end
	; write system call:  
	; file descriptor in hl,
	; RST8 04 buf.l buf.h bytes.l bytes.h
	; returns carry clear on good, byte count in hl
	; errno in hl.
	;
	patch write
		include	write.asm
	end
end

block read
	match
		CALL ncsv
		79 ff
		dd 36 fb 00
		dd 36 fc 00
		06 08
		dd 7e 06
		CALL brelop
		38 06
		21 ff ff
		JUMP cret
		11 2a 00
		dd 6e 06
		26 00
		CALL ANY ANY
		11 fcb
		19
		e5
		fd e1
	end
	patch read
		include read.asm
	end
end

block open
	match
		CALL csv
		e5
		dd 5e 08
		dd 56 09
		13
		dd 73 08
		dd 72 09
		21 03 00
		CALL ANY ANY
		f2 ANY ANY
		dd 36 08 03
		dd 36 09 00
		CALL ANY ANY
		e5
		fd e1
	end
	patch open
		ld		hl, 5
		add 	hl, sp
		ld		d,(hl)
		dec		hl
		ld		e,(hl)
		dec		hl
		ld		(sys_open+4),de
		ld		d,(hl)
		dec		hl
		ld		e,(hl)
		dec		hl
		ld		(sys_open+2),de
sys_open:
		db		0xcf, 05, 00, 00, 00, 00
		ret		nc
		ld		hl,0xffff
		ret
		ds		159,0	
	end
end

block unlink
	match
	CALL ncsv
	d3 ff
	dd 6e 06
	dd 66 07
	e5
	dd e5
	d1
	21 d6 ff
	19
	e5
	CALL ANY ANY
	c1
	c1
	7d
	b7
	28 06
	21 00 00
	JUMP cret
	end
end

block creat
	match
		CALL csv
		e5
		CALL ANY ANY
		e5
		fd e1
		7d
		b4
		20 06
		21 ff ff
		JUMP cret
		CALL ANY ANY
		dd 75 ff
		dd 6e 06
		dd 66 07
		e5
		fd e5
		CALL ANY ANY
	end
	patch creat
		ld hl,0x5
		add hl,sp
		ld d,(hl)
		dec hl
		ld e,(hl)
		dec hl
		ld (crsys+4),de
		ld d,(hl)
		dec hl
		ld e,(hl)
		dec hl
		ld (crsys+2),de
	crsys: defb 0xcf, 08, 00, 00, 00, 00
		ret nc
		ld hl, 0xffff
		ret
		ds 91,0
	end
end

;
; the compiler system interface uses 
; fopen, fclose, fwrite, fread, fflush
;
; iob { char *ptr, int cnt, char *base, char flag, char fd }
; flags (bits 0-7): rd wr nbuf mybuf eof err string binary
;

block filbuf
	match
		01 02 03 04 05 06 07 99 99 99
	end
	; f->cnt = 0
	; if (f->flag & IORD) return EOF
	; if (f->base == 0) {
	;     f->ptr = &tmp
	; count = 1;
	; } else {
	;     f->ptr = f->base
	;	  count = BUFSIZE
	; } 
	; f->cnt = read(f->fd, f->ptr, count);
	; if (f->cnt > 0) {
	;   f->cnt--;
	;   return(*f->fptr++);
	; }
    ; if (f->cnt == 0) f->flag |= EOF
	; if (f->cnt < 0) f->flag |= ERR
	; return eof
	;
	patch
		pop hl				; get f into de
		pop de
		push de
		push hl

		ld hl,6				; if ! f->flag & IORD
		add hl,de
		bit 0,(hl)
		jr z,feof
	
		dec hl				; get base
		ld b,(hl)
		dec hl
		ld c,(hl)
		ld a,b
		or c
		jr nz, fbuf			; if base, use it
		ld bc,fend+1		; else use fend+1
	fbuf:
		ld (m_read+2),bc

		ld bc,0x200			; count = BUFSIZE
		jz nz,fcnt
		ld bc,1				; if !base count = 1
	fcnt:
		ld (m_read+4),bc
		dec hl
		ld bc,-1		; assume eof 
		ld (fend+1),bc
		ld bc,0

	m_read:			; read(fd, base, 0x200 - cnt)
		defb 0xcf, 5, 0, 0, 0, 0

		ld a,0x10	; ERR bit
		jr c,ferr
		ld a,h
		or l

	feof:
		ld a,0x08	; EOF bit
		jr z,fret

		ld b,h		; save returned byte count for f->cnt
		ld c,l

	ferr:
		ld (_errno), hl

	fret:			; a = bits for flags, bc = count
		ld hl,6
		add hl,de
		or (hl)	
		ld (hl),a
		or a
		jr z,fr
		ld bc,0		; if err ret, f->cnt = 0
	fr:
		dec hl		; f->cnt = bc
		dec hl
		dec hl
		ld (hl),b
		dec hl
		ld (hl),c
		ld a,c
		or b
		jr nz,fneof

	fend:
		ld hl,-1	; store into this instruction data field
		ret		
	end
end

block fsize
	match
		CALL ncsv
		fb ff
		06 08
		dd 7e 06
		cd brelop
		38 08
		11 ff ff
		6b 62
		JUMP cret
		11 2a 00
		dd 6e 06
		26 00
		cd ANY ANY
		dd 75 fb
		fd 6e 29
	end	
end

