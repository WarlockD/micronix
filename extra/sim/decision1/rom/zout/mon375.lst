   1:				        ; subttl	'(c) 1981 Morrow Designs'
   2:					; title   'MPZ-80  MON3.75-M FIRMWARE'
   3:					.z80
   4:				
   5:				;****************************************************************
   6:				;*								*
   7:				;* Decision one CPU firmware, for the Morrow Designs / Thinker	*
   8:				;* Toys Decision one computer.	The monitor routine looks for	*
   9:				;* the power on jump addresses on CPU switches which determine 	*
  10:				;* address to begin execution (top 5 switches).	 I/O is through	*
  11:				;* the Wunderbus I/O motherboard UART 1.  Base address of the	*
  12:				;* I/O is assumed to be standard (beginning at port 48H).	*
  13:				;* If top five switches are 'On', a hard disk is assumed to be	*
  14:				;* the disk device and Boothd is executed.  Enter diagnostic	*
  15:				;* mode by grounding pin 13 of header at 12C.			*
  16:				;*								*
  17:				;* Revised 12/28/82	-	Fixed PIC initialization	*	
  18:				;*								*
  19:				;* Revised 8/27/82	-	M16 home and load constants	*
  20:				;*				changed.  group equ changed to 	*
  21:				;*				add int en bit high.		*
  22:				;*								*
  23:				;* Bobby Dale Gifford and Bob Groppo        			*
  24:				;* 10/20/81							*
  25:				;*								*
  26:				;****************************************************************
  27:				
  28:     -	0000          		org	0		;Local Ram in task zero
  29:     -	0000          	nop	equ	0
  30:     -	00C3          	jmpop	equ	0c3h		;Jump instruction op-code
  31:     -	00CD          	callop	equ	0cdh		;z80 call instruction opcode
  32:     -	002B          	t1mask	equ	2bh		;unlimited mask... no traps enabled
  33:     -	002B          	t0mask	equ	2bh		;unlimited mask	
  34:     -	0036          	ssmode	equ	036h		;single step mode mask
  35:     -	001A          	hstrap	equ	1Ah		;allow traps on halts and stops, interrupts
  36:								;- masked out in task 0 (temporary)
  37:     -	0001          	window	equ	01h		;task 0 window at location 10000
  38:     -	000D          	ACR	equ	0Dh		;carriage return
  39:     -	000A          	ALF	equ	0Ah		;line feed
  40:     -	0020          	ASP	equ	' '		;space
  41:     -	000C          	AFF	equ	0Ch		;form feed
  42:     -	0007          	BEl	equ	07H		;bell
  43:     -	0008          	BSP	equ	08H		;backspace
  44:     -	0019          	mskofst	equ	19h		;offset to get to user's mask reg. contents
  45:     -	0017          	spofst	equ	17h		;offset to stack pointer of user
  46:     -	0015          	afofst	equ	15h		;offset to user Af register
  47:     -	0013          	hlofst	equ	13h		;offset to user h,l register
  48:     -	0011          	deofst	equ	11h		;offset to d,e
  49:     -	000F          	bcofst	equ	0Fh		;offset to b,c
  50:     -	000D          	pcofst	equ	0Dh		;offset to the users pc register
  51:     -	0076          	nxtbyte	equ	076h		;byte after a halt
  52:				
  53:				;****************************************************************
  54:				;*								*
  55:				;*		   Wunderbus I/O equates:			*
  56:				;*								*
  57:				;****************************************************************
  58:     -	0048          	base	equ	048h		;I/O base address of wunderbus ports
  59:     -	0008          	group0	equ	08h
  60:     -	0009          	group1	equ	09h		;serial port 1
  61:     -	000A          	group2	equ	0Ah		;serial	port 2
  62:     -	000B          	group3	equ	0Bh		;serial port 3
  63:     -	004F          	grpctl	equ	base+7		;I/O group select port
  64:				
  65:				;	UART equates
  66:				
  67:     -	0048          	dll	equ	base		;divisor latch lsb
  68:     -	0049          	dlm	equ	base+1		;divisor latch msb
  69:     -	0049          	ier	equ	base+1		;interupt enable register
  70:     -	004B          	lcr	equ	base+3		;line control register
  71:     -	004C          	mcr	equ	base+4		;modem control register
  72:     -	004D          	lsr	equ	base+5		;line status register
  73:     -	0048          	rbr	equ	base		;read data buffer
  74:     -	0048          	thr	equ	base		;transmitter data buffer
  75:     -	0080          	dlab	equ	80h		;divisor latch access bit
  76:     -	0020          	thre	equ	20h		;status line TBE
  77:     -	0001          	dr	equ	01		;line status DR bit
  78:     -	0001          	wls0	equ	01		;word length select bit 0
  79:     -	0002          	wls1	equ	02		;word length select bit 1 (for 8 bit word)
  80:     -	0004          	stb	equ	04		;stop bit count (2 stop bits)
  81:     -	0000          	imask	equ	00		;non interupt mode
  82:     -	0010          	loop	equ	010h		;UART loop mode
  83:				
  84:				;	PIC equates
  85:				
  86:     -	0010          	init	equ	010h		;bit high to initialize the PIC
  87:     -	004C          	icw1	equ	base + 4	;PIC initialization control word 1
  88:     -	004D          	icw2	equ	base + 5	;PIC initialization control word 2
  89:     -	004D          	icw3	equ	base + 5	;PIC initialization control word 3
  90:     -	004D          	icw4	equ	base + 5	;PIC initialization control word 4
  91:     -	004D          	ocw1	equ	base + 5	;PIC interrupt mask register
  92:     -	004C          	ocw2	equ	base + 4	;PIC EOI register
  93:     -	00FF          	picmask equ	0ffh		;mask to turn all interrupts off
  94:     -	0008          	ltim	equ	08h		;level triggered mode
  95:     -	0004          	adi4	equ	04h		;call address intervals = 4
  96:     -	0000          	adi8	equ	00h		;call address intervals = 8
  97:     -	0002          	sngl	equ	02		;sole system PIC
  98:     -	0001          	ic4	equ	01h		;icw4 access bit
  99:     -	0000          	lovect	equ	0		;call vectors begin at 0
 100:     -	0000          	hivect	equ	0		;call vectors begin at 0
 101:     -	0000          	normal	equ	0		;Master/Reg. nest/unbuffered/no AEOI/8085					; -normal setting of OCW4 for Morrow Software
 102:     -	0020          	eoi	equ	20h		;non-specific EOI constant
 103:     -	001F          	ivalu	equ	init OR ltim OR adi4 OR sngl OR ic4 OR lovect
 104:				;****************************************************************
 105:				;*								*
 106:				;*	HDC Winchester controller equates			*
 107:				;*								*
 108:				;****************************************************************
 109:				
 110:     -	000D          	revnum	equ	13		
 111:     -	0050          	ioaddr	equ	120Q
 112:     -	0050          	contrl	equ	ioaddr
 113:     -	0050          	status	equ	ioaddr
 114:     -	0053          	data	equ	ioaddr+3
 115:     -	0052          	functn	equ	ioaddr+2
 116:     -	0051          	commd	equ	ioaddr+1
 117:     -	0051          	secstat equ	ioaddr+1
 118:     -	0001          	dread	equ	1
 119:     -	0001          	sector	equ	1
 120:     -	0002          	opdone	equ	2
 121:     -	0004          	complt	equ	4
 122:     -	0008          	header	equ	10Q
 123:     -	0005          	drenbl	equ	5
 124:     -	0007          	dskrun	equ	7
 125:     -	0020          	ready	equ	40Q
 126:     -	0080          	system	equ	200Q
 127:     -	00F8          	stepo	equ	370Q
 128:     -	00FC          	drivea	equ	374Q
 129:     -	0001          	trk0	equ	1
 130:				
 131:				;****************************************************************
 132:				;*								*
 133:				;*	DJ-DMA Equates						*
 134:				;*								*
 135:				;****************************************************************
 136:				
 137:     -	104A          	djstat	equ	104ah		;adjusted channel address of status byte
 138:				
 139:				;****************************************************************
 140:				;*								*
 141:				;*  	     DMA Winchester Controller Equates			*
 142:				;*								*
 143:				;****************************************************************
 144:     -	0099          	cyl	equ	153		;number cylinders for Seagate ST-506
 145:     -	0004          	heads	equ	  4		;number heads for Seagate ST-506
 146:     -	001E          	stpdly	equ	 01eh		;15 msec for Seagate ST-506
 147:     -	00C8          	hdsetl	equ	 0C8h		;20 msec for Seagate ST-506
 148:     -	0007          	secsiz	equ	  7		;1024 byte sectors for CPM
 149:     -	0000          	readat	equ	  0		;DMA controller read sector opcode
 150:     -	0001          	write	equ	  1		;DMA controller write sector opcode
 151:     -	0002          	rhead	equ	  2		;DMA controller read header opcode
 152:     -	0003          	format	equ	  3		;DMA controller format track opcode
 153:     -	0004          	const	equ	  4		;load drive constants command
 154:     -	0005          	sense	equ	  5		;return drive status command
 155:     -	0006          	noop	equ	  6		;command used when seeking
 156:     -	0054          	dmarst	equ	 54h		;DMA controller reset port
 157:     -	0055          	attn	equ	 55h		;DMA controller Attention port
 158:     -	0010          	stepout	equ	 10h		;Step direction to track 0
 159:     -	0000          	stepin	equ	  0		;Step direction away from track 0
 160:     -	0001          	track0	equ	  1		;track 0 status
 161:     -	0002          	wfault	equ	  2		;write fault condition from drive
 162:     -	0004          	dready	equ	  4		;drive ready status
 163:     -	0008          	sekcmp	equ	  8		;seek complete status
 164:     -	0011          	hdspt	equ	 17		;number of sectors per track
 165:     -	1050          	iopb	equ	1050h		;pointer to the channel
 166:     -	1080          	chan	equ	1080h		;actual channel
 167:     -	1083          	select	equ	chan + 3	;select byte in channel
 168:     -	1084          	dmaddr	equ	chan + 4	;24 bit dma address location
 169:     -	1087          	arg	equ	chan + 7	;beginning of four arguments to commands
 170:     -	108B          	cmmd	equ	chan + 11	;actual command location
 171:     -	108C          	statis	equ	chan + 12	;controller return status location 
 172:     -	108D          	link	equ	chan + 13	;link field address for next command
 173:     -	1100          	bootad	equ	1100h		;dma address for first sector from hddma
 174:     -	00FF          	good	equ	0ffh		;good status result
 175:				
 176:				;****************************************************************
 177:				;*								*
 178:				;* Decision One Ram variables, visible only to task 0.		*
 179:				;*								*
 180:				;****************************************************************
 181:				
 182:     -	0000          	ram	equ	$			;Local RAM, visible only to task 0
 183:				
 184:				;****************************************************************
 185:				;*								*
 186:				;* Supervisor entry point, this jump must be inserted into the	*
 187:				;* CPU's ram by the supervisor for subsequent entry to the	*
 188:				;* supervisor when traps occur.					*
 189:				;*								*
 190:				;****************************************************************
 191:				
 192:    0+10	0000  C30000  	super:	jp	super			;Supervisor entry point
 193:   10+10	0003  C30300  	user:	jp	user			;(7) User entry point
 194:				
 195:     -	0006  00      	ctask:	db	0			;Current task
 196:     -	0007  00      	cmask:	db	0			;Current mask contents
 197:				
 198:				;****************************************************************
 199:				;*								*
 200:				;* Task save areas. Each of the tasks 1-15 have one of these	*
 201:				;* structures associated with it.  When tskbase returns, HL	*
 202:				;* will point to u.ir for that task + 0 offset.        		*
 203:				;*								*
 204:				;*             offset						*
 205:				;*	u.ir    +0	Interrupt register	(1 byte)	*
 206:				;*	u.ix	+1	Index registers		(2 bytes)	*
 207:				;*	u.iy	+3				(2 bytes)	*
 208:				;*	u.abc	+5	Alternate registers	(2 bytes)	*
 209:				;*	u.ade	+7				(2 bytes)	*
 210:				;*	u.ahl	+9				(2 bytes)	*
 211:				;*	u.aaf	+B				(2 bytes)	*
 212:				;*	u.pc	+D	Task PC			(2 bytes)	*
 213:				;*	u.bc	+F	Task registers		(2 bytes)	*
 214:				;*	u.de	+11				(2 bytes)	*
 215:				;*	u.hl	+13				(2 bytes)	*
 216:				;*	u.af	+15				(2 bytes)	*
 217:				;*	u.sp	+17	Stack pointer		(2 bytes)	*
 218:				;*	u.mask	+19	Mask register contents.	(1 bytes)	*
 219:				;*								*
 220:				;****************************************************************
 221:				
 222:     -	001A          	tasksiz	equ	26
 223:     -	0008          	tasks:	ds	tasksiz		;Task 1
 224:     -	0022          		ds	tasksiz		;Task 2
 225:     -	003C          		ds	tasksiz		;Task 3
 226:     -	0056          		ds	tasksiz		;Task 4
 227:     -	0070          		ds	tasksiz		;Task 5
 228:     -	008A          		ds	tasksiz		;Task 6
 229:     -	00A4          		ds	tasksiz		;Task 7
 230:     -	00BE          		ds	tasksiz		;Task 8
 231:     -	00D8          		ds	tasksiz		;Task 9
 232:     -	00F2          		ds	tasksiz		;Task 10
 233:     -	010C          		ds	tasksiz		;Task 11
 234:     -	0126          		ds	tasksiz		;Task 12
 235:     -	0140          		ds	tasksiz		;Task 13
 236:     -	015A          		ds	tasksiz		;Task 14
 237:     -	0174          		ds	tasksiz		;Task 15
 238:				
 239:				
 240:     -	018E  00      	u.save:	db	0		;Start of user save area
 241:     -	018F  00      	u.ir:	db	0		;Temporary user interrupt reg. save
 242:     -	0190  00000000		dw	0,0,0,0,0,0	;ix,iy,bc',de',hl',af'
	      00000000
	      00000000
 243:     -	019C  0000    	u.pc:	dw	0		;Temporary user pc storage
 244:     -	019E  00000000		dw	0,0,0		;bc,de,hl
	      0000
 245:     -	01A4  0000    	u.af:	dw	0		;Temporary user af storage
 246:     -	01A6  0000    	u.sp:   dw      0               ;temporary user stack storage
 247:     -	01A8  0000    	u.mask:	dw	0		;temporary mask storage
 248:     -	01AA          	gobuff	equ	$
 249:     -	01AA          		ds	14		;task boot buffer
 250:     -	01B8          	ersav	equ	$	
 251:     -	01B8          	      	ds	200h-(ersav-ram);Fill out the ram
 252:     -	0200          	stack	equ	$		;End of local ram
 253:				
 254:				;****************************************************************
 255:				;*								*
 256:				;* The following map is used to hold an image of the current	*
 257:				;* memory map for all tasks.					*
 258:				;*								*
 259:				;****************************************************************
 260:				
 261:     -	0200          	map:	ds	200h			;Task Memory map image
 262:				
 263:				;****************************************************************
 264:				;*								*
 265:				;* Decision One local I/O map, the following registers are	*
 266:				;* memory mapped into task 0, and are always visible to task	*
 267:				;* zero only.							*
 268:				;*								*
 269:				;****************************************************************
 270:				
 271:     -	0400          	locio	equ	$			;Local I/O, visible only to task 0
 272:				trpadd:	ds	0			;Trapp address register (read)
 273:     -	0400          	dspseg:	ds	1			;Display segment register (write)
 274:				keybd:	ds	0			;Key board register (read)
 275:     -	0401          	dspcol:	ds	1			;Display column register (write)
 276:				switch:	ds	0			;CPU switch port (read)
 277:     -	0402          	task:	ds	1			;Task register (write)
 278:				stats:	ds	0			;Trap status register (read)
 279:     -	0403          	mask:	ds	1			;Task mask register (write)
 280:     -	0404          	elocio	equ	$			;End of local I/O
 281:				
 282:     -	0404          		ds	200h-(elocio-locio)	;Fill out local I/O
 283:				
 284:				;****************************************************************
 285:				;*								*
 286:				;* The following ram is the actual memory map, it can only be	*
 287:				;* written into, so an image is kept in the local ram.		*
 288:				;*								*
 289:				;****************************************************************
 290:				
 291:     -	0600          	mapram:	ds	200h			;Memory Map RAM, visible only to task 0
 292:				
 293:				;****************************************************************
 294:				;*								*
 295:				;* Decision One prom routines, usable by the supervisor task	*
 296:				;* only after a reset but not accessible by any other tasks.	*
 297:				;*								*
 298:				;****************************************************************
 299:				
 300:     -	0800          	rom0	equ	$			;Local ROM, visible only to task 0
 301:									;and is visible only during RESET
 302:				
 303:				;****************************************************************
 304:				;*								*
 305:				;* Reset is executed only once. Currently, reset forms an	*
 306:				;* identity map for task zero to occupy the first 64K of main	*
 307:				;* memory, allows task 0 to have unlimited priviledges. Task1   *
 308:				;* occupies the first 64K, unlimited access and the traps are  	*
 309:				;* set for halts or a stop. All other task maps are initialized *
 310:				;* starting at bank 2 to bank 15. (e.g. task 15 has bank 15).	*
 311:				;* If swithches are set with S1 through S7 off and S8 on, the   *
 312:				;* power on jump address will be F800. If switch 6 is on, the	*
 313:				;* program will jump to the monitor regardless of the state	*
 314:				;* of the other switches.  If S1 - S5 are all 'ON' a MORROW	*
 315:				;* hard disk is assumed and the 'Boothd' program is executed.	*
 316:				;* If pin 2 of 15D is lifted, the diag nostic mode is entered.	*
 317:				;*								*
 318:				;****************************************************************
 319:				
 320:				
 321:				; Check all the readable registers
 322:				
 323:				
 324:   20+11	0800  D3FF    	regrd:  out	(0ffh),a		;sync
 325:   31+10	0802  210004  		ld	hl,trpadd
 326:   41+7	0805  7E      		ld	a,(hl)			;read trap address reg @ 400h
 327:   48+6	0806  23      		inc	hl			
 328:   54+7	0807  7E      		ld	a,(hl)			;read keyboard reg @ 401h
 329:   61+6	0808  23      		inc	hl
 330:   67+7	0809  7E      		ld	a,(hl)			;read switch reg @ 402h
 331:   74+6	080A  23      		inc	hl
 332:   80+7	080B  7E      		ld	a,(hl)			;read trap status reg @ 403h
 333:   87+12	080C  184C    		jr	getsw
 334:				
 335:				
 336:				
 337:				; Check all the writable registers
 338:				
 339:   99+4	080E  AF      	regwr:	xor	a			;loop till switch not 00
 340:  103+11	080F  D3FF    	regwr1:	out	(0ffh),a		;sync
 341:  114+13	0811  320304  		ld	(mask),a		;write to the mask register
 342:  127+13	0814  320104  		ld	(dspcol),a		;write to the display column register
 343:  140+13	0817  320004  		ld	(dspseg),a		;write to the display segment reg.
 344:  153+4	081A  2F      		cpl	
 345:  157+7	081B  FEFF    		cp	0ffh
 346:  164+7+5	081D  28F0    		jr	z,regwr1
 347:  171+12	081F  1839    		jr	getsw
 348:				
 349:				
 350:				; Check the Map RAMs
 351:				
 352:  183+4	0821  AF      	tmap:   xor	a			;write to map ram / protection ram
 353:  187+10	0822  210006  		ld	hl,mapram
 354:  197+11	0825  D3FF    		out	(0ffh),a		;sync
 355:  208+7	0827  77      		ld	(hl),a			;write location 600,0
 356:  215+6	0828  23      		inc	hl
 357:  221+7	0829  77      		ld	(hl),a			;write 601,0
 358:  228+4	082A  2F      		cpl
 359:  232+7	082B  77      		ld	(hl),a			;write 601,0ffh
 360:  239+6	082C  2B      		dec	hl
 361:  245+7	082D  77      		ld	(hl),a			;write 600,0ffh
 362:  252+10	082E  21FE07  		ld	hl,mapram + 01feh
 363:  262+7	0831  77      		ld	(hl),a			;write 7fe,0ff
 364:  269+6	0832  23      		inc	hl
 365:  275+7	0833  77      		ld	(hl),a			;write 7ff,0ff
 366:  282+4	0834  2F      		cpl
 367:  286+7	0835  77      		ld	(hl),a			;write 7ff,00
 368:  293+6	0836  2B      		dec	hl
 369:  299+7	0837  77      		ld	(hl),a			;write 7fe,00
 370:  306+12	0838  1820    		jr	getsw
 371:				
 372:				
 373:				; Check the R/W RAMs
 374:				
 375:				
 376:  318+10	083A  210000  	tram:	ld	hl,0000h		;write to read/write ram
 377:  328+11	083D  D3FF    		out	(0ffh),a
 378:  339+4	083F  AF      	tram1:	xor	a
 379:  343+7	0840  77      		ld	(hl),a			;write a 00 to ram 
 380:  350+7	0841  BE      		cp	(hl)			;read it back
 381:  357+4	0842  2F      		cpl
 382:  361+7	0843  77      		ld	(hl),a			;write an ffh to ram 
 383:  368+7	0844  BE      		cp	(hl)			;read it back
 384:  375+8	0845  CB44    		bit	0,h
 385:  383+7+5	0847  2011    		jr	nz,getsw
 386:  390+10	0849  21FF03  		ld	hl,03ffh
 387:  400+12	084C  18F1    		jr      tram1			;write to 3ffh a ffh
 388:				
 389:				; Check the Floating Point Processor
 390:				
 391:				
 392:  412+4	084E  AF      	tfpp:   xor	a			;check FPP
 393:  416+11	084F  D3FF    		out	(0ffh),a		;sync
 394:  427+13	0851  32000C  		ld	(0c00h),a		;write a 00 to location C00h
 395:  440+13	0854  32080C  		ld	(0c08h),a		;write a 00 to location C08h
 396:  453+13	0857  3A000C  		ld	a,(0c00h)		;read c00h
 397:				
 398:				
 399:  466+13	085A  3A0104  	getsw:	ld	a,(keybd)		
 400:  479+8	085D  CB4F    		bit	1,a
 401:  487+10	085F  CAE308  	reset:	jp	z,reset0		;go to the montior if  low
 402:  497+13	0862  3A0204  		ld	a,(switch)
 403:  510+8	0865  CB57    		bit	2,a
 404:  518+10	0867  CAE308  		jp	z,reset0		;go to the monitor if S6 is on
 405:  528+7	086A  E670    		and	070h			;strip insignificant bits
 406:  535+8	086C  CB0F    		rrc	a			;4 byte offset
 407:  543+8	086E  CB0F    		rrc	a
 408:  551+10	0870  21D00B  		ld	hl,jtable		;point to beginning of table
 409:  561+4	0873  85      		add	a,l
 410:  565+4	0874  6F      		ld	l,a
 411:  569+4	0875  E9      		jp	(hl)
 412:				
 413:				; Check the S-100 bus addr and data lines
 414:				
 415:				
 416:  573+7	0876  3EF0    	tbus:   ld	a,0f0h
 417:  580+13	0878  320204  		ld	(task),a		;force upper task bits high
 418:  593+7	087B  3EFF    		ld	a,0ffh			;init the T0 map
 419:  600+13	087D  321E06  		ld	(61eh),a
 420:  613+7	0880  3E03    		ld	a,03
 421:  620+13	0882  321F06  		ld	(61fh),a
 422:  633+13	0885  320306  		ld	(603h),a
 423:  646+4	0888  AF      		xor	a
 424:  650+13	0889  320206  		ld	(602h),a
 425:  663+11	088C  D3FF    		out	(0ffh),a		;sync
 426:  674+13	088E  32FFFF  		ld	(0ffffh),a		;write - bus addresses A0-23 are high
 427:  687+13	0891  320204  		ld	(task),a		;upper task bits low
 428:  700+13	0894  320010  		ld	(1000h),a		;write - bus addresses A0-23 are low
 429:  713+7	0897  3EF0    		ld	a,0f0h
 430:  720+13	0899  320204  		ld	(task),a		;force upper task bits high
 431:  733+13	089C  3AFFFF  		ld	a,(0ffffh)		;read  - bus addresses A0-23 are high
 432:  746+4	089F  AF      		xor	a
 433:  750+13	08A0  320204  		ld	(task),a		;force upper task bits low
 434:  763+13	08A3  3A0010  		ld	a,(1000h)		;read  - bus addresses A0-23 are low
 435:  776+12	08A6  18B2    		jr	getsw
 436:				
 437:				
 438:  788+7	08A8  3EA0    	ntbus:  ld	a,0A0h
 439:  795+13	08AA  320204  		ld	(task),a		;force upper task bits high
 440:  808+7	08AD  3EAA    	        ld	a,0aah			;init the T0 map
 441:  815+13	08AF  321E06  		ld	(61eh),a
 442:  828+7	08B2  3E03    		ld	a,03
 443:  835+13	08B4  321F06  		ld	(61fh),a
 444:  848+13	08B7  320306  		ld	(603h),a
 445:  861+7	08BA  3E55    		ld	a,55h
 446:  868+13	08BC  320206  		ld	(602h),a
 447:  881+11	08BF  D3FF    		out	(0ffh),a		;sync
 448:  892+7	08C1  3EAA    		ld	a,0aah
 449:  899+13	08C3  32AAFA  		ld	(0faaah),a		;write - bus addresses A0-23 = AAAAAA
 450:  912+7	08C6  3E50    		ld	a,50h
 451:  919+13	08C8  320204  		ld	(task),a		;upper task bits low = 5
 452:  932+7	08CB  3E55    		ld	a,55h
 453:  939+13	08CD  325515  		ld	(1555h),a		;write - bus addresses A0-23 are low
 454:  952+7	08D0  3EA0    		ld	a,0A0h
 455:  959+13	08D2  320204  		ld	(task),a		;force upper task bits high
 456:  972+13	08D5  3AAAFA  		ld	a,(0faaah)		;read  - bus addresses A0-23 are high
 457:  985+7	08D8  3E50    		ld	a,050h
 458:  992+13	08DA  320204  		ld	(task),a		;force upper task bits low
 459: 1005+13	08DD  3A5515  		ld	a,(1555h)		;read  - bus addresses A0-23 are low
 460: 1018+10	08E0  C35A08  		jp	getsw
 461:				
 462:					
 463:				; Initialize the maps and jump vectors
 464:				
 465:				
 466: 1028+17	08E3  CDEF08  	reset0: call	reset1
 467: 1045+17	08E6  CD2B0B  		call	uartst
 468: 1062+17	08E9  CD2209  		call	setup
 469: 1079+10	08EC  C3AA01  		jp	gobuff
 470:				
 471: 1089+10	08EF  210000  	reset1:	ld	hl,super		;initialize 'super' to the monitor...
 472: 1099+6	08F2  2B      	settle:	dec	hl			;wait for the hardware to settle down
 473: 1105+4	08F3  7D      		ld	a,l
 474: 1109+4	08F4  B4      		or	h
 475: 1113+7+5	08F5  20FB    		jr	nz,settle
 476: 1120+10	08F7  36C3    		ld	(hl),jmpop		;- this will be overwritten by the
 477: 1130+6	08F9  23      		inc	hl			;- supervisor but all traps in the 
 478: 1136+10	08FA  3612    		ld	(hl),012h		;- meantime will fall into the monitor.
 479: 1146+6	08FC  23      		inc 	hl
 480: 1152+10	08FD  3608    		ld	(hl),08h
 481:				
 482: 1162+4	08FF  AF      	reslop: xor	a
 483: 1166+7	0900  0E03    		ld	c,3			;New access priviledges
 484: 1173+4	0902  47      	reslp2: ld	b,a			;New allocation = segment #
 485: 1177+17	0903  CD180B  		call	rstmap			;Allocate it
 486: 1194+4	0906  3C      		inc	a			;Next segment #
 487: 1198+7	0907  E60F    		and	0fh			;Check if all done
 488: 1205+7+5	0909  20F7    		jr	nz,reslp2		;Continue until done
 489: 1212+7	090B  3E10    	        LD	A,10h			;write new task and segment
 490: 1219+7	090D  0600    		LD	B,0			;TASK 1 gets first 64K of memory
 491: 1226+17	090F  CD180B  	reslp1: call    rstmap			;Give TASK 1 a full 64k of space
 492: 1243+4	0912  04      		inc	B			
 493: 1247+4	0913  3C      		inc	A			
 494: 1251+7	0914  FE20    		cp      20h			
 495: 1258+7+5	0916  20F7    		jr	nz,reslp1						
 496: 1265+4	0918  47      	fmap:	ld	b,a			;fill all the tasks' maps
 497: 1269+17	0919  CD180B  		call	rstmap
 498: 1286+4	091C  3C      		inc	a
 499: 1290+7	091D  FE00    		cp	0h
 500: 1297+7+5	091F  20F7    		jr	nz,fmap
 501: 1304+10	0921  C9      		ret
 502:				
 503:					
 504:				
 505: 1314+4	0922  AF      	setup:	xor	a
 506: 1318+13	0923  320206  		ld	(mapram + 2),a		;a window for DMA device commands
 507: 1331+13	0926  320202  		ld	(map + 2),a		;update the image map
 508: 1344+13	0929  32B801  		ld	(ersav),a		;null the error save byte
 509: 1357+7	092C  3E1A    		ld	a,hstrap		;initialize the mask register
 510: 1364+13	092E  320304  		ld	(mask),a		; -to trap on halts and stops
 511: 1377+13	0931  320700  		ld	(cmask),a
 512:				
 513:				;	Following code checks for ram in system
 514:				
 515: 1390+10	0934  21FFFF  		ld	hl,0ffffh		;top of ram
 516: 1400+7	0937  3EF0    	ramchk:	ld	a,0f0h
 517: 1407+4	0939  A4      		and	h
 518: 1411+7+5	093A  2812    		jr	z,badram		;dont go below task0,seg1	
 519: 1418+7	093C  77      		ld	(hl),a			;check it with a 00h
 520: 1425+7	093D  BE      		cp	(hl)			
 521: 1432+7+5	093E  2803    		jr	z,nexchk
 522: 1439+6	0940  2B      		dec	hl			;try the next location
 523: 1445+12	0941  18F4    		jr	ramchk
 524: 1457+4	0943  2F      	nexchk:	cpl	
 525: 1461+7	0944  77      		ld	(hl),a			;check it with an ff (might be ROM)
 526: 1468+7	0945  BE      		cp	(hl)
 527: 1475+16	0946  22B901  		ld	(ersav + 1),hl		;store it away for printing
 528: 1491+7+5	0949  2811    		jr	z,tstsw					
 529: 1498+6	094B  2B      		dec	hl			;try next location
 530: 1504+12	094C  18E9    		jr	ramchk
 531:				
 532: 1516+10	094E  21AD0B  	badram: ld	hl,0badh
 533: 1526+16	0951  22B901  		ld	(ersav + 1),hl
 534: 1542+7	0954  3E4D    		ld	a,'M'
 535: 1549+13	0956  32B801  		ld	(ersav),a
 536: 1562+10	0959  C36B0A  		jp 	allerr			;if no ram force entry to monitor
 537:				
 538: 1572+13	095C  3A0204  	tstsw:	ld	a,(switch)		;get contents of switch
 539: 1585+7	095F  E6F8    		and	0f8h			;Ignore irrelevent bits
 540: 1592+4	0961  57      		ld	d,a			;d & e contain jump address
 541: 1596+7	0962  1E00    		ld	e,0H
 542: 1603+7	0964  FE00    		cp	0			;boot hard disk if switches are all on
 543: 1610+10	0966  CAA30A  		jp	z,boothd
 544: 1620+7	0969  FE08    		cp	08h			;If switch 5 is off others are on
 545: 1627+10	096B  CAF709  		jp	z,nuboot		; - boot DMA controller
 546: 1637+7	096E  FE10    		cp	10h			;If switches 4 is off, others on
 547: 1644+7+5	0970  2857    		jr	z,djdma			; - boot the DJ-DMA floppy device
 548:				
 549: 1651+13	0972  3A0204  	check:	ld	a,(switch)		;test monitor switch
 550: 1664+8	0975  CB57    		bit  	2,a
 551: 1672+7	0977  3E01    		ld	a,1			;normal task number
 552: 1679+20	0979  ED531500		ld	(15h),de		;initialize the t1 pc save area
 553: 1699+13	097D  320600  		ld	(ctask),a
 554: 1712+7+5	0980  2004    		jr	nz,nutask		;jump if boot desired
 555:				
 556: 1719+4	0982  AF      	montor:	xor	a			;monitor task number
 557: 1723+10	0983  111609  		ld	de,cold			;monitor location
 558:				
 559: 1733+10	0986  21AA01  	nutask: ld	hl,gobuff		;Write a routine to switch to new task
 560: 1743+10	0989  363E    		ld	(hl),03eh		;- because when the task register is
 561: 1753+6	098B  23      		inc	hl			;- written into, the lower half of the
 562: 1759+7	098C  77      		ld	(hl),a			;- prom goes away.
 563: 1766+6	098D  23      		inc	hl
 564: 1772+10	098E  3632    		ld	(hl),032h
 565: 1782+6	0990  23      		inc	hl
 566: 1788+10	0991  3602    		ld	(hl),02h
 567: 1798+6	0993  23      		inc	hl
 568: 1804+10	0994  3604    		ld	(hl),04h
 569: 1814+6	0996  23      		inc	hl
 570: 1820+10	0997  3600    		ld	(hl),nop		;6 nops for countdown sequence
 571: 1830+6	0999  23      		inc	hl
 572: 1836+10	099A  3600    		ld	(hl),nop
 573: 1846+6	099C  23      		inc	hl
 574: 1852+10	099D  3600    		ld	(hl),nop
 575: 1862+6	099F  23      		inc	hl
 576: 1868+10	09A0  3600    		ld	(hl),nop
 577: 1878+6	09A2  23      		inc	hl
 578: 1884+10	09A3  3600    		ld	(hl),nop
 579: 1894+6	09A5  23      		inc	hl
 580: 1900+10	09A6  3600    		ld	(hl),nop
 581: 1910+6	09A8  23      		inc	hl
 582: 1916+10	09A9  36C3    		ld	(hl),0c3h		;the jump op code
 583: 1926+6	09AB  23      		inc	hl
 584: 1932+7	09AC  73      		ld	(hl),e
 585: 1939+6	09AD  23      		inc	hl
 586: 1945+7	09AE  72      		ld	(hl),d
 587:				
 588:				
 589:				;****************************************************************
 590:				;*								*
 591:				;*	Wunderbuss I/O and Mult I/O PIC initialization	rou-	*
 592:				;*	tine.  Interrupt vectors = restart locations.		*
 593:				;*								*
 594:				;****************************************************************
 595:				
 596: 1952+4	09AF  AF      	picset:	xor     a
 597: 1956+11	09B0  D34F    		out	(grpctl),a
 598: 1967+7	09B2  3E1F    		ld	a,ivalu			;sngl,level,4 byte address
 599: 1974+11	09B4  D34C    		out	(icw1),a		;initialize the first word
 600: 1985+7	09B6  3E00    		ld	a,hivect
 601: 1992+11	09B8  D34D    		out	(icw2),a		;initialize the second word
 602: 2003+7	09BA  3E00    		ld	a,normal
 603: 2010+11	09BC  D34D    		out	(icw4),a		;initialize the forth word
 604: 2021+7	09BE  3EFF    		ld	a,picmask
 605: 2028+11	09C0  D34D    		out	(ocw1),a		;mask all interrupts
 606: 2039+7	09C2  3E20    		ld	a,eoi			;send PIC an End of Interrupt word
 607: 2046+11	09C4  D34C    		out	(ocw2),a		;clear the master interrupt requests
 608: 2057+11	09C6  D34C    		out	(ocw2),a		;clear the slaves interrupt requests
 609: 2068+10	09C8  C9      		ret
 610:				
 611:				
 612:				;****************************************************************
 613:				;*								*
 614:				;* DJ-DMA floppy disk boot routine (5.25 or 8 inch).		*
 615:				;*								*
 616:				;****************************************************************
 617:				
 618: 2078+7	09C9  2610    	djdma:	ld	h,10h			; wait byte for 1 minute 
 619: 2085+10	09CB  010000  	djlop0:	ld	bc,0000h
 620: 2095+13	09CE  3A4A10  	djloop:	ld	a,(djstat)		;read the status back
 621: 2108+7	09D1  FE40    		cp	040h
 622: 2115+20	09D3  ED5B4810		ld	de,(djstat - 2)		;d & e point to cold boot loader
 623: 2135+7+5	09D7  2899    		jr	z,check			;if good status continue set gobuff
 624: 2142+7	09D9  FEFF    		cp	0ffh			; - else loop for good status
 625: 2149+7+5	09DB  2814    		jr	z,nstat			;if 0ffh then force to a zero
 626: 2156+6	09DD  0B      		dec	bc
 627: 2162+4	09DE  78      		ld	a,b
 628: 2166+4	09DF  B1      		or	c
 629: 2170+7+5	09E0  20EC    		jr	nz,djloop
 630: 2177+4	09E2  25      		dec	h
 631: 2181+7+5	09E3  20E6    		jr	nz,djlop0		;continue looping till a minute elapses
 632:				
 633:				;	DJ-DMA not responding correctly
 634:				
 635: 2188+7	09E5  0E46    		ld	c,'F'
 636: 2195+13	09E7  3A4A10  		ld	a,(djstat)
 637: 2208+4	09EA  47      		ld	b,a			;save the error status
 638: 2212+13	09EB  3A4810  		ld	a,(djstat - 2)
 639: 2225+4	09EE  57      		ld	d,a
 640: 2229+12	09EF  1871    		jr	derror			;go to error--controller not
 641:									; - responding
 642:				
 643: 2241+4	09F1  AF      	nstat: 	xor	a
 644: 2245+13	09F2  324A10  		ld	(djstat),a		;null status byte ... signal DJ-DMA
 645: 2258+12	09F5  18D7    		jr	djloop
 646:				
 647:				;****************************************************************
 648:				;*								*
 649:				;* Hard Disk Boot program for the DMA Winchester Controller.	*
 650:				;*								*
 651:				;****************************************************************
 652:				
 653: 2270+10	09F7  011000  	nuboot:	ld	bc,endboot - bootbl	;byte count
 654: 2280+10	09FA  21B30B  		ld	hl,bootbl		;source
 655: 2290+10	09FD  118010  		ld	de,chan			;destination
 656: 2300+16+5	0A00  EDB0    		ldir				;move the command
 657: 2316+10	0A02  215010  		ld	hl,iopb			;point to default channel addr
 658: 2326+10	0A05  3680    		ld	(hl),80h		;fill in the command channel address
 659: 2336+4	0A07  AF      		xor	a
 660: 2340+6	0A08  23      		inc	hl			; -located at 50h to point to channel
 661: 2346+7	0A09  77      		ld	(hl),a			; -at 80h.
 662: 2353+6	0A0A  23      		inc	hl
 663: 2359+7	0A0B  77      		ld	(hl),a
 664: 2366+11	0A0C  D354    		out	(dmarst),a		;send the controller a reset
 665: 2377+10	0A0E  111000  		ld	de,010h
 666:				
 667: 2387+4	0A11  15      	hdrl:	dec	d			;wait for controller to process reset
 668: 2391+7+5	0A12  20FD    		jr	nz,hdrl
 669: 2398+17	0A14  CD3E0A  		call	cloop
 670:				
 671: 2415+10	0A17  21FFFF  	home:	ld	hl,-1  			;seek to home
 672: 2425+16	0A1A  228110  	        ld      (chan + 1),hl           ; - with ffff steps
 673: 2441+7	0A1D  3E06    		ld	a,noop
 674: 2448+13	0A1F  328B10  		ld	(statis - 1),a		;null command 
 675: 2461+7	0A22  3E01    		ld	a,1
 676: 2468+13	0A24  328C10  		ld	(statis),a		;set up the status byte
 677: 2481+17	0A27  CD3E0A  		call	cloop
 678:					
 679: 2498+10	0A2A  118010  	rdata: 	ld	de,chan			;destination
 680: 2508+10	0A2D  010D00  		ld	bc,endrd - rdtbl	;byte count
 681: 2518+10	0A30  21C30B  		ld	hl,rdtbl		;source
 682: 2528+16+5	0A33  EDB0    		ldir				;move the read sector command
 683: 2544+17	0A35  CD3E0A  		call	cloop
 684: 2561+10	0A38  110001  		ld	de,0100h		;point to beginning of DMA boot prog.
 685: 2571+10	0A3B  C37209  		jp	check
 686:				
 687:				
 688:				; cloop1 = 9.6 us
 689:				
 690:							
 691: 2581+7	0A3E  0E20    	cloop:	ld	c,020h
 692: 2588+11	0A40  D355    	cloop0:	out	(attn),a
 693: 2599+10	0A42  110000  		ld	de,0000h
 694: 2609+13	0A45  3A8C10  	cloop1: ld	a,(statis)		;check drive status
 695: 2622+7	0A48  FEFF    		cp	0ffh			;an FF means command completed
 696: 2629+5+6	0A4A  C8      		ret	z
 697: 2634+6	0A4B  1B      		dec	de			;wait for controller to respond
 698: 2640+4	0A4C  7B      		ld	a,e
 699: 2644+4	0A4D  B2      		or	d
 700: 2648+7+5	0A4E  20F5    		jr	nz,cloop1		;give it time to respond
 701:									;end cloop1
 702:				
 703:				;	Fall through to here on any error
 704:				
 705: 2655+13	0A50  3A8C10  		ld	a,(statis)
 706: 2668+7	0A53  FE01    		cp	01h
 707: 2675+7+5	0A55  2003    		jr	nz,cloop2	
 708: 2682+4	0A57  0D      		dec	c			;give it 10 tries if not rdy error
 709: 2686+7+5	0A58  20E6    		jr	nz,cloop0		; - about 20 seconds
 710:				
 711: 2693+10	0A5A  D1      	cloop2:	pop	de			;re-align the stack pointer
 712: 2703+4	0A5B  47      		ld	b,a
 713: 2707+7	0A5C  0E48    		ld	c,'H'
 714: 2714+13	0A5E  3A8B10  		ld	a,(cmmd)
 715: 2727+4	0A61  57      		ld	d,a
 716:				
 717:				;****************************************************************
 718:				;*								*
 719:				;* Enter here if DISK controllers don't respond correctly.	*
 720:				;* Routine alters gobuff to point to the monitor cout routine.	*	
 721:				;*								*
 722:				;****************************************************************
 723:				
 724:     -	0A62          	derror:	
 725: 2731+4	0A62  79      		ld	a,c
 726: 2735+10	0A63  21B801  		ld	hl,ersav
 727: 2745+7	0A66  77      		ld	(hl),a			;store c for later
 728: 2752+6	0A67  23      		inc	hl
 729: 2758+7	0A68  70      		ld	(hl),b			;error status
 730: 2765+6	0A69  23      		inc	hl
 731: 2771+7	0A6A  72      		ld	(hl),d			;command causing error 
 732: 2778+4	0A6B  AF      	allerr:	xor	a
 733: 2782+13	0A6C  320600  		ld	(ctask),a
 734: 2795+10	0A6F  111609  		ld	de,cold			;pointer to error print
 735: 2805+20	0A72  ED531500		ld	(15h),de		;save the pointer in t1 pc
 736: 2825+10	0A76  C38609  		jp	nutask			
 737:					
 738:				
 739:					
 740:				;****************************************************************
 741:				;*								*
 742:				;* Hard Disk Boot program for Decision 1 EPROM.			*
 743:				;* For M26, M10, and M20.					*
 744:				;*						11/4/81  BJG	*
 745:				;****************************************************************
 746:				
 747: 2835+10	0A79  110000  	hdclop:	ld	de,0000h
 748: 2845+11	0A7C  DB50    	hdlop1: in	a,(status)
 749: 2856+4	0A7E  A0      		and	b
 750: 2860+5+6	0A7F  C0      		ret	nz
 751: 2865+6	0A80  1B      		dec	de
 752: 2871+4	0A81  7A      		ld	a,d
 753: 2875+4	0A82  B3      		or	e
 754: 2879+7+5	0A83  20F7    		jr	nz,hdlop1
 755: 2886+12	0A85  1812    		jr	hdcerr
 756:				
 757: 2898+7	0A87  2610    	wait:	ld	h,010h
 758: 2905+10	0A89  110000  	wait0:	ld	de,0
 759: 2915+11	0A8C  DB50    	wait1:	in	a,(status)
 760: 2926+4	0A8E  A0      		and	b
 761: 2930+5+6	0A8F  C8      		ret	z
 762: 2935+6	0A90  1B      		dec	de
 763: 2941+4	0A91  7A      		ld	a,d
 764: 2945+4	0A92  B3      		or	e
 765: 2949+7+5	0A93  20F7    		jr	nz,wait1
 766: 2956+4	0A95  25      		dec	h
 767: 2960+7+5	0A96  20F1    		jr	nz,wait0
 768: 2967+10	0A98  E1      		pop	hl			;re-align the stack pointer
 769: 2977+7	0A99  0E44    	hdcerr: ld	c,'D'			; D for HDCA error flag
 770: 2984+11	0A9B  DB50    		in	a,(status)		;get the primary status
 771: 2995+4	0A9D  47      		ld	b,a
 772: 2999+11	0A9E  DB51    		in	a,(secstat)		;get the secondary status
 773: 3010+4	0AA0  57      		ld	d,a
 774: 3014+12	0AA1  18BF    		jr	derror
 775:				
 776: 3026+7	0AA3  3EFC    	boothd:	ld	a,drivea		;select
 777: 3033+11	0AA5  D352    		out	(functn),a		;    drive A
 778: 3044+7	0AA7  3E05    		ld	a,drenbl		;turn on drive
 779: 3051+11	0AA9  D350    		out	(contrl),a		;    command register
 780:				
 781: 3062+7	0AAB  0620    	rloop:	ld	b,ready
 782: 3069+17	0AAD  CD870A  		call	wait
 783: 3086+7	0AB0  3E07    		ld	a,dskrun		;enable the
 784: 3093+11	0AB2  D350    		out	(contrl),a		;    controller
 785:				
 786: 3104+11	0AB4  DB50    	waitz:	in	a,(status)		;test for heads at track 0
 787: 3115+4	0AB6  1F      		rra
 788: 3119+7+5	0AB7  300F    		jr	nc,sdone
 789: 3126+7	0AB9  3EF8    		ld	a,stepo			;execute
 790: 3133+11	0ABB  D352    		out	(functn),a		;    the
 791: 3144+7	0ABD  3EFC    		ld	a,drivea		;    step out
 792: 3151+11	0ABF  D352    		out	(functn),a		;    command
 793:				
 794: 3162+7	0AC1  0604    	waitc:  ld	b,complt
 795: 3169+17	0AC3  CD790A  		call	hdclop
 796: 3186+12	0AC6  18EC    		jr	waitz
 797:				
 798: 3198+11	0AC8  DB50    	sdone:	in	a,(status)		;get an image
 799: 3209+4	0ACA  4F      		ld	c,a			;    of the status reg
 800:				
 801: 3213+11	0ACB  DB50    	iwait1: in	a,(status)		;wait for
 802: 3224+4	0ACD  91      		sub	c			;    the index pulse
 803: 3228+7+5	0ACE  28FB    		jr	z,iwait1		;    to arrive
 804:				
 805: 3235+11	0AD0  DB50    	iwait2: in	a,(status)		;wait for the
 806: 3246+4	0AD2  91      		sub	c			;    next index pulse
 807: 3250+7+5	0AD3  20FB    		jr	nz,iwait2		;test for head settle
 808:				
 809: 3257+11	0AD5  DB50    	iwait3:	in	a,(status)
 810: 3268+4	0AD7  91      		sub	c
 811: 3272+7+5	0AD8  28FB    		jr	z,iwait3
 812: 3279+7	0ADA  3E08    		ld	a,header		;reset the
 813: 3286+11	0ADC  D351    		out	(commd),a		;    buffer pointer
 814: 3297+4	0ADE  AF      		xor	a			;    to header area
 815: 3301+11	0ADF  D353    		out	(data),a		;head 0
 816: 3312+11	0AE1  D353    		out	(data),a		;track 0
 817: 3323+4	0AE3  3C      		inc	a			;sector 1
 818: 3327+11	0AE4  D353    		out	(data),a		    
 819: 3338+7	0AE6  3E80    		ld	a,system		;system key
 820: 3345+11	0AE8  D353    		out	(data),a
 821: 3356+7	0AEA  3E01    		ld	a,dread			;issue a
 822: 3363+11	0AEC  D351    		out	(commd),a		;    read command
 823:				
 824: 3374+7	0AEE  0602    	waitd:	ld	b,opdone
 825: 3381+17	0AF0  CD790A  		call	hdclop
 826: 3398+11	0AF3  DB53    		in	a,(data)		;low order byte of
 827: 3409+4	0AF5  6F      		ld	l,a			;    bootstrap address
 828: 3413+4	0AF6  5F      		ld	e,a
 829: 3417+11	0AF7  DB53    		in	a,(data)		;high order byte of
 830: 3428+4	0AF9  67      		ld	h,a			;    bootstrap address
 831: 3432+4	0AFA  57      		ld	d,a
 832: 3436+7	0AFB  E6F0    		and	0f0h			;check for 1st segment of task0
 833: 3443+7+5	0AFD  2811    		jr	z,dxloop
 834: 3450+4	0AFF  AF      		xor	a
 835: 3454+13	0B00  320206  		ld	(mapram + 2),a		;T0 map is as normal with no window
 836:				
 837:				
 838: 3467+11	0B03  DB53    	lloop:	in	a,(data)		;load
 839: 3478+7	0B05  12      		ld	(de),a			;    the
 840: 3485+4	0B06  1C      		inc	e			;    bootstrap
 841: 3489+7+5	0B07  20FA    		jr	nz,lloop
 842: 3496+4	0B09  54      		ld	d,h			;save the boot addr for later
 843: 3500+4	0B0A  5D      		ld	e,l
 844: 3504+7	0B0B  3E01    		ld	a,01
 845: 3511+10	0B0D  C37209  		jp	check
 846:				
 847: 3521+4	0B10  7A      	dxloop: ld	a,d
 848: 3525+7	0B11  E60F    		and	0fh			;strip the segment #
 849: 3532+7	0B13  F610    		or	010h			; force the load into seg 0 task 1
 850: 3539+4	0B15  57      		ld	d,a
 851: 3543+12	0B16  18EB    		jr	lloop
 852:				
 853:				
 854:				;****************************************************************
 855:				;*								*
 856:				;* Rstmap writes the tasks memory allocation vectors. Upon	*
 857:				;* entry the registers must contain:				*
 858:				;*	a = task number / task segment number to update		*
 859:				;*          high nibble = task #    low nibble = segment #	*
 860:				;*	b = New allocation vector				*
 861:				;*	c = New allocation access				*
 862:				;*								*	
 863:				;* Routine calculates the expression  600+(Accumulator) x 2 	*
 864:				;* where accumulator contents are as listed above.  All arit-   * 	
 865:				;* hmetic and numbers are in Hex				*
 866:				;*  						 		*
 867:				;****************************************************************
 868:				
 869: 3555+4	0B18  6F      	rstmap:	ld	l,a             ;Get task and segment numbers       
 870: 3559+7	0B19  2600    	        ld	h,0h    
 871: 3566+11	0B1B  29      		add	hl,hl           ;multiply times 2       
 872: 3577+4	0B1C  EB      	        ex	de,hl  		;save calculated offset in D,E
 873: 3581+10	0B1D  210006  	        ld	hl,mapram       ;point to beginning of ram map
 874: 3591+17	0B20  CD260B  	        call    rstmxx            
 875: 3608+10	0B23  210002  		ld	hl,map		;point to image map at 200
 876: 3618+11	0B26  19      	rstmxx:	add	hl,de		;add offset to selected map
 877: 3629+7	0B27  70      		ld	(hl),b          ;write the allocation vector to ram
 878: 3636+6	0B28  23      		inc	hl		;point to access ram
 879: 3642+7	0B29  71      		ld	(hl),c          ;write access attributes to ram
 880: 3649+10	0B2A  C9      		ret
 881:				
 882:				;********************************************************
 883:				;*							*
 884:				;*  The following code intitializes the I/O for		*
 885:				;*  the Decision 1 Motherboard and the Mult I/O.	*
 886:				;*  							*
 887:				;********************************************************
 888:				
 889:				
 890: 3659+7	0B2B  1603    	uartst:	ld	d,3			;start with uart 3
 891: 3666+4	0B2D  7A      	uarts0:	ld	a,d
 892: 3670+11	0B2E  D34F    		out   	(grpctl),a
 893: 3681+4	0B30  AF      		xor 	a
 894: 3685+11	0B31  D34D    		out	(lsr),a			;clear line status register 
 895: 3696+11	0B33  D349    		out 	(ier),a			;initialialize interupt mask (off)
 896: 3707+4	0B35  15      		dec	d
 897: 3711+7+5	0B36  20F5    		jr	nz,uarts0
 898: 3718+11	0B38  D34F    		out 	(grpctl),a		;select sense switch port
 899: 3729+11	0B3A  DB49    		in	a,(base+1)		
 900: 3740+4	0B3C  07      		rlca
 901: 3744+4	0B3D  07      		rlca
 902: 3748+4	0B3E  07      		rlca
 903: 3752+7	0B3F  E607    		and	07h			;mask insignificant bits
 904: 3759+7	0B41  FE07    		cp	07h			;all off?
 905: 3766+7	0B43  1600    		ld	d,0
 906: 3773+7+5	0B45  280B    		jr	z,default		;default if all off
 907: 3780+10	0B47  21A50B  		ld	hl,btable		;point to baud rate table
 908: 3790+4	0B4A  87      		add 	a,a
 909: 3794+4	0B4B  5F      		ld	e,a
 910: 3798+11	0B4C  19      		add 	hl,de			;offset to selected baud rate
 911: 3809+7	0B4D  4E      		ld	c,(hl)
 912: 3816+6	0B4E  23      		inc	hl
 913: 3822+7	0B4F  46      		ld	b,(hl)			;bc = baud rate divisor value (D)
 914: 3829+12	0B50  1803    		jr	setit
 915:				
 916:     -	0B52          	default:
 917: 3841+10	0B52  010C00  		ld	bc,12			;default baud rate is 9600
 918:				
 919: 3851+4	0B55  14      	setit:	inc	d
 920: 3855+4	0B56  7A      		ld	a,d
 921: 3859+11	0B57  D34F    		out	(grpctl),a
 922: 3870+7	0B59  3E87    		ld	a,dlab+wls1+wls0+stb
 923: 3877+11	0B5B  D34B    		out 	(lcr),a			;divisor access bit is on
 924: 3888+4	0B5D  78      		ld	a,b
 925: 3892+11	0B5E  D349    		out 	(dlm),a			;load high divisor register
 926: 3903+4	0B60  79      		ld	a,c
 927: 3907+11	0B61  D348    		out 	(dll),a			;load low divisor register
 928: 3918+7	0B63  3E07    		ld	a,wls1+wls0+stb
 929: 3925+11	0B65  D34B    		out 	(lcr),a			;divisor access bit is off
 930: 3936+7	0B67  3E10    	        ld	a,loop			;clear the shift register
 931: 3943+11	0B69  D34C    		out	(mcr),a			; - by looping back.
 932: 3954+11	0B6B  DB48    		in	a,(rbr)			;clear receiver buffer
 933: 3965+4	0B6D  AF      		xor	a
 934: 3969+11	0B6E  D348    		out	(thr),a			;clear transmitter buffer
 935: 3980+17	0B70  CD9E0B  		call	begin0
 936: 3997+11	0B73  DB48    		in	a,(rbr)
 937: 4008+4	0B75  AF      		xor	a
 938: 4012+11	0B76  D348    		out	(thr),a
 939: 4023+17	0B78  CD9E0B  		call	begin0			;two times to make sure
 940: 4040+11	0B7B  DB4D    	rduart:	in	a,(lsr)
 941: 4051+7	0B7D  E601    		and	dr 			;check for data available
 942: 4058+7+5	0B7F  28FA    		jr	z,rduart
 943: 4065+11	0B81  DB48    		in	a,(rbr)			;intitialize receiver buffer
 944: 4076+7	0B83  FE00    		cp	0
 945: 4083+7+5	0B85  280F    		jr	z,contin		;jump if UARTS good
 946:				
 947: 4090+11	0B87  F5      	urterr:	push 	af
 948: 4101+7	0B88  3E55    		ld	a,'U'
 949: 4108+13	0B8A  32B801  		ld	(ersav),a		;Uart error
 950: 4121+4	0B8D  7A      		ld	a,d			
 951: 4125+13	0B8E  32BA01  		ld	(ersav + 2),a		;Uart # saved
 952: 4138+10	0B91  F1      		pop	af
 953: 4148+13	0B92  32B901  		ld	(ersav + 1),a		;bad character saved
 954: 4161+4	0B95  AF      		xor	a
 955:				
 956: 4165+11	0B96  D34C    	contin:	out	(mcr),a
 957: 4176+4	0B98  7A      		ld	a,d
 958: 4180+7	0B99  FE03    		cp	3			;initialize all three uarts
 959: 4187+5+6	0B9B  C8      		ret	z
 960: 4192+12	0B9C  18B7    		jr	setit
 961:				
 962: 4204+11	0B9E  DB4D    	begin0:	in	a,(lsr)
 963: 4215+7	0BA0  E620    		and	thre
 964: 4222+7+5	0BA2  28FA    		jr	z,begin0
 965: 4229+10	0BA4  C9      		ret
 966:				
 967:				
 968:				;  Baud rate selection table for Mult I/o or WB I/O
 969:				
 970:     -	0BA5  1704    	btable:	dw	1047			;110 baud		0 0 0
 971:     -	0BA7  8001    		dw	384			;300 baud		0 0 1
 972:     -	0BA9  6000    		dw	96			;1200 baud		0 1 0
 973:     -	0BAB  3000    		dw	48			;2400 baud		0 1 1
 974:     -	0BAD  1800    		dw	24			;4800 baud		1 0 0
 975:     -	0BAF  0C00    		dw	12			;9600 baud		1 0 1
 976:     -	0BB1  0600    		dw	6			;19200 baud		1 1 0
 977:				
 978:				; Load constants command for the DMA Winchester controller
 979:				
 980:     -	0BB3  10      	bootbl: db	10h			;direction out
 981:     -	0BB4  00      		db	0			;low steps
 982:     -	0BB5  00      		db	0			;high steps
 983:     -	0BB6  3C      		db	03ch			;select drive 0
 984:     -	0BB7  00      		db	0			;low dma address
 985:     -	0BB8  01      		db	01			;high dma address
 986:     -	0BB9  00      		db	0			;extended dma address
 987:     -	0BBA  00      		db	0			;argument 0
 988:     -	0BBB  1E      		db	stpdly			;argument 1
 989:     -	0BBC  C8      		db	hdsetl			;argument 2
 990:     -	0BBD  07      		db	secsiz			;argument 3
 991:     -	0BBE  04      		db	const			;load constants opcode
 992:     -	0BBF  00      		db	0			;clear status byte
 993:     -	0BC0  80      		db	80h			;low link address
 994:     -	0BC1  00      		db	0			;high link address
 995:     -	0BC2  00      		db	0			;extended link address
 996:				
 997:     -	0BC3          	endboot equ	$
 998:				
 999:				; Read sector 1, head 0, cyl 0  command for the HD-DMA:
1000:				
1001:     -	0BC3  00      	rdtbl:	db	0			;no seek
1002:     -	0BC4  00      		db	0
1003:     -	0BC5  00      		db	0
1004:     -	0BC6  7C      		db	07ch			;select drive 0, head 0 
1005:     -	0BC7  00      		db	0			;dma address of 100h
1006:     -	0BC8  01      		db	1
1007:     -	0BC9  00      		db	0
1008:     -	0BCA  00      		db	0			;low byte cylinder
1009:     -	0BCB  00      		db	0			;high byte cylinder
1010:     -	0BCC  00      		db	0			;head 0
1011:     -	0BCD  00      		db	0			;sector 1
1012:     -	0BCE  00      		db	0			;read command
1013:     -	0BCF  00      		db	0			;clear status
1014:				
1015:     -	0BD0          	endrd 	equ	$
1016:				
1017:				
1018:				; Dispatch table for the on-board diagnostic routines
1019:				
1020:     -	0BD0          	jtable	equ 	$
1021: 4239+10	0BD0  C30008  		jp	regrd			;test all the readable registers
1022:     -	0BD3  00      		db	0
1023: 4249+10	0BD4  C30E08  		jp	regwr			;check all the writable registers but
1024:				 					; -task register
1025:     -	0BD7  00      		db	0
1026: 4259+10	0BD8  C32108  		jp	tmap			;check map rams
1027:     -	0BDB  00      		db	0
1028: 4269+10	0BDC  C33A08  		jp	tram			;check read/write ram
1029:     -	0BDF  00      		db 	0
1030: 4279+10	0BE0  C34E08  		jp	tfpp			;check fpp
1031:     -	0BE3  00      		db	0
1032: 4289+10	0BE4  C37608  		jp	tbus			;check bus read/write addresses
1033:     -	0BE7  00      		db	0
1034: 4299+10	0BE8  C3A808  		jp	ntbus			;R/W bus with 055h and 0aah
1035:     -	0BEB  00      		db	0
1036: 4309+12	0BEC  180B    		jr	start			;yet to be defined
1037:					
1038:					
1039:     -	0BEE          	ecode0  equ	$			;End of reset prom code
1040:				
1041:     -	0BEE          		ds	3f0h-(ecode0-rom0)	;Fill out the prom
1042:				
1043:				;****************************************************************
1044:				;*								*
1045:				;* The following special piece of code is where the user task	*
1046:				;* begins executing when a reset trap occurs. 			*
1047:				;*								*
1048:				;****************************************************************
1049: 4321+10	0BF0  214A10  		ld	hl,djstat
1050: 4331+7	0BF3  3E00    		ld	a,0h
1051: 4338+13	0BF5  320206  		ld	(mapram + 2),a		;t0 map points to t1 map seg 0
1052: 4351+4	0BF8  3C      		inc	a
1053: 4355+10	0BF9  310002  	start:	ld	sp,stack
1054: 4365+10	0BFC  C35A08  		jp	getsw 		        ;power-on or reset jump
1055: 4375+4	0BFF  00      		nop				;Fill out the prom.
1056:     -	0C00          	erom0   equ	$
1057:				
1058:					ds	400h-(erom0-rom0)
1059:				
1060:     -	0800          		.phase 800h  
1061:				
1062:				;****************************************************************
1063:				;*								*
1064:				;*	This code is usuable by the supervisor task (task0)    	*
1065:				;*	but is not accessible to any other tasks. Any trap	*
1066:				;*      other than a reset will enable this half of the eprom	*
1067:				;*	as well.						*
1068:				;*								*
1069:				;****************************************************************
1070:				
1071:				
1072:     -	0800          		rom1	equ	$
1073:				
1074:				;****************************************************************
1075:				;*								*
1076:				;*          ===>>  J U M P   T A B L E   <<===			*
1077:				;*								*
1078:				;****************************************************************
1079:				
1080: 4379+10	0800  C31B08  	svtrap:	jp	trappd			;trap routine, check out reason why
1081: 4389+10	0803  C35D08  	tskbse:	jp	tskbase			;Return task base pointer
1082: 4399+10	0806  C3EB08  	nmap:	jp	putmap			;set up new allocation vector, access 
1083: 4409+10	0809  C37B08  	gotsk:	jp	gotask			;switch to new task
1084: 4419+10	080C  C3B908  	getmap:	jp	gtmap			;get the old allocation vector, access
1085: 4429+10	080F  C3C508  	dupmap:	jp	dpmap			;copy user vector into T0 window
1086: 4439+10	0812  C30209  	what:	jp	monitor			;debugger/monitor called 'MON'
1087: 4449+10	0815  C36D08  	restr: 	jp	restor			;restore task 0 map to normal condition
1088: 4459+10	0818  C37808  	otask:	jp	oldtask			;jumps to last task before trap
1089:				 	
1090:				
1091:					
1092: 4469+10	081B  11F1FF  	trappd:	ld	de,-15			;back up the users pc
1093: 4479+16	081E  2A9C01  		ld 	hl,(u.pc)
1094: 4495+11	0821  19      		add	hl,de
1095: 4506+16	0822  229C01  		ld	(u.pc),hl		;save the users original pc
1096: 4522+4	0825  08      		ex 	Af,Af'			;save auxilary registers
1097: 4526+4	0826  D9      		exx
1098: 4530+11	0827  F5      		push	Af
1099: 4541+11	0828  E5      		push	hl
1100: 4552+11	0829  D5      		push	de
1101: 4563+11	082A  C5      		push	bc
1102: 4574+15	082B  FDE5    		push	iy
1103: 4589+15	082D  DDE5    		push	ix
1104: 4604+9	082F  ED57    		ld	a,i			;get interupt register
1105: 4613+11	0831  F5      		push	af			;save it
1106: 4624+13	0832  3A0600  		ld	a,(ctask)		;get current task number
1107: 4637+10	0835  310002  		ld	sp,stack
1108: 4647+17	0838  CD0308  		call    tskbse			;get base of task save area
1109: 4664+11	083B  E5      		push	hl			;save the bottom of task save area
1110: 4675+4	083C  EB      		ex	de,hl			;de = bottom task_ save
1111: 4679+10	083D  218F01  		ld	hl,u.ir			;hl = bottom of temp_ save
1112: 4689+10	0840  011A00  		ld      bc,tasksiz		;repeat count
1113: 4699+11	0843  C5      		push	bc			;save for register print routine
1114: 4710+16+5	0844  EDB0    		ldir   				;move registers from temporary store
1115:									;to task_ store area
1116: 4726+16	0846  2A0304  		ld	hl,(stats)		;get status bits
1117: 4742+11	0849  E5      		push	hl
1118: 4753+8	084A  CB55    		bit	2,l			;was the trap a halt?
1119: 4761+10	084C  C20000  		jp	nz,super
1120: 4771+17	084F  CD0F08  		call	dupmap			;copy users map into task 0
1121: 4788+16	0852  2A9C01  		ld	hl,(u.pc)		;hl has users adjusted pc 
1122: 4804+7	0855  7E      		ld 	a,(hl)			;a = adjusted pc contents
1123: 4811+7	0856  FE76    		cp	nxtbyte			;was it an 76 in next byte??
1124: 4818+10	0858  C20000  		jp      nz,super		;jump if not an 76 to supervisor
1125: 4828+6	085B  23      		inc	hl			;HL point to address after 2nd halt
1126: 4834+4	085C  E9      		jp	(hl)			;jump to byte following the halt 76 
1127:									; - but now in task 0...
1128:				
1129:				           
1130:				
1131:				;****************************************************************
1132:				;*								*
1133:				;*   Tskbase returns with H & L pointing to the first address	*
1134:				;*   in the user's task save area.  User is designated by 	*
1135:				;*   register A upon entry.					*	
1136:				;*								*
1137:				;****************************************************************
1138:				
1139:				
1140:				
1141:     -	085D          	tskbase:	
1142: 4838+10	085D  21EEFF  		ld	hl,tasks-tasksiz	;no task zero save area
1143: 4848+10	0860  111A00  		ld	de,tasksiz		;size of save area
1144: 4858+7	0863  E60F    		and 	0fh			;mask off upper bits
1145: 4865+7+5	0865  2001    		jr	nz,tsklp		;task 0 and 1 share the same area
1146: 4872+4	0867  3C      		inc	a
1147: 4876+11	0868  19      	tsklp:	add     hl,de			
1148: 4887+4	0869  3D      		dec	a			
1149: 4891+7+5	086A  20FC    		jr	nz,tsklp		
1150: 4898+10	086C  C9      		ret
1151:						
1152:				
1153:						
1154:				;********************************************************
1155:				;*							*
1156:				;*   Restore will restore Task 0's map with its old 	*
1157:				;*   values.  This assumes that if the map for task 0   *
1158:				;*   has been changed, that only the actual map had 	*
1159:				;*   been changed and that the image map was left in	*
1160:				;*   the condition before the change occurred.		*
1161:				;*							*
1162:				;********************************************************
1163:				
1164:				
1165: 4908+10	086D  210002  	restor:	ld 	hl,map			;point to beginning of map image
1166: 4918+10	0870  110006  		ld	de,mapram		;point to beginning of actual map
1167: 4928+10	0873  011F00  		ld	bc,01Fh			;all of task 0 map 
1168: 4938+16+5	0876  EDB0    		ldir
1169:				
1170:				
1171:				;****************************************************************
1172:				;*								*
1173:				;*	Gotask restores all the task's registers  and then	*
1174:				;*	switches to that task.                 			*
1175:				;*								*
1176:				;****************************************************************
1177:				
1178:     -	0878          	oldtask:
1179: 4954+13	0878  3A0600  		ld	a,(ctask)
1180: 4967+13	087B  320600  	gotask:	ld	(ctask),a		;save new task number
1181: 4980+17	087E  CD5D08  		call	tskbase 		;get address of task save area
1182: 4997+10	0881  118F01  		ld	de,u.ir			;base of save area
1183: 5007+10	0884  318E01  		ld	sp,u.save
1184: 5017+10	0887  011A00  		ld	bc,tasksiz		;repeat count
1185: 5027+16+5	088A  EDB0    		ldir				;move the registers
1186: 5043+10	088C  F1      		pop	Af			;get back the interupt register
1187: 5053+9	088D  ED47    		ld	i,a			;restore it
1188: 5062+14	088F  DDE1    		pop	ix			;restore auxilliary registers
1189: 5076+14	0891  FDE1    		pop	iy
1190: 5090+10	0893  C1      		pop	bc
1191: 5100+10	0894  D1      		pop	de
1192: 5110+10	0895  E1      		pop	hl
1193: 5120+10	0896  F1      		pop	af
1194: 5130+4	0897  08      		ex      Af,Af'
1195: 5134+4	0898  D9      		exx
1196: 5138+10	0899  E1      		pop	hl			;get pc register
1197: 5148+16	089A  220400  		ld	(user+1),hl		;put in jump instruction
1198: 5164+10	089D  C1      		pop	bc			;restore primary registers
1199: 5174+7	089E  3EC3    		ld	a,jmpop			;lay down the jump instruction
1200: 5181+13	08A0  320300  		ld	(user),a		;
1201: 5194+13	08A3  3AA801  		ld	a,(u.mask)		;get back the old mask for that task
1202: 5207+13	08A6  320700  		ld	(cmask),a
1203: 5220+16	08A9  2A0600  		ld	hl,(ctask)		;get the task/mask for swapping
1204: 5236+16	08AC  220204  		ld	(task),hl		;begin count, eigth instruction
1205:									; is in the user's space
1206: 5252+10	08AF  D1      		pop	de			;(1) restore primary registers
1207: 5262+10	08B0  E1      		pop	hl			;(2)
1208: 5272+10	08B1  F1      		pop	af			;(3)
1209: 5282+20	08B2  ED7BA601		ld      sp,(u.sp)		;(4) (5)
1210: 5302+10	08B6  C30300  		jp	user			;(6)
1211:									; 7th instruction is @ 003 task 0
1212:					
1213:				;********************************************************
1214:				;*							*
1215:				;*  The following code will return with:		*
1216:				;*      Register A = task #/ segment #			*
1217:				;*	Register B = old allocation vector		*
1218:				;*	Register C = old access	priviledges		*
1219:				;*  Upon entry, it expects the A register to have	*
1220:				;*  the desired task# / segment #. Consider this to be	*
1221:				;*  opposite of the putmap routine.			*
1222:				;*							*
1223:				;********************************************************
1224:				
1225: 5312+17	08B9  CDFD08  	gtmap:	call	tsmod		;get task and segment numbers
1226: 5329+4	08BC  EB      		ex	de,hl		;save calculated offset in de
1227: 5333+10	08BD  210002  		ld	hl,map		;point to beginning of map ram image
1228: 5343+11	08C0  19      		add	hl,de		;add offset to get desired map
1229: 5354+7	08C1  46      		ld	b,(HL)		;get old allocation vector
1230: 5361+6	08C2  23      		inc	hl		;offset to access map
1231: 5367+7	08C3  4E      		ld	c,(HL)		;get old access priviledges
1232: 5374+10	08C4  C9      		ret 	
1233:						
1234:				
1235:				
1236:				;********************************************************
1237:				;*							*
1238:				;*	This routine copies the most recently trapped	*
1239:				;*	user's map into task0 actual map and gives T0   *
1240:				;*      unlimited privilidges with this memory. The	*
1241:				;*      T0 image map is not altered.			*
1242:				;*							*
1243:				;********************************************************
1244:				
1245: 5384+13	08C5  3A0600  	dpmap:	ld	a,(ctask)
1246: 5397+8	08C8  CB07    		rlc	a
1247: 5405+8	08CA  CB07    		rlc	a
1248: 5413+8	08CC  CB07    		rlc	a
1249: 5421+8	08CE  CB07    		rlc	a
1250: 5429+17	08D0  CDB908  	dpmap0: call    gtmap    		;return with values in b,c
1251: 5446+7	08D3  0E03    		ld	c,03h			;unlimied access priviledges
1252: 5453+11	08D5  F5      		push	af
1253: 5464+7	08D6  E60F    		and	0fh			;force task # to be 0
1254: 5471+17	08D8  CDFD08  		call	tsmod
1255: 5488+10	08DB  110006  		ld	de,mapram		;point to T0 actual map
1256: 5498+11	08DE  19      		add	hl,de
1257: 5509+7	08DF  70      		ld	(hl),b			;new access vector
1258: 5516+6	08E0  23      		inc	hl
1259: 5522+7	08E1  71      		ld	(hl),c			;new priviledges
1260: 5529+10	08E2  F1      		pop	af
1261: 5539+4	08E3  3C      		inc	a			;next map location
1262: 5543+4	08E4  4F      		ld	c,a
1263: 5547+7	08E5  E60F    		and	0fh			
1264: 5554+5+6	08E7  C8      		ret	z			;do it 16 times for all segments
1265: 5559+4	08E8  79      		ld	a,c
1266: 5563+12	08E9  18E5    		jr	dpmap0
1267:				
1268:				;********************************************************
1269:				;*							*
1270:				;*  Putmap updates a task's allocation vectors and	*
1271:				;*  access atributes.  Upon entry, registers must	*
1272:				;*  contain:						*
1273:				;*	a = task # / task segment # to update		*
1274:				;*	    high nibble = task#, low nibble = segment#	*
1275:				;*	b = new allocation vector			*
1276:				;*	c = new access privilidges			*
1277:				;*							*
1278:				;*  Routine calculates the expression 600 + (a) X 2	*
1279:				;*  where a is as listed above.  All arithmetic and	*
1280:				;*  numbers are in Hex.					*
1281:				;*							*
1282:				;********************************************************
1283:				
1284: 5575+17	08EB  CDFD08  	putmap:	call	tsmod			;get task and sec #
1285: 5592+4	08EE  EB      		ex 	de,hl			;save calculated offset in de
1286: 5596+10	08EF  210006  		ld	hl,mapram		;point to beginning of ram map
1287: 5606+17	08F2  CDF808  		call 	putmxx			
1288: 5623+10	08F5  210002  		ld	hl,map			;point to beginning of image map
1289: 5633+11	08F8  19      	putmxx: add	hl,de			;add offset to selected map
1290: 5644+7	08F9  70      		ld	(hl),b			;write the allocation vector
1291: 5651+6	08FA  23      		inc	hl			;point to access attribute ram
1292: 5657+7	08FB  71      		ld	(hl),c			;write new access atributes
1293: 5664+10	08FC  C9      		ret
1294:				
1295: 5674+4	08FD  6F      	tsmod: 	ld	l,a			;get task / seg number
1296: 5678+7	08FE  2600    		ld	h,0
1297: 5685+11	0900  29      		add	hl,hl 			;multiply times two
1298: 5696+10	0901  C9      		ret
1299:					
1300:				;********************************************************	
1301:				;*							*
1302:				;*  The following routines make up the debugging tool	*
1303:				;*  called UPMON1.  It is a modified version of the 	*
1304:				;*  code in the lower half of the EPROM.       		*	
1305:				;*							*
1306:				;********************************************************
1307:				
1308:				
1309:     -	0902          	monitor:
1310: 5706+17	0902  CD040A  		call	ucrlf
1311: 5723+10	0905  E1      		pop	hl			;print the stats and trap address
1312: 5733+17	0906  CDC60A  		call	uladr			;print the task and mask
1313: 5750+10	0909  D1      		pop 	de			;get task size
1314: 5760+6	090A  1B      		dec	de			
1315: 5766+10	090B  E1      		pop	hl			;get the bottom of task save area
1316: 5776+11	090C  E5      		push	hl
1317: 5787+11	090D  19      		add	hl,de
1318: 5798+4	090E  EB      		ex	de,hl
1319: 5802+10	090F  E1      		pop	hl
1320: 5812+10	0910  012309  		ld	bc,ustart
1321: 5822+11	0913  C5      		push	bc
1322: 5833+12	0914  1834    		jr	udi0			;print out the registers
1323:				
1324: 5845+13	0916  3AB801  	cold:	ld	a,(ersav)		;retrieve the error byte if any
1325: 5858+4	0919  4F      		ld	c,a
1326: 5862+17	091A  CD370A  		call	ucout1			;print it
1327: 5879+16	091D  2AB901  		ld	hl,(ersav + 1)		;retrieve disk command
1328: 5895+17	0920  CDC60A  		call	uladr
1329:				
1330: 5912+10	0923  310002  	ustart:	ld	sp,stack
1331: 5922+10	0926  112309  		LD	DE,USTART		;monitor begins here
1332: 5932+11	0929  D5      		PUSH	DE
1333: 5943+17	092A  CD040A  		CALL	UCRLF
1334: 5960+7	092D  0E3A    		LD	C,':'
1335: 5967+17	092F  CD370A  		CALL	ucout1
1336: 5984+17	0932  CD0A0B  	USTAR0:	CALL	UTI
1337: 6001+4	0935  B7      		OR	A
1338: 6005+7+5	0936  28FA    		JR	Z,USTAR0
1339: 6012+7	0938  FE7B    		CP	'z'+1
1340: 6019+10	093A  D2230A  		JP	NC,UERROR
1341: 6029+7	093D  0E02    		LD	C,002H
1342: 6036+7	093F  FE44    		CP	'D'
1343: 6043+7+5	0941  2804    		JR	Z,udisp
1344: 6050+7	0943  FE64    		cp	'd'
1345: 6057+7+5	0945  2019    		jr	nz,ufill
1346:				
1347:				;
1348:				;	DISPLAY MEMORY XXXX TO XXXX
1349:				;
1350:				;
1351: 6064+17	0947  CDFF09  	UDISP:	CALL	UEXLF
1352: 6081+17	094A  CD040A  	UDI0:	CALL	UCRLF
1353: 6098+17	094D  CDC60A  		CALL	ULADR
1354: 6115+7	0950  0610    		LD	B,010H
1355: 6122+17	0952  CD350A  	UDI1:	CALL	UBLK
1356: 6139+7	0955  7E      		LD	A,(HL)
1357: 6146+17	0956  CDCB0A  		CALL	ULBYTE
1358: 6163+17	0959  CDA20A  		CALL	UHILOX
1359: 6180+8+5	095C  10F4    		DJNZ	UDI1
1360: 6188+12	095E  18EA    		JR	UDI0
1361:				;
1362:				;
1363:				;
1364:				;	FILL MEMORY XXXX TO XXXX WITH XX
1365:				;
1366:				;
1367:				;
1368: 6200+7	0960  FE46    	UFILL:	CP	'F'
1369: 6207+7+5	0962  2804    		JR	z,ufill0
1370: 6214+7	0964  FE66    		cp	'f'
1371: 6221+7+5	0966  200C    		jr	nz,ugoto
1372: 6228+17	0968  CD700A  	ufill0:	CALL	UEXPR3
1373: 6245+7	096B  71      	UFI0:	LD	(HL),C
1374: 6252+17	096C  CDA80A  		CALL	UHILO
1375: 6269+7+5	096F  30FA    		JR	NC,UFI0
1376: 6276+10	0971  D1      		POP	DE
1377: 6286+12	0972  18AF    		JR	USTART
1378:				;
1379:				;
1380:				;	GOTO (EXECUTE) XXXX
1381:				;
1382:				;
1383: 6298+7	0974  FE47    	UGOTO:	CP	'G'
1384: 6305+7+5	0976  2804    		JR	Z,ugoto0
1385: 6312+7	0978  FE67    		cp	'g'
1386: 6319+7+5	097A  2008    		jr	nz,umtest
1387: 6326+17	097C  CD7B0A  	ugoto0:	CALL	UEXPR1
1388: 6343+17	097F  CD040A  		CALL	UCRLF
1389: 6360+10	0982  E1      		POP	HL
1390: 6370+4	0983  E9      		JP	(HL)
1391:				;
1392:				;
1393:				;	TEST MEMORY XXXX TO XXXX
1394:				;
1395:				;
1396: 6374+7	0984  FE54    	UMTEST:	CP	'T'
1397: 6381+7+5	0986  2804    		JR	Z,ut10
1398: 6388+7	0988  FE74    		cp	't'
1399: 6395+7+5	098A  201C    		jr	nz,umove
1400: 6402+17	098C  CDFF09  	ut10:	CALL	UEXLF
1401: 6419+7	098F  7E      	UT1:	LD	A,(HL)
1402: 6426+4	0990  47      		LD	B,A
1403: 6430+4	0991  2F      		CPL
1404: 6434+7	0992  77      		LD	(HL),A
1405: 6441+7	0993  AE      		XOR	(HL)
1406: 6448+7+5	0994  280C    		JR	Z,UT2
1407: 6455+11	0996  D5      		PUSH	DE
1408: 6466+4	0997  5F      		LD	E,A
1409: 6470+17	0998  CD320A  		CALL	UHLSP
1410: 6487+17	099B  CD410B  		CALL	UQI1
1411: 6504+17	099E  CD040A  		CALL	UCRLF
1412: 6521+10	09A1  D1      		POP	DE
1413: 6531+7	09A2  70      	UT2:	LD	(HL),B
1414: 6538+17	09A3  CDA20A  		CALL	UHILOX
1415: 6555+12	09A6  18E7    		JR	UT1
1416:				;
1417:				;
1418:				;	MOVE DATA FROM XXXX TO XXXX
1419:				;
1420:				;
1421: 6567+7	09A8  FE4D    	UMOVE:	CP	'M'
1422: 6574+7+5	09AA  2804    		JR	Z,umvo0
1423: 6581+7	09AC  FE6D    		cp	'm'
1424: 6588+7+5	09AE  2012    		jr	nz,usubs
1425: 6595+17	09B0  CD700A  	umvo0:	CALL	UEXPR3
1426: 6612+7	09B3  7E      	UMV0:	LD	A,(HL)
1427: 6619+7	09B4  02      		LD	(BC),A
1428: 6626+6	09B5  03      		INC	BC
1429: 6632+17	09B6  CDA20A  		CALL	UHILOX
1430: 6649+12	09B9  18F8    		JR	UMV0
1431: 6661+19	09BB  DD7700  	USTORE:	LD	(IX+00H),A
1432: 6680+10	09BE  DD23    		INC	IX
1433: 6690+4	09C0  1D      		DEC	E
1434: 6694+10	09C1  C9      		RET
1435:				;
1436:				;
1437:				;	EXAMINE AND/OR REPLACE MEMORY DATA
1438:				;
1439:				;
1440: 6704+7	09C2  FE53    	USUBS:	CP	'S'
1441: 6711+7+5	09C4  2805    		JR	Z,usuo0
1442: 6718+7	09C6  FE73    		cp	's'
1443: 6725+10	09C8  C2B20A  		jp	nz,uhexn
1444: 6735+17	09CB  CD7B0A  	usuo0:	CALL	UEXPR1
1445: 6752+17	09CE  CDFE0A  		CALL	UQCHK
1446: 6769+10	09D1  DA230A  		JP	C,UERROR
1447: 6779+10	09D4  E1      		POP	HL
1448: 6789+7	09D5  7E      	USU0:	LD	A,(HL)
1449: 6796+17	09D6  CDCB0A  		CALL	ULBYTE
1450: 6813+7	09D9  0E2D    		LD	C,02DH
1451: 6820+17	09DB  CDF80A  		CALL	UCOPCK
1452: 6837+5+6	09DE  D8      		RET	C
1453: 6842+7+5	09DF  2810    		JR	Z,USU1
1454: 6849+11	09E1  E5      		PUSH	HL
1455: 6860+10	09E2  210000  		LD	HL,0
1456: 6870+7	09E5  0E01    		LD	C,001H
1457: 6877+17	09E7  CD830A  		CALL	UEX1
1458: 6894+10	09EA  D1      		POP	DE
1459: 6904+10	09EB  E1      		POP	HL
1460: 6914+7	09EC  73      		LD	(HL),E
1461: 6921+4	09ED  78      		LD	A,B
1462: 6925+7	09EE  FE0D    		CP	00DH
1463: 6932+5+6	09F0  C8      		RET	Z
1464: 6937+6	09F1  23      	USU1:	INC	HL
1465: 6943+17	09F2  CD040A  		CALL	UCRLF
1466: 6960+11	09F5  E5      		PUSH	HL
1467: 6971+17	09F6  CDC60A  		CALL	ULADR
1468: 6988+17	09F9  CD350A  		CALL	UBLK
1469: 7005+10	09FC  E1      		POP	HL
1470: 7015+12	09FD  18D6    		JR	USU0
1471:				;
1472:				;
1473: 7027+17	09FF  CD7D0A  	UEXLF:	CALL 	UEXPR
1474: 7044+10	0A02  D1      		POP	DE
1475: 7054+10	0A03  E1      		POP	HL
1476:				;	CR/LF OUTPUT
1477:				;
1478:				;
1479: 7064+11	0A04  E5      	UCRLF:	PUSH	HL
1480: 7075+11	0A05  C5      		PUSH	BC
1481: 7086+7	0A06  0E0D    		LD	C,0DH
1482: 7093+17	0A08  CD370A  		CALL	ucout1
1483: 7110+7	0A0B  0E0A    		LD	C,0AH
1484: 7117+17	0A0D  CD370A  		CALL	ucout1
1485: 7134+10	0A10  C1      		POP	BC
1486: 7144+10	0A11  E1      		POP	HL
1487: 7154+17	0A12  CD520A  		CALL	UCSTS
1488: 7171+4	0A15  B7      		OR	A
1489: 7175+5+6	0A16  C8      		RET	Z
1490:				;
1491:				;	CHECK FOR CONTROL CHARACTER
1492:				;
1493:				;
1494: 7180+17	0A17  CD440A  	UCCHK:	CALL	ucon1
1495: 7197+7	0A1A  E67F    		AND	07FH
1496: 7204+7	0A1C  FE13    		CP	013H	;CONTROL-S
1497: 7211+7+5	0A1E  28F7    		JR	Z,UCCHK
1498: 7218+7	0A20  FE03    		CP	003H	;CONTROL-C
1499: 7225+5+6	0A22  C0      		RET	NZ
1500: 7230+17	0A23  CDDA0A  	UERROR:	CALL	UMEMSIZ
1501: 7247+10	0A26  11230A  		LD	DE,UERROR
1502: 7257+11	0A29  D5      		PUSH	DE
1503: 7268+7	0A2A  0E3F    		LD	C,'?'
1504: 7275+17	0A2C  CD370A  		CALL	ucout1
1505: 7292+10	0A2F  C32309  		JP	USTART
1506: 7302+17	0A32  CDC60A  	UHLSP:	CALL	ULADR
1507:				;
1508:				;	PRINT SPACE CHARACTER
1509:				;
1510: 7319+7	0A35  0E20    	UBLK:	LD	C,020H
1511:				
1512:				
1513:				;********************************************************
1514:				;*							*
1515:				;*  Console I/O routines for the Wunderbus I/O.  These	*
1516:				;*  routines assume that the uart divisor latch has 	*
1517:				;*  previously set (either on power up or in routine 	*
1518:				;*  executed before a trap to this routine occurred.    *
1519:				;*  The character to output should be in the 'C' reg-	*
1520:				;*  ister, the character received is returned in the	*
1521:				;*  'A' register.  UCSTS returns with zero flag set	*
1522:				;*  when no character is waiting in the UART buffer,	*
1523:				;*  or with A = FFh if a character is waiting.		*
1524:				;*							*
1525:				;********************************************************	
1526:				
1527:				
1528: 7326+17	0A37  CD5D0A  	ucout1:	call	uconinit
1529: 7343+11	0A3A  DB4D    	ucout2:	in	a,(lsr)			;get uart status
1530: 7354+7	0A3C  E620    		and	thre
1531: 7361+7+5	0A3E  28FA    		jr	z,ucout2		;loop until tbe
1532: 7368+4	0A40  79      		ld	a,c
1533: 7372+11	0A41  D348    		out	(thr),a			;output the data to uart
1534: 7383+10	0A43  C9      		ret
1535:				
1536: 7393+17	0A44  CD5D0A  	ucon1:	call	uconinit
1537: 7410+11	0A47  DB4D    	ucon2:	in	a,(lsr)			;get uart status
1538: 7421+7	0A49  E601    		and	dr
1539: 7428+7+5	0A4B  28FA    		jr	z,ucon2			;wait until receive data available
1540: 7435+11	0A4D  DB48    		in	a,(rbr)			;read the uart data register
1541: 7446+7	0A4F  E67F    		and	07fh			;strip parity
1542: 7453+10	0A51  C9      		ret
1543:				
1544: 7463+17	0A52  CD5D0A  	ucsts:	call	uconinit		
1545: 7480+11	0A55  DB4D    		in	a,(lsr)			;read uart status
1546: 7491+7	0A57  E601    		and	dr
1547: 7498+5+6	0A59  C8      		ret	z			;return zero set if no character
1548: 7503+7	0A5A  3EFF    		ld	a,0ffh
1549: 7510+10	0A5C  C9      		ret				;return a = ffh if character waiting
1550:				
1551:     -	0A5D          	uconinit:
1552: 7520+7	0A5D  3E09    		ld	a,group1
1553: 7527+11	0A5F  D34F    		out   	(grpctl),a		;set up for UART 1
1554: 7538+7	0A61  3E07    		ld	a,wls0+wls1+stb		
1555: 7545+11	0A63  D34B    		out 	(lcr),a			;8 bit word, 2 bit stop bits
1556: 7556+10	0A65  C9      		ret		
1557:				
1558:				
1559:				
1560:				;	CONVERT HEX TO ASCII
1561:				
1562: 7566+7	0A66  E60F    	UCONV:	AND	00fh
1563: 7573+7	0A68  C690    		ADD	A,090H
1564: 7580+4	0A6A  27      		DAA
1565: 7584+7	0A6B  CE40    		ADC	A,040H
1566: 7591+4	0A6D  27      		DAA
1567: 7595+4	0A6E  4F      		LD	C,A
1568: 7599+10	0A6F  C9      		RET
1569:				;
1570:				;	GET PARAMETERS 1,2,OR 3
1571:				;
1572: 7609+4	0A70  0C      	UEXPR3:	INC	C
1573: 7613+17	0A71  CD7D0A  		CALL	UEXPR
1574: 7630+17	0A74  CD040A  		CALL	UCRLF
1575: 7647+10	0A77  C1      		POP	BC
1576: 7657+10	0A78  D1      		POP	DE
1577: 7667+10	0A79  E1      		POP	HL
1578: 7677+10	0A7A  C9      		RET
1579: 7687+7	0A7B  0E01    	UEXPR1:	LD	C,001H
1580: 7694+10	0A7D  210000  	UEXPR:	LD	HL,0
1581: 7704+17	0A80  CD0A0B  	UEX0:	CALL	UTI
1582: 7721+4	0A83  47      	UEX1:	LD	B,A
1583: 7725+17	0A84  CDDE0A  		CALL	UNIBBLE
1584: 7742+7+5	0A87  3808    		JR	C,UEX2
1585: 7749+11	0A89  29      		ADD	HL,HL
1586: 7760+11	0A8A  29      		ADD	HL,HL
1587: 7771+11	0A8B  29      		ADD	HL,HL
1588: 7782+11	0A8C  29      		ADD	HL,HL
1589: 7793+4	0A8D  B5      		OR	L
1590: 7797+4	0A8E  6F      		LD	L,A
1591: 7801+12	0A8F  18EF    		JR	UEX0
1592: 7813+19	0A91  E3      	UEX2:	EX	(SP),HL
1593: 7832+11	0A92  E5      		PUSH	HL
1594: 7843+4	0A93  78      		LD	A,B
1595: 7847+17	0A94  CDFE0A  		CALL	UQCHK
1596: 7864+7+5	0A97  3002    		JR	NC,UEX3
1597: 7871+4	0A99  0D      		DEC	C
1598: 7875+5+6	0A9A  C8      		RET	Z
1599: 7880+10	0A9B  C2230A  	UEX3:	JP	NZ,UERROR
1600: 7890+4	0A9E  0D      		DEC	C
1601: 7894+7+5	0A9F  20DC    		JR	NZ,UEXPR
1602: 7901+10	0AA1  C9      		RET
1603: 7911+17	0AA2  CDA80A  	UHILOX:	CALL	UHILO
1604: 7928+5+6	0AA5  D0      		RET	NC
1605: 7933+10	0AA6  D1      		POP	DE
1606: 7943+10	0AA7  C9      		RET
1607: 7953+6	0AA8  23      	UHILO:	INC	HL
1608: 7959+4	0AA9  7C      		LD	A,H
1609: 7963+4	0AAA  B5      		OR	L
1610: 7967+4	0AAB  37      		SCF
1611: 7971+5+6	0AAC  C8      		RET	Z
1612: 7976+4	0AAD  7B      		LD	A,E
1613: 7980+4	0AAE  95      		SUB	L
1614: 7984+4	0AAF  7A      		LD	A,D
1615: 7988+4	0AB0  9C      		SBC	A,H
1616: 7992+10	0AB1  C9      		RET
1617:				;
1618:				;	HEXADECIMAL ARITHMETIC
1619:				;
1620: 8002+7	0AB2  FE48    	UHEXN:	CP	'H'
1621: 8009+7+5	0AB4  2804    		JR	Z,uhexd
1622: 8016+7	0AB6  FE68    		cp	'h'
1623: 8023+7+5	0AB8  206A    		jr	nz,uport
1624: 8030+17	0ABA  CDFF09  	uhexd:	CALL	UEXLF
1625: 8047+11	0ABD  E5      		PUSH	HL
1626: 8058+11	0ABE  19      		ADD	HL,DE
1627: 8069+17	0ABF  CD320A  		CALL	UHLSP
1628: 8086+10	0AC2  E1      		POP	HL
1629: 8096+4	0AC3  B7      		OR	A
1630: 8100+15	0AC4  ED52    		SBC	HL,DE
1631:				;
1632:				;	CONVERT HL REGISTER TO ASCII
1633:				;
1634: 8115+4	0AC6  7C      	ULADR:	LD	A,H
1635: 8119+17	0AC7  CDCB0A  		CALL	ULBYTE
1636: 8136+4	0ACA  7D      		LD	A,L
1637:				;
1638:				;	CONVERT A REGISTER TO ASCII
1639:				;
1640: 8140+11	0ACB  F5      	ULBYTE:	PUSH	AF
1641: 8151+4	0ACC  0F      		RRCA
1642: 8155+4	0ACD  0F      		RRCA
1643: 8159+4	0ACE  0F      		RRCA
1644: 8163+4	0ACF  0F      		RRCA
1645: 8167+17	0AD0  CDD40A  		CALL	UDBLC
1646: 8184+10	0AD3  F1      		POP	AF
1647: 8194+17	0AD4  CD660A  	UDBLC:	CALL	UCONV
1648: 8211+10	0AD7  C3370A  		JP	ucout1			;checked
1649:				
1650:     -	0ADA          	UMEMSIZ:
1651: 8221+16	0ADA  2A0002  		LD	HL,(STACK)
1652: 8237+10	0ADD  C9      		RET
1653:				
1654:     -	0ADE          	UNIBBLE:
1655: 8247+7	0ADE  FE61    		cp	'a'			;is it less than lower case 'a'?
1656: 8254+7+5	0AE0  3806    		jr	c,unibok		;take jump if so
1657: 8261+7	0AE2  FE7B    		cp	'z'+1			;less than a lower case 'z'?
1658: 8268+4	0AE4  3F      		ccf				;set carry and return if > 'z'
1659: 8272+5+6	0AE5  D8      		ret	c
1660: 8277+7	0AE6  D620    		sub	' '			;convert to upper case
1661: 8284+7	0AE8  D630    	unibok:	SUB	030H
1662: 8291+5+6	0AEA  D8      		RET	C
1663: 8296+7	0AEB  FE17    		cp	017h
1664: 8303+4	0AED  3F      		ccf
1665: 8307+5+6	0AEE  D8      		RET	C
1666: 8312+7	0AEF  FE0A    		CP	00AH
1667: 8319+4	0AF1  3F      		CCF
1668: 8323+5+6	0AF2  D0      		RET	NC
1669: 8328+7	0AF3  D607    		SUB	007H
1670: 8335+7	0AF5  FE0A    		CP	00AH
1671: 8342+10	0AF7  C9      		RET
1672: 8352+17	0AF8  CD370A  	UCOPCK:	CALL	ucout1
1673: 8369+17	0AFB  CD0A0B  	UPCHK:	CALL	UTI
1674:				;
1675:				;	CHARACTER CHECK
1676:				;
1677: 8386+7	0AFE  FE20    	UQCHK:	CP	020H
1678: 8393+5+6	0B00  C8      		RET	Z
1679: 8398+7	0B01  FE2C    		CP	02CH
1680: 8405+5+6	0B03  C8      		RET	Z
1681: 8410+7	0B04  FE0D    		CP	00DH
1682: 8417+4	0B06  37      		SCF
1683: 8421+5+6	0B07  C8      		RET	Z
1684: 8426+4	0B08  3F      		CCF
1685: 8430+10	0B09  C9      		RET
1686:				;
1687:				;	ECHO CONSOLE
1688:				;
1689: 8440+17	0B0A  CD440A  	UTI:	CALL	ucon1
1690: 8457+4	0B0D  3C      		INC	A
1691: 8461+5+6	0B0E  C8      		RET	Z
1692: 8466+4	0B0F  3D      		DEC	A
1693: 8470+7	0B10  E67F    		AND	07FH
1694: 8477+5+6	0B12  C8      		RET	Z
1695: 8482+7	0B13  FE00    		CP	000H
1696: 8489+5+6	0B15  C8      		RET	Z
1697: 8494+7	0B16  FE4E    		CP	04EH
1698: 8501+5+6	0B18  C8      		RET	Z
1699: 8506+7	0B19  FE6E    		CP	06EH
1700: 8513+5+6	0B1B  C8      		RET	Z
1701: 8518+11	0B1C  C5      		PUSH	BC
1702: 8529+4	0B1D  4F      		LD	C,A
1703: 8533+17	0B1E  CD370A  		CALL	ucout1
1704: 8550+4	0B21  79      		LD	A,C
1705: 8554+10	0B22  C1      		POP	BC
1706: 8564+10	0B23  C9      		RET
1707:				;
1708:				;	READ/WRITE TO I/O PORT
1709:				;
1710: 8574+7	0B24  FE4F    	UPORT:	CP	'O'
1711: 8581+7+5	0B26  282A    		JR	Z,UQOUT
1712: 8588+7	0B28  FE6F    		CP 	'o'
1713: 8595+7+5	0B2A  2826    		jr	z,uqout
1714: 8602+7	0B2C  FE49    		CP	'I'
1715: 8609+7+5	0B2E  2806    		JR	Z,uin
1716: 8616+7	0B30  FE69    		cp	'i'
1717: 8623+7+5	0B32  2802    		jr	z,uin
1718: 8630+12	0B34  1824    		JR	UVERIFY
1719: 8642+17	0B36  CD7B0A  	UIN:	CALL	UEXPR1
1720: 8659+7	0B39  0E0A    		LD	C,0AH
1721: 8666+17	0B3B  CD370A  		CALL	ucout1
1722: 8683+10	0B3E  C1      		POP	BC
1723: 8693+12	0B3F  ED58    	UQ0:	IN	E,(C)
1724: 8705+7	0B41  0608    	UQI1:	LD	B,008H
1725: 8712+17	0B43  CD350A  		CALL	UBLK
1726: 8729+8	0B46  CB23    	UQI2:	SLA	E
1727: 8737+7	0B48  3E18    		LD	A,018H
1728: 8744+4	0B4A  8F      		ADC	A,A
1729: 8748+4	0B4B  4F      		LD	C,A
1730: 8752+17	0B4C  CD370A  		CALL	ucout1
1731: 8769+8+5	0B4F  10F5    		DJNZ	UQI2
1732: 8777+10	0B51  C9      		RET
1733: 8787+17	0B52  CD7D0A  	UQOUT:	CALL	UEXPR
1734: 8804+10	0B55  D1      		POP	DE
1735: 8814+10	0B56  C1      		POP	BC
1736: 8824+12	0B57  ED59    		OUT	(C),E
1737: 8836+10	0B59  C9      		RET
1738:				;
1739:				;
1740:				;
1741:				;
1742:				;	VERIFY MEMORY XXXX TO XXXX WITH XXXX
1743:				;
1744:     -	0B5A          	UVERIFY:
1745: 8846+7	0B5A  FE56    		CP	'V'
1746: 8853+7+5	0B5C  2804    		JR	Z,uver0
1747: 8860+7	0B5E  FE76    		cp	'v'
1748: 8867+7+5	0B60  2012    		jr	nz,uretrn
1749: 8874+17	0B62  CD700A  	uver0:	call 	uexpr3
1750: 8891+7	0B65  0A      	UVERIO:	LD	A,(BC)
1751: 8898+7	0B66  BE      		CP	(HL)
1752: 8905+7+5	0B67  2805    		JR	Z,U..B
1753: 8912+11	0B69  C5      		PUSH	BC
1754: 8923+17	0B6A  CDDE0B  		CALL	UCERR
1755: 8940+10	0B6D  C1      		POP	BC
1756: 8950+6	0B6E  03      	U..B:	INC	BC
1757: 8956+17	0B6F  CDA20A  		CALL	UHILOX
1758: 8973+12	0B72  18F1    		JR	UVERIO
1759:				
1760:				;	Return to task which just trapped with old pc and registers restored
1761:				
1762: 8985+7	0B74  FE43    	uretrn:	cp	'C'
1763: 8992+7+5	0B76  2804    		jr	z,uretr1
1764: 8999+7	0B78  FE63    		cp	'c'	
1765: 9006+7+5	0B7A  2011    		jr	nz,ucontr
1766: 9013+13	0B7C  3A0600  	uretr1:	ld	a,(ctask)
1767: 9026+17	0B7F  CD5D08  		call	tskbase
1768: 9043+10	0B82  111900  		ld	de,mskofst
1769: 9053+11	0B85  19      		add	hl,de
1770: 9064+7	0B86  7E      		ld	a,(hl)
1771: 9071+7	0B87  F608    		or	08h
1772: 9078+7	0B89  77      		ld	(hl),a
1773: 9085+10	0B8A  C31808  		jp	otask
1774:				
1775:				
1776:				;	Return to trapped task, execute next instruction and trap back
1777:				
1778: 9095+7	0B8D  FE55    	ucontr:	cp	'U'
1779: 9102+7+5	0B8F  2804    		jr	z,ucont1
1780: 9109+7	0B91  FE75    		cp	'u'
1781: 9116+7+5	0B93  2011    		jr	nz,uboot
1782: 9123+13	0B95  3A0600  	ucont1:	ld	a,(ctask)
1783: 9136+17	0B98  CD5D08  		call	tskbase
1784: 9153+10	0B9B  111900  		ld	de,mskofst
1785: 9163+11	0B9E  19      		add	hl,de
1786: 9174+7	0B9F  7E      		ld	a,(hl)
1787: 9181+7	0BA0  E6F6    		and	0f6h			;force mask for stop and run enble low
1788: 9188+7	0BA2  77      		ld	(hl),a
1789: 9195+10	0BA3  C31808  		jp	otask	
1790:				
1791:				;	Jump to the cpu switch address into task specified by CTASK
1792:				
1793: 9205+7	0BA6  FE42    	uboot:	cp	'B'
1794: 9212+7+5	0BA8  2805    		jr	z,uboot1
1795: 9219+7	0BAA  FE62    		cp	'b'
1796: 9226+10	0BAC  C2230A  		jp	nz,uerror
1797: 9236+13	0BAF  3A0600  	uboot1:	ld	a,(ctask)
1798: 9249+17	0BB2  CD5D08  		call	tskbase
1799: 9266+11	0BB5  E5      		push	hl
1800: 9277+13	0BB6  3A0204  		ld	a,(switch)
1801: 9290+7	0BB9  E6F8    		and	0f8h
1802: 9297+7	0BBB  FE00    		cp	0			;check for a HDCA hard disk boot
1803: 9304+10	0BBD  CAD20B  		jp	z,uboot2
1804: 9314+7	0BC0  FE08    		cp	08h			;check for DMA hard disk boot
1805: 9321+10	0BC2  CAD20B  		jp	z,uboot2
1806: 9331+7	0BC5  FE10    		cp	010h			;check for DJ-DMA
1807: 9338+10	0BC7  CAD20B  		jp	z,uboot2
1808: 9348+10	0BCA  110D00  		ld	de,pcofst
1809: 9358+11	0BCD  19      		add	hl,de
1810: 9369+10	0BCE  3600    		ld	(hl),0
1811: 9379+6	0BD0  23      		inc	hl
1812: 9385+7	0BD1  77      		ld	(hl),a
1813: 9392+13	0BD2  3A0700  	uboot2: ld	a,(cmask)
1814: 9405+10	0BD5  E1      		pop	hl
1815: 9415+10	0BD6  111900  		ld	de,mskofst
1816: 9425+11	0BD9  19      		add	hl,de
1817: 9436+7	0BDA  77      		ld	(hl),a
1818: 9443+10	0BDB  C37808  		jp	oldtask
1819:				
1820:				
1821:				
1822:				;	MEMORY MISMATCH PRINTOUT
1823:				;
1824: 9453+4	0BDE  47      	UCERR:	LD	B,A
1825: 9457+17	0BDF  CD320A  		CALL	UHLSP
1826: 9474+7	0BE2  7E      		LD	A,(HL)
1827: 9481+17	0BE3  CDCB0A  		CALL	ULBYTE
1828: 9498+17	0BE6  CD350A  		CALL	UBLK
1829: 9515+4	0BE9  78      		LD	A,B
1830: 9519+17	0BEA  CDCB0A  		CALL	ULBYTE
1831: 9536+10	0BED  C3040A  		JP	UCRLF
1832:				;
1833:				
1834:				
1835:     -	0BF0          	ecode1	equ	$
1836:					ds	3f0h-(ecode1-rom1)
1837:				
1838:				;********************************************************
1839:				;*   							*
1840:				;*   The following piece of code is where the user	*
1841:				;*   task begins execution whenever a trap occurs.	*
1842:				;*   The users registers and sp are saved in the 	*
1843:				;*   temporary users store area.			*
1844:				;*							*
1845:				;********************************************************
1846:				
1847: 9546+4	0BF0  00      		nop				;must be a nop to void instruction
1848: 9550+20	0BF1  ED73A601		ld 	(u.sp),sp		;save the users stack pointer
1849: 9570+10	0BF5  31A601  		ld	sp,u.sp			;set sp to the temporary save area
1850: 9580+11	0BF8  F5      		push	Af			;save the users registers in temp area
1851: 9591+11	0BF9  E5      		push	hl
1852: 9602+11	0BFA  D5      		push	de
1853: 9613+11	0BFB  C5      		push	bc
1854: 9624+17	0BFC  CD0008  		call 	svtrap			;go to supervisor trap, pc is save
1855:				
1856:				
1857: 9641+4	0BFF  76      		halt				;to allow halts in task 0
1858:     -	0C00          	erom1	equ	$						
1859:					ds	400h-(erom1-rom1)
1860:					
1861:				
1862:				
1863:     -	0C00 .. 0C07 00	fpp0:	ds	8
1864:     -	0C08 .. 0C08 00	fpp1:	ds	1
1865:				
1866:     -	0C09          		end



Statistics:

     4	passes
     0	jr promotions
   322	symbols
  2091	bytes



Symbol Table:

acr            =   d     
adi4           =   4     
adi8           =   0     
aff            =   c     
afofst         =  15     
alf            =   a     
allerr           a6b     
arg            =1087     
asp            =  20     
attn           =  55     
badram           94e     
base           =  48     
bcofst         =   f     
begin0           b9e     
bel            =   7     
bootad         =1100     
bootbl           bb3     
boothd           aa3     
bsp            =   8     
btable           ba5     
callop         =  cd     
chan           =1080     
check            972     
cloop            a3e     
cloop0           a40     
cloop1           a45     
cloop2           a5a     
cmask              7     
cmmd           =108b     
cold             916     
commd          =  51     
complt         =   4     
const          =   4     
contin           b96     
contrl         =  50     
ctask              6     
cyl            =  99     
data           =  53     
default          b52     
deofst         =  11     
derror           a62     
djdma            9c9     
djloop           9ce     
djlop0           9cb     
djstat         =104a     
dlab           =  80     
dll            =  48     
dlm            =  49     
dmaddr         =1084     
dmarst         =  54     
dpmap            8c5     
dpmap0           8d0     
dr             =   1     
dread          =   1     
dready         =   4     
drenbl         =   5     
drivea         =  fc     
dskrun         =   7     
dspcol           401     
dspseg           400     
dupmap           80f     
dxloop           b10     
ecode0         = bee     
ecode1         = bf0     
elocio         = 404     
endboot        = bc3     
endrd          = bd0     
eoi            =  20     
erom0          = c00     
erom1          = c00     
ersav          = 1b8     
fmap             918     
format         =   3     
fpp0             c00     
fpp1             c08     
functn         =  52     
getmap           80c     
getsw            85a     
gobuff         = 1aa     
good           =  ff     
gotask           87b     
gotsk            809     
group0         =   8     
group1         =   9     
group2         =   a     
group3         =   b     
grpctl         =  4f     
gtmap            8b9     
hdcerr           a99     
hdclop           a79     
hdlop1           a7c     
hdrl             a11     
hdsetl         =  c8     
hdspt          =  11     
header         =   8     
heads          =   4     
hivect         =   0     
hlofst         =  13     
home             a17     
hstrap         =  1a     
ic4            =   1     
icw1           =  4c     
icw2           =  4d     
icw3           =  4d     
icw4           =  4d     
ier            =  49     
imask          =   0     
init           =  10     
ioaddr         =  50     
iopb           =1050     
ivalu          =  1f     
iwait1           acb     
iwait2           ad0     
iwait3           ad5     
jmpop          =  c3     
jtable         = bd0     
keybd            401     
lcr            =  4b     
link           =108d     
lloop            b03     
locio          = 400     
loop           =  10     
lovect         =   0     
lsr            =  4d     
ltim           =   8     
map              200     
mapram           600     
mask             403     
mcr            =  4c     
monitor          902     
montor           982     
mskofst        =  19     
nexchk           943     
nmap             806     
noop           =   6     
nop            =   0     
normal         =   0     
nstat            9f1     
ntbus            8a8     
nuboot           9f7     
nutask           986     
nxtbyte        =  76     
ocw1           =  4d     
ocw2           =  4c     
oldtask          878     
opdone         =   2     
otask            818     
pcofst         =   d     
picmask        =  ff     
picset           9af     
putmap           8eb     
putmxx           8f8     
ram            =   0     
ramchk           937     
rbr            =  48     
rdata            a2a     
rdtbl            bc3     
rduart           b7b     
readat         =   0     
ready          =  20     
regrd            800     
regwr            80e     
regwr1           80f     
reset            85f     
reset0           8e3     
reset1           8ef     
reslop           8ff     
reslp1           90f     
reslp2           902     
restor           86d     
restr            815     
revnum         =   d     
rhead          =   2     
rloop            aab     
rom0           = 800     
rom1           = 800     
rstmap           b18     
rstmxx           b26     
sdone            ac8     
secsiz         =   7     
secstat        =  51     
sector         =   1     
sekcmp         =   8     
select         =1083     
sense          =   5     
setit            b55     
settle           8f2     
setup            922     
sngl           =   2     
spofst         =  17     
ssmode         =  36     
stack          = 200     
start            bf9     
statis         =108c     
stats            403     
status         =  50     
stb            =   4     
stepin         =   0     
stepo          =  f8     
stepout        =  10     
stpdly         =  1e     
super              0     
svtrap           800     
switch           402     
system         =  80     
t0mask         =  2b     
t1mask         =  2b     
task             402     
tasks              8     
tasksiz        =  1a     
tbus             876     
tfpp             84e     
thr            =  48     
thre           =  20     
tmap             821     
track0         =   1     
tram             83a     
tram1            83f     
trappd           81b     
trk0           =   1     
trpadd           400     
tskbase          85d     
tskbse           803     
tsklp            868     
tsmod            8fd     
tstsw            95c     
u..b             b6e     
u.af             1a4     
u.ir             18f     
u.mask           1a8     
u.pc             19c     
u.save           18e     
u.sp             1a6     
uarts0           b2d     
uartst           b2b     
ublk             a35     
uboot            ba6     
uboot1           baf     
uboot2           bd2     
ucchk            a17     
ucerr            bde     
ucon1            a44     
ucon2            a47     
uconinit         a5d     
ucont1           b95     
ucontr           b8d     
uconv            a66     
ucopck           af8     
ucout1           a37     
ucout2           a3a     
ucrlf            a04     
ucsts            a52     
udblc            ad4     
udi0             94a     
udi1             952     
udisp            947     
uerror           a23     
uex0             a80     
uex1             a83     
uex2             a91     
uex3             a9b     
uexlf            9ff     
uexpr            a7d     
uexpr1           a7b     
uexpr3           a70     
ufi0             96b     
ufill            960     
ufill0           968     
ugoto            974     
ugoto0           97c     
uhexd            aba     
uhexn            ab2     
uhilo            aa8     
uhilox           aa2     
uhlsp            a32     
uin              b36     
uladr            ac6     
ulbyte           acb     
umemsiz          ada     
umove            9a8     
umtest           984     
umv0             9b3     
umvo0            9b0     
unibble          ade     
unibok           ae8     
upchk            afb     
uport            b24     
uq0              b3f     
uqchk            afe     
uqi1             b41     
uqi2             b46     
uqout            b52     
uretr1           b7c     
uretrn           b74     
urterr           b87     
user               3     
ustar0           932     
ustart           923     
ustore           9bb     
usu0             9d5     
usu1             9f1     
usubs            9c2     
usuo0            9cb     
ut1              98f     
ut10             98c     
ut2              9a2     
uti              b0a     
uver0            b62     
uverify          b5a     
uverio           b65     
wait             a87     
wait0            a89     
wait1            a8c     
waitc            ac1     
waitd            aee     
waitz            ab4     
wfault         =   2     
what             812     
window         =   1     
wls0           =   1     
wls1           =   2     
write          =   1     
